"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_pnpm_photoswipe_5_4_4_node_modules_photoswipe_dist_photoswipe-dce903"],{

/***/ "(app-pages-browser)/./node_modules/.pnpm/photoswipe@5.4.4/node_modules/photoswipe/dist/photoswipe.esm.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/photoswipe@5.4.4/node_modules/photoswipe/dist/photoswipe.esm.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ PhotoSwipe)\n/* harmony export */ });\n/*!\n  * PhotoSwipe 5.4.4 - https://photoswipe.com\n  * (c) 2024 Dmytro Semenov\n  */\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/**\r\n * @template {keyof HTMLElementTagNameMap} T\r\n * @param {string} className\r\n * @param {T} tagName\r\n * @param {Node} [appendToEl]\r\n * @returns {HTMLElementTagNameMap[T]}\r\n */\nfunction createElement(className, tagName, appendToEl) {\n  const el = document.createElement(tagName);\n\n  if (className) {\n    el.className = className;\n  }\n\n  if (appendToEl) {\n    appendToEl.appendChild(el);\n  }\n\n  return el;\n}\n/**\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {Point}\r\n */\n\nfunction equalizePoints(p1, p2) {\n  p1.x = p2.x;\n  p1.y = p2.y;\n\n  if (p2.id !== undefined) {\n    p1.id = p2.id;\n  }\n\n  return p1;\n}\n/**\r\n * @param {Point} p\r\n */\n\nfunction roundPoint(p) {\n  p.x = Math.round(p.x);\n  p.y = Math.round(p.y);\n}\n/**\r\n * Returns distance between two points.\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {number}\r\n */\n\nfunction getDistanceBetween(p1, p2) {\n  const x = Math.abs(p1.x - p2.x);\n  const y = Math.abs(p1.y - p2.y);\n  return Math.sqrt(x * x + y * y);\n}\n/**\r\n * Whether X and Y positions of points are equal\r\n *\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {boolean}\r\n */\n\nfunction pointsEqual(p1, p2) {\n  return p1.x === p2.x && p1.y === p2.y;\n}\n/**\r\n * The float result between the min and max values.\r\n *\r\n * @param {number} val\r\n * @param {number} min\r\n * @param {number} max\r\n * @returns {number}\r\n */\n\nfunction clamp(val, min, max) {\n  return Math.min(Math.max(val, min), max);\n}\n/**\r\n * Get transform string\r\n *\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n * @returns {string}\r\n */\n\nfunction toTransformString(x, y, scale) {\n  let propValue = `translate3d(${x}px,${y || 0}px,0)`;\n\n  if (scale !== undefined) {\n    propValue += ` scale3d(${scale},${scale},1)`;\n  }\n\n  return propValue;\n}\n/**\r\n * Apply transform:translate(x, y) scale(scale) to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {number} x\r\n * @param {number} [y]\r\n * @param {number} [scale]\r\n */\n\nfunction setTransform(el, x, y, scale) {\n  el.style.transform = toTransformString(x, y, scale);\n}\nconst defaultCSSEasing = 'cubic-bezier(.4,0,.22,1)';\n/**\r\n * Apply CSS transition to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string} [prop] CSS property to animate\r\n * @param {number} [duration] in ms\r\n * @param {string} [ease] CSS easing function\r\n */\n\nfunction setTransitionStyle(el, prop, duration, ease) {\n  // inOut: 'cubic-bezier(.4, 0, .22, 1)', // for \"toggle state\" transitions\n  // out: 'cubic-bezier(0, 0, .22, 1)', // for \"show\" transitions\n  // in: 'cubic-bezier(.4, 0, 1, 1)'// for \"hide\" transitions\n  el.style.transition = prop ? `${prop} ${duration}ms ${ease || defaultCSSEasing}` : 'none';\n}\n/**\r\n * Apply width and height CSS properties to element\r\n *\r\n * @param {HTMLElement} el\r\n * @param {string | number} w\r\n * @param {string | number} h\r\n */\n\nfunction setWidthHeight(el, w, h) {\n  el.style.width = typeof w === 'number' ? `${w}px` : w;\n  el.style.height = typeof h === 'number' ? `${h}px` : h;\n}\n/**\r\n * @param {HTMLElement} el\r\n */\n\nfunction removeTransitionStyle(el) {\n  setTransitionStyle(el);\n}\n/**\r\n * @param {HTMLImageElement} img\r\n * @returns {Promise<HTMLImageElement | void>}\r\n */\n\nfunction decodeImage(img) {\n  if ('decode' in img) {\n    return img.decode().catch(() => {});\n  }\n\n  if (img.complete) {\n    return Promise.resolve(img);\n  }\n\n  return new Promise((resolve, reject) => {\n    img.onload = () => resolve(img);\n\n    img.onerror = reject;\n  });\n}\n/** @typedef {LOAD_STATE[keyof LOAD_STATE]} LoadState */\n\n/** @type {{ IDLE: 'idle'; LOADING: 'loading'; LOADED: 'loaded'; ERROR: 'error' }} */\n\nconst LOAD_STATE = {\n  IDLE: 'idle',\n  LOADING: 'loading',\n  LOADED: 'loaded',\n  ERROR: 'error'\n};\n/**\r\n * Check if click or keydown event was dispatched\r\n * with a special key or via mouse wheel.\r\n *\r\n * @param {MouseEvent | KeyboardEvent} e\r\n * @returns {boolean}\r\n */\n\nfunction specialKeyUsed(e) {\n  return 'button' in e && e.button === 1 || e.ctrlKey || e.metaKey || e.altKey || e.shiftKey;\n}\n/**\r\n * Parse `gallery` or `children` options.\r\n *\r\n * @param {import('../photoswipe.js').ElementProvider} [option]\r\n * @param {string} [legacySelector]\r\n * @param {HTMLElement | Document} [parent]\r\n * @returns HTMLElement[]\r\n */\n\nfunction getElementsFromOption(option, legacySelector, parent = document) {\n  /** @type {HTMLElement[]} */\n  let elements = [];\n\n  if (option instanceof Element) {\n    elements = [option];\n  } else if (option instanceof NodeList || Array.isArray(option)) {\n    elements = Array.from(option);\n  } else {\n    const selector = typeof option === 'string' ? option : legacySelector;\n\n    if (selector) {\n      elements = Array.from(parent.querySelectorAll(selector));\n    }\n  }\n\n  return elements;\n}\n/**\r\n * Check if browser is Safari\r\n *\r\n * @returns {boolean}\r\n */\n\nfunction isSafari() {\n  return !!(navigator.vendor && navigator.vendor.match(/apple/i));\n}\n\n// Detect passive event listener support\nlet supportsPassive = false;\n/* eslint-disable */\n\ntry {\n  /* @ts-ignore */\n  window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n    get: () => {\n      supportsPassive = true;\n    }\n  }));\n} catch (e) {}\n/* eslint-enable */\n\n/**\r\n * @typedef {Object} PoolItem\r\n * @prop {HTMLElement | Window | Document | undefined | null} target\r\n * @prop {string} type\r\n * @prop {EventListenerOrEventListenerObject} listener\r\n * @prop {boolean} [passive]\r\n */\n\n\nclass DOMEvents {\n  constructor() {\n    /**\r\n     * @type {PoolItem[]}\r\n     * @private\r\n     */\n    this._pool = [];\n  }\n  /**\r\n   * Adds event listeners\r\n   *\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type Can be multiple, separated by space.\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   */\n\n\n  add(target, type, listener, passive) {\n    this._toggleListener(target, type, listener, passive);\n  }\n  /**\r\n   * Removes event listeners\r\n   *\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   */\n\n\n  remove(target, type, listener, passive) {\n    this._toggleListener(target, type, listener, passive, true);\n  }\n  /**\r\n   * Removes all bound events\r\n   */\n\n\n  removeAll() {\n    this._pool.forEach(poolItem => {\n      this._toggleListener(poolItem.target, poolItem.type, poolItem.listener, poolItem.passive, true, true);\n    });\n\n    this._pool = [];\n  }\n  /**\r\n   * Adds or removes event\r\n   *\r\n   * @private\r\n   * @param {PoolItem['target']} target\r\n   * @param {PoolItem['type']} type\r\n   * @param {PoolItem['listener']} listener\r\n   * @param {PoolItem['passive']} [passive]\r\n   * @param {boolean} [unbind] Whether the event should be added or removed\r\n   * @param {boolean} [skipPool] Whether events pool should be skipped\r\n   */\n\n\n  _toggleListener(target, type, listener, passive, unbind, skipPool) {\n    if (!target) {\n      return;\n    }\n\n    const methodName = unbind ? 'removeEventListener' : 'addEventListener';\n    const types = type.split(' ');\n    types.forEach(eType => {\n      if (eType) {\n        // Events pool is used to easily unbind all events when PhotoSwipe is closed,\n        // so developer doesn't need to do this manually\n        if (!skipPool) {\n          if (unbind) {\n            // Remove from the events pool\n            this._pool = this._pool.filter(poolItem => {\n              return poolItem.type !== eType || poolItem.listener !== listener || poolItem.target !== target;\n            });\n          } else {\n            // Add to the events pool\n            this._pool.push({\n              target,\n              type: eType,\n              listener,\n              passive\n            });\n          }\n        } // most PhotoSwipe events call preventDefault,\n        // and we do not need browser to scroll the page\n\n\n        const eventOptions = supportsPassive ? {\n          passive: passive || false\n        } : false;\n        target[methodName](eType, listener, eventOptions);\n      }\n    });\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\n\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {PhotoSwipeBase} pswp\r\n * @returns {Point}\r\n */\nfunction getViewportSize(options, pswp) {\n  if (options.getViewportSizeFn) {\n    const newViewportSize = options.getViewportSizeFn(options, pswp);\n\n    if (newViewportSize) {\n      return newViewportSize;\n    }\n  }\n\n  return {\n    x: document.documentElement.clientWidth,\n    // TODO: height on mobile is very incosistent due to toolbar\n    // find a way to improve this\n    //\n    // document.documentElement.clientHeight - doesn't seem to work well\n    y: window.innerHeight\n  };\n}\n/**\r\n * Parses padding option.\r\n * Supported formats:\r\n *\r\n * // Object\r\n * padding: {\r\n *  top: 0,\r\n *  bottom: 0,\r\n *  left: 0,\r\n *  right: 0\r\n * }\r\n *\r\n * // A function that returns the object\r\n * paddingFn: (viewportSize, itemData, index) => {\r\n *  return {\r\n *    top: 0,\r\n *    bottom: 0,\r\n *    left: 0,\r\n *    right: 0\r\n *  };\r\n * }\r\n *\r\n * // Legacy variant\r\n * paddingLeft: 0,\r\n * paddingRight: 0,\r\n * paddingTop: 0,\r\n * paddingBottom: 0,\r\n *\r\n * @param {'left' | 'top' | 'bottom' | 'right'} prop\r\n * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n * @param {Point} viewportSize PhotoSwipe viewport size, for example: { x:800, y:600 }\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {number} index Slide index\r\n * @returns {number}\r\n */\n\nfunction parsePaddingOption(prop, options, viewportSize, itemData, index) {\n  let paddingValue = 0;\n\n  if (options.paddingFn) {\n    paddingValue = options.paddingFn(viewportSize, itemData, index)[prop];\n  } else if (options.padding) {\n    paddingValue = options.padding[prop];\n  } else {\n    const legacyPropName = 'padding' + prop[0].toUpperCase() + prop.slice(1); // @ts-expect-error\n\n    if (options[legacyPropName]) {\n      // @ts-expect-error\n      paddingValue = options[legacyPropName];\n    }\n  }\n\n  return Number(paddingValue) || 0;\n}\n/**\r\n * @param {PhotoSwipeOptions} options\r\n * @param {Point} viewportSize\r\n * @param {SlideData} itemData\r\n * @param {number} index\r\n * @returns {Point}\r\n */\n\nfunction getPanAreaSize(options, viewportSize, itemData, index) {\n  return {\n    x: viewportSize.x - parsePaddingOption('left', options, viewportSize, itemData, index) - parsePaddingOption('right', options, viewportSize, itemData, index),\n    y: viewportSize.y - parsePaddingOption('top', options, viewportSize, itemData, index) - parsePaddingOption('bottom', options, viewportSize, itemData, index)\n  };\n}\n\n/** @typedef {import('./slide.js').default} Slide */\n\n/** @typedef {Record<Axis, number>} Point */\n\n/** @typedef {'x' | 'y'} Axis */\n\n/**\r\n * Calculates minimum, maximum and initial (center) bounds of a slide\r\n */\n\nclass PanBounds {\n  /**\r\n   * @param {Slide} slide\r\n   */\n  constructor(slide) {\n    this.slide = slide;\n    this.currZoomLevel = 1;\n    this.center =\n    /** @type {Point} */\n    {\n      x: 0,\n      y: 0\n    };\n    this.max =\n    /** @type {Point} */\n    {\n      x: 0,\n      y: 0\n    };\n    this.min =\n    /** @type {Point} */\n    {\n      x: 0,\n      y: 0\n    };\n  }\n  /**\r\n   * _getItemBounds\r\n   *\r\n   * @param {number} currZoomLevel\r\n   */\n\n\n  update(currZoomLevel) {\n    this.currZoomLevel = currZoomLevel;\n\n    if (!this.slide.width) {\n      this.reset();\n    } else {\n      this._updateAxis('x');\n\n      this._updateAxis('y');\n\n      this.slide.pswp.dispatch('calcBounds', {\n        slide: this.slide\n      });\n    }\n  }\n  /**\r\n   * _calculateItemBoundsForAxis\r\n   *\r\n   * @param {Axis} axis\r\n   */\n\n\n  _updateAxis(axis) {\n    const {\n      pswp\n    } = this.slide;\n    const elSize = this.slide[axis === 'x' ? 'width' : 'height'] * this.currZoomLevel;\n    const paddingProp = axis === 'x' ? 'left' : 'top';\n    const padding = parsePaddingOption(paddingProp, pswp.options, pswp.viewportSize, this.slide.data, this.slide.index);\n    const panAreaSize = this.slide.panAreaSize[axis]; // Default position of element.\n    // By default, it is center of viewport:\n\n    this.center[axis] = Math.round((panAreaSize - elSize) / 2) + padding; // maximum pan position\n\n    this.max[axis] = elSize > panAreaSize ? Math.round(panAreaSize - elSize) + padding : this.center[axis]; // minimum pan position\n\n    this.min[axis] = elSize > panAreaSize ? padding : this.center[axis];\n  } // _getZeroBounds\n\n\n  reset() {\n    this.center.x = 0;\n    this.center.y = 0;\n    this.max.x = 0;\n    this.max.y = 0;\n    this.min.x = 0;\n    this.min.y = 0;\n  }\n  /**\r\n   * Correct pan position if it's beyond the bounds\r\n   *\r\n   * @param {Axis} axis x or y\r\n   * @param {number} panOffset\r\n   * @returns {number}\r\n   */\n\n\n  correctPan(axis, panOffset) {\n    // checkPanBounds\n    return clamp(panOffset, this.max[axis], this.min[axis]);\n  }\n\n}\n\nconst MAX_IMAGE_WIDTH = 4000;\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\n\n/** @typedef {'fit' | 'fill' | number | ((zoomLevelObject: ZoomLevel) => number)} ZoomLevelOption */\n\n/**\r\n * Calculates zoom levels for specific slide.\r\n * Depends on viewport size and image size.\r\n */\n\nclass ZoomLevel {\n  /**\r\n   * @param {PhotoSwipeOptions} options PhotoSwipe options\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {number} index Slide index\r\n   * @param {PhotoSwipe} [pswp] PhotoSwipe instance, can be undefined if not initialized yet\r\n   */\n  constructor(options, itemData, index, pswp) {\n    this.pswp = pswp;\n    this.options = options;\n    this.itemData = itemData;\n    this.index = index;\n    /** @type { Point | null } */\n\n    this.panAreaSize = null;\n    /** @type { Point | null } */\n\n    this.elementSize = null;\n    this.fit = 1;\n    this.fill = 1;\n    this.vFill = 1;\n    this.initial = 1;\n    this.secondary = 1;\n    this.max = 1;\n    this.min = 1;\n  }\n  /**\r\n   * Calculate initial, secondary and maximum zoom level for the specified slide.\r\n   *\r\n   * It should be called when either image or viewport size changes.\r\n   *\r\n   * @param {number} maxWidth\r\n   * @param {number} maxHeight\r\n   * @param {Point} panAreaSize\r\n   */\n\n\n  update(maxWidth, maxHeight, panAreaSize) {\n    /** @type {Point} */\n    const elementSize = {\n      x: maxWidth,\n      y: maxHeight\n    };\n    this.elementSize = elementSize;\n    this.panAreaSize = panAreaSize;\n    const hRatio = panAreaSize.x / elementSize.x;\n    const vRatio = panAreaSize.y / elementSize.y;\n    this.fit = Math.min(1, hRatio < vRatio ? hRatio : vRatio);\n    this.fill = Math.min(1, hRatio > vRatio ? hRatio : vRatio); // zoom.vFill defines zoom level of the image\n    // when it has 100% of viewport vertical space (height)\n\n    this.vFill = Math.min(1, vRatio);\n    this.initial = this._getInitial();\n    this.secondary = this._getSecondary();\n    this.max = Math.max(this.initial, this.secondary, this._getMax());\n    this.min = Math.min(this.fit, this.initial, this.secondary);\n\n    if (this.pswp) {\n      this.pswp.dispatch('zoomLevelsUpdate', {\n        zoomLevels: this,\n        slideData: this.itemData\n      });\n    }\n  }\n  /**\r\n   * Parses user-defined zoom option.\r\n   *\r\n   * @private\r\n   * @param {'initial' | 'secondary' | 'max'} optionPrefix Zoom level option prefix (initial, secondary, max)\r\n   * @returns { number | undefined }\r\n   */\n\n\n  _parseZoomLevelOption(optionPrefix) {\n    const optionName =\n    /** @type {'initialZoomLevel' | 'secondaryZoomLevel' | 'maxZoomLevel'} */\n    optionPrefix + 'ZoomLevel';\n    const optionValue = this.options[optionName];\n\n    if (!optionValue) {\n      return;\n    }\n\n    if (typeof optionValue === 'function') {\n      return optionValue(this);\n    }\n\n    if (optionValue === 'fill') {\n      return this.fill;\n    }\n\n    if (optionValue === 'fit') {\n      return this.fit;\n    }\n\n    return Number(optionValue);\n  }\n  /**\r\n   * Get zoom level to which image will be zoomed after double-tap gesture,\r\n   * or when user clicks on zoom icon,\r\n   * or mouse-click on image itself.\r\n   * If you return 1 image will be zoomed to its original size.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getSecondary() {\n    let currZoomLevel = this._parseZoomLevelOption('secondary');\n\n    if (currZoomLevel) {\n      return currZoomLevel;\n    } // 3x of \"fit\" state, but not larger than original\n\n\n    currZoomLevel = Math.min(1, this.fit * 3);\n\n    if (this.elementSize && currZoomLevel * this.elementSize.x > MAX_IMAGE_WIDTH) {\n      currZoomLevel = MAX_IMAGE_WIDTH / this.elementSize.x;\n    }\n\n    return currZoomLevel;\n  }\n  /**\r\n   * Get initial image zoom level.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getInitial() {\n    return this._parseZoomLevelOption('initial') || this.fit;\n  }\n  /**\r\n   * Maximum zoom level when user zooms\r\n   * via zoom/pinch gesture,\r\n   * via cmd/ctrl-wheel or via trackpad.\r\n   *\r\n   * @private\r\n   * @return {number}\r\n   */\n\n\n  _getMax() {\n    // max zoom level is x4 from \"fit state\",\n    // used for zoom gesture and ctrl/trackpad zoom\n    return this._parseZoomLevelOption('max') || Math.max(1, this.fit * 4);\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n/**\r\n * Renders and allows to control a single slide\r\n */\n\nclass Slide {\n  /**\r\n   * @param {SlideData} data\r\n   * @param {number} index\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(data, index, pswp) {\n    this.data = data;\n    this.index = index;\n    this.pswp = pswp;\n    this.isActive = index === pswp.currIndex;\n    this.currentResolution = 0;\n    /** @type {Point} */\n\n    this.panAreaSize = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point} */\n\n    this.pan = {\n      x: 0,\n      y: 0\n    };\n    this.isFirstSlide = this.isActive && !pswp.opener.isOpen;\n    this.zoomLevels = new ZoomLevel(pswp.options, data, index, pswp);\n    this.pswp.dispatch('gettingData', {\n      slide: this,\n      data: this.data,\n      index\n    });\n    this.content = this.pswp.contentLoader.getContentBySlide(this);\n    this.container = createElement('pswp__zoom-wrap', 'div');\n    /** @type {HTMLElement | null} */\n\n    this.holderElement = null;\n    this.currZoomLevel = 1;\n    /** @type {number} */\n\n    this.width = this.content.width;\n    /** @type {number} */\n\n    this.height = this.content.height;\n    this.heavyAppended = false;\n    this.bounds = new PanBounds(this);\n    this.prevDisplayedWidth = -1;\n    this.prevDisplayedHeight = -1;\n    this.pswp.dispatch('slideInit', {\n      slide: this\n    });\n  }\n  /**\r\n   * If this slide is active/current/visible\r\n   *\r\n   * @param {boolean} isActive\r\n   */\n\n\n  setIsActive(isActive) {\n    if (isActive && !this.isActive) {\n      // slide just became active\n      this.activate();\n    } else if (!isActive && this.isActive) {\n      // slide just became non-active\n      this.deactivate();\n    }\n  }\n  /**\r\n   * Appends slide content to DOM\r\n   *\r\n   * @param {HTMLElement} holderElement\r\n   */\n\n\n  append(holderElement) {\n    this.holderElement = holderElement;\n    this.container.style.transformOrigin = '0 0'; // Slide appended to DOM\n\n    if (!this.data) {\n      return;\n    }\n\n    this.calculateSize();\n    this.load();\n    this.updateContentSize();\n    this.appendHeavy();\n    this.holderElement.appendChild(this.container);\n    this.zoomAndPanToInitial();\n    this.pswp.dispatch('firstZoomPan', {\n      slide: this\n    });\n    this.applyCurrentZoomPan();\n    this.pswp.dispatch('afterSetContent', {\n      slide: this\n    });\n\n    if (this.isActive) {\n      this.activate();\n    }\n  }\n\n  load() {\n    this.content.load(false);\n    this.pswp.dispatch('slideLoad', {\n      slide: this\n    });\n  }\n  /**\r\n   * Append \"heavy\" DOM elements\r\n   *\r\n   * This may depend on a type of slide,\r\n   * but generally these are large images.\r\n   */\n\n\n  appendHeavy() {\n    const {\n      pswp\n    } = this;\n    const appendHeavyNearby = true; // todo\n    // Avoid appending heavy elements during animations\n\n    if (this.heavyAppended || !pswp.opener.isOpen || pswp.mainScroll.isShifted() || !this.isActive && !appendHeavyNearby) {\n      return;\n    }\n\n    if (this.pswp.dispatch('appendHeavy', {\n      slide: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    this.heavyAppended = true;\n    this.content.append();\n    this.pswp.dispatch('appendHeavyContent', {\n      slide: this\n    });\n  }\n  /**\r\n   * Triggered when this slide is active (selected).\r\n   *\r\n   * If it's part of opening/closing transition -\r\n   * activate() will trigger after the transition is ended.\r\n   */\n\n\n  activate() {\n    this.isActive = true;\n    this.appendHeavy();\n    this.content.activate();\n    this.pswp.dispatch('slideActivate', {\n      slide: this\n    });\n  }\n  /**\r\n   * Triggered when this slide becomes inactive.\r\n   *\r\n   * Slide can become inactive only after it was active.\r\n   */\n\n\n  deactivate() {\n    this.isActive = false;\n    this.content.deactivate();\n\n    if (this.currZoomLevel !== this.zoomLevels.initial) {\n      // allow filtering\n      this.calculateSize();\n    } // reset zoom level\n\n\n    this.currentResolution = 0;\n    this.zoomAndPanToInitial();\n    this.applyCurrentZoomPan();\n    this.updateContentSize();\n    this.pswp.dispatch('slideDeactivate', {\n      slide: this\n    });\n  }\n  /**\r\n   * The slide should destroy itself, it will never be used again.\r\n   * (unbind all events and destroy internal components)\r\n   */\n\n\n  destroy() {\n    this.content.hasSlide = false;\n    this.content.remove();\n    this.container.remove();\n    this.pswp.dispatch('slideDestroy', {\n      slide: this\n    });\n  }\n\n  resize() {\n    if (this.currZoomLevel === this.zoomLevels.initial || !this.isActive) {\n      // Keep initial zoom level if it was before the resize,\n      // as well as when this slide is not active\n      // Reset position and scale to original state\n      this.calculateSize();\n      this.currentResolution = 0;\n      this.zoomAndPanToInitial();\n      this.applyCurrentZoomPan();\n      this.updateContentSize();\n    } else {\n      // readjust pan position if it's beyond the bounds\n      this.calculateSize();\n      this.bounds.update(this.currZoomLevel);\n      this.panTo(this.pan.x, this.pan.y);\n    }\n  }\n  /**\r\n   * Apply size to current slide content,\r\n   * based on the current resolution and scale.\r\n   *\r\n   * @param {boolean} [force] if size should be updated even if dimensions weren't changed\r\n   */\n\n\n  updateContentSize(force) {\n    // Use initial zoom level\n    // if resolution is not defined (user didn't zoom yet)\n    const scaleMultiplier = this.currentResolution || this.zoomLevels.initial;\n\n    if (!scaleMultiplier) {\n      return;\n    }\n\n    const width = Math.round(this.width * scaleMultiplier) || this.pswp.viewportSize.x;\n    const height = Math.round(this.height * scaleMultiplier) || this.pswp.viewportSize.y;\n\n    if (!this.sizeChanged(width, height) && !force) {\n      return;\n    }\n\n    this.content.setDisplayedSize(width, height);\n  }\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\n\n\n  sizeChanged(width, height) {\n    if (width !== this.prevDisplayedWidth || height !== this.prevDisplayedHeight) {\n      this.prevDisplayedWidth = width;\n      this.prevDisplayedHeight = height;\n      return true;\n    }\n\n    return false;\n  }\n  /** @returns {HTMLImageElement | HTMLDivElement | null | undefined} */\n\n\n  getPlaceholderElement() {\n    var _this$content$placeho;\n\n    return (_this$content$placeho = this.content.placeholder) === null || _this$content$placeho === void 0 ? void 0 : _this$content$placeho.element;\n  }\n  /**\r\n   * Zoom current slide image to...\r\n   *\r\n   * @param {number} destZoomLevel Destination zoom level.\r\n   * @param {Point} [centerPoint]\r\n   * Transform origin center point, or false if viewport center should be used.\r\n   * @param {number | false} [transitionDuration] Transition duration, may be set to 0.\r\n   * @param {boolean} [ignoreBounds] Minimum and maximum zoom levels will be ignored.\r\n   */\n\n\n  zoomTo(destZoomLevel, centerPoint, transitionDuration, ignoreBounds) {\n    const {\n      pswp\n    } = this;\n\n    if (!this.isZoomable() || pswp.mainScroll.isShifted()) {\n      return;\n    }\n\n    pswp.dispatch('beforeZoomTo', {\n      destZoomLevel,\n      centerPoint,\n      transitionDuration\n    }); // stop all pan and zoom transitions\n\n    pswp.animations.stopAllPan(); // if (!centerPoint) {\n    //   centerPoint = pswp.getViewportCenterPoint();\n    // }\n\n    const prevZoomLevel = this.currZoomLevel;\n\n    if (!ignoreBounds) {\n      destZoomLevel = clamp(destZoomLevel, this.zoomLevels.min, this.zoomLevels.max);\n    } // if (transitionDuration === undefined) {\n    //   transitionDuration = this.pswp.options.zoomAnimationDuration;\n    // }\n\n\n    this.setZoomLevel(destZoomLevel);\n    this.pan.x = this.calculateZoomToPanOffset('x', centerPoint, prevZoomLevel);\n    this.pan.y = this.calculateZoomToPanOffset('y', centerPoint, prevZoomLevel);\n    roundPoint(this.pan);\n\n    const finishTransition = () => {\n      this._setResolution(destZoomLevel);\n\n      this.applyCurrentZoomPan();\n    };\n\n    if (!transitionDuration) {\n      finishTransition();\n    } else {\n      pswp.animations.startTransition({\n        isPan: true,\n        name: 'zoomTo',\n        target: this.container,\n        transform: this.getCurrentTransform(),\n        onComplete: finishTransition,\n        duration: transitionDuration,\n        easing: pswp.options.easing\n      });\n    }\n  }\n  /**\r\n   * @param {Point} [centerPoint]\r\n   */\n\n\n  toggleZoom(centerPoint) {\n    this.zoomTo(this.currZoomLevel === this.zoomLevels.initial ? this.zoomLevels.secondary : this.zoomLevels.initial, centerPoint, this.pswp.options.zoomAnimationDuration);\n  }\n  /**\r\n   * Updates zoom level property and recalculates new pan bounds,\r\n   * unlike zoomTo it does not apply transform (use applyCurrentZoomPan)\r\n   *\r\n   * @param {number} currZoomLevel\r\n   */\n\n\n  setZoomLevel(currZoomLevel) {\n    this.currZoomLevel = currZoomLevel;\n    this.bounds.update(this.currZoomLevel);\n  }\n  /**\r\n   * Get pan position after zoom at a given `point`.\r\n   *\r\n   * Always call setZoomLevel(newZoomLevel) beforehand to recalculate\r\n   * pan bounds according to the new zoom level.\r\n   *\r\n   * @param {'x' | 'y'} axis\r\n   * @param {Point} [point]\r\n   * point based on which zoom is performed, usually refers to the current mouse position,\r\n   * if false - viewport center will be used.\r\n   * @param {number} [prevZoomLevel] Zoom level before new zoom was applied.\r\n   * @returns {number}\r\n   */\n\n\n  calculateZoomToPanOffset(axis, point, prevZoomLevel) {\n    const totalPanDistance = this.bounds.max[axis] - this.bounds.min[axis];\n\n    if (totalPanDistance === 0) {\n      return this.bounds.center[axis];\n    }\n\n    if (!point) {\n      point = this.pswp.getViewportCenterPoint();\n    }\n\n    if (!prevZoomLevel) {\n      prevZoomLevel = this.zoomLevels.initial;\n    }\n\n    const zoomFactor = this.currZoomLevel / prevZoomLevel;\n    return this.bounds.correctPan(axis, (this.pan[axis] - point[axis]) * zoomFactor + point[axis]);\n  }\n  /**\r\n   * Apply pan and keep it within bounds.\r\n   *\r\n   * @param {number} panX\r\n   * @param {number} panY\r\n   */\n\n\n  panTo(panX, panY) {\n    this.pan.x = this.bounds.correctPan('x', panX);\n    this.pan.y = this.bounds.correctPan('y', panY);\n    this.applyCurrentZoomPan();\n  }\n  /**\r\n   * If the slide in the current state can be panned by the user\r\n   * @returns {boolean}\r\n   */\n\n\n  isPannable() {\n    return Boolean(this.width) && this.currZoomLevel > this.zoomLevels.fit;\n  }\n  /**\r\n   * If the slide can be zoomed\r\n   * @returns {boolean}\r\n   */\n\n\n  isZoomable() {\n    return Boolean(this.width) && this.content.isZoomable();\n  }\n  /**\r\n   * Apply transform and scale based on\r\n   * the current pan position (this.pan) and zoom level (this.currZoomLevel)\r\n   */\n\n\n  applyCurrentZoomPan() {\n    this._applyZoomTransform(this.pan.x, this.pan.y, this.currZoomLevel);\n\n    if (this === this.pswp.currSlide) {\n      this.pswp.dispatch('zoomPanUpdate', {\n        slide: this\n      });\n    }\n  }\n\n  zoomAndPanToInitial() {\n    this.currZoomLevel = this.zoomLevels.initial; // pan according to the zoom level\n\n    this.bounds.update(this.currZoomLevel);\n    equalizePoints(this.pan, this.bounds.center);\n    this.pswp.dispatch('initialZoomPan', {\n      slide: this\n    });\n  }\n  /**\r\n   * Set translate and scale based on current resolution\r\n   *\r\n   * @param {number} x\r\n   * @param {number} y\r\n   * @param {number} zoom\r\n   * @private\r\n   */\n\n\n  _applyZoomTransform(x, y, zoom) {\n    zoom /= this.currentResolution || this.zoomLevels.initial;\n    setTransform(this.container, x, y, zoom);\n  }\n\n  calculateSize() {\n    const {\n      pswp\n    } = this;\n    equalizePoints(this.panAreaSize, getPanAreaSize(pswp.options, pswp.viewportSize, this.data, this.index));\n    this.zoomLevels.update(this.width, this.height, this.panAreaSize);\n    pswp.dispatch('calcSlideSize', {\n      slide: this\n    });\n  }\n  /** @returns {string} */\n\n\n  getCurrentTransform() {\n    const scale = this.currZoomLevel / (this.currentResolution || this.zoomLevels.initial);\n    return toTransformString(this.pan.x, this.pan.y, scale);\n  }\n  /**\r\n   * Set resolution and re-render the image.\r\n   *\r\n   * For example, if the real image size is 2000x1500,\r\n   * and resolution is 0.5 - it will be rendered as 1000x750.\r\n   *\r\n   * Image with zoom level 2 and resolution 0.5 is\r\n   * the same as image with zoom level 1 and resolution 1.\r\n   *\r\n   * Used to optimize animations and make\r\n   * sure that browser renders image in the highest quality.\r\n   * Also used by responsive images to load the correct one.\r\n   *\r\n   * @param {number} newResolution\r\n   */\n\n\n  _setResolution(newResolution) {\n    if (newResolution === this.currentResolution) {\n      return;\n    }\n\n    this.currentResolution = newResolution;\n    this.updateContentSize();\n    this.pswp.dispatch('resolutionChanged');\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/** @typedef {import('./gestures.js').default} Gestures */\n\nconst PAN_END_FRICTION = 0.35;\nconst VERTICAL_DRAG_FRICTION = 0.6; // 1 corresponds to the third of viewport height\n\nconst MIN_RATIO_TO_CLOSE = 0.4; // Minimum speed required to navigate\n// to next or previous slide\n\nconst MIN_NEXT_SLIDE_SPEED = 0.5;\n/**\r\n * @param {number} initialVelocity\r\n * @param {number} decelerationRate\r\n * @returns {number}\r\n */\n\nfunction project(initialVelocity, decelerationRate) {\n  return initialVelocity * decelerationRate / (1 - decelerationRate);\n}\n/**\r\n * Handles single pointer dragging\r\n */\n\n\nclass DragHandler {\n  /**\r\n   * @param {Gestures} gestures\r\n   */\n  constructor(gestures) {\n    this.gestures = gestures;\n    this.pswp = gestures.pswp;\n    /** @type {Point} */\n\n    this.startPan = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  start() {\n    if (this.pswp.currSlide) {\n      equalizePoints(this.startPan, this.pswp.currSlide.pan);\n    }\n\n    this.pswp.animations.stopAll();\n  }\n\n  change() {\n    const {\n      p1,\n      prevP1,\n      dragAxis\n    } = this.gestures;\n    const {\n      currSlide\n    } = this.pswp;\n\n    if (dragAxis === 'y' && this.pswp.options.closeOnVerticalDrag && currSlide && currSlide.currZoomLevel <= currSlide.zoomLevels.fit && !this.gestures.isMultitouch) {\n      // Handle vertical drag to close\n      const panY = currSlide.pan.y + (p1.y - prevP1.y);\n\n      if (!this.pswp.dispatch('verticalDrag', {\n        panY\n      }).defaultPrevented) {\n        this._setPanWithFriction('y', panY, VERTICAL_DRAG_FRICTION);\n\n        const bgOpacity = 1 - Math.abs(this._getVerticalDragRatio(currSlide.pan.y));\n        this.pswp.applyBgOpacity(bgOpacity);\n        currSlide.applyCurrentZoomPan();\n      }\n    } else {\n      const mainScrollChanged = this._panOrMoveMainScroll('x');\n\n      if (!mainScrollChanged) {\n        this._panOrMoveMainScroll('y');\n\n        if (currSlide) {\n          roundPoint(currSlide.pan);\n          currSlide.applyCurrentZoomPan();\n        }\n      }\n    }\n  }\n\n  end() {\n    const {\n      velocity\n    } = this.gestures;\n    const {\n      mainScroll,\n      currSlide\n    } = this.pswp;\n    let indexDiff = 0;\n    this.pswp.animations.stopAll(); // Handle main scroll if it's shifted\n\n    if (mainScroll.isShifted()) {\n      // Position of the main scroll relative to the viewport\n      const mainScrollShiftDiff = mainScroll.x - mainScroll.getCurrSlideX(); // Ratio between 0 and 1:\n      // 0 - slide is not visible at all,\n      // 0.5 - half of the slide is visible\n      // 1 - slide is fully visible\n\n      const currentSlideVisibilityRatio = mainScrollShiftDiff / this.pswp.viewportSize.x; // Go next slide.\n      //\n      // - if velocity and its direction is matched,\n      //   and we see at least tiny part of the next slide\n      //\n      // - or if we see less than 50% of the current slide\n      //   and velocity is close to 0\n      //\n\n      if (velocity.x < -MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio < 0 || velocity.x < 0.1 && currentSlideVisibilityRatio < -0.5) {\n        // Go to next slide\n        indexDiff = 1;\n        velocity.x = Math.min(velocity.x, 0);\n      } else if (velocity.x > MIN_NEXT_SLIDE_SPEED && currentSlideVisibilityRatio > 0 || velocity.x > -0.1 && currentSlideVisibilityRatio > 0.5) {\n        // Go to prev slide\n        indexDiff = -1;\n        velocity.x = Math.max(velocity.x, 0);\n      }\n\n      mainScroll.moveIndexBy(indexDiff, true, velocity.x);\n    } // Restore zoom level\n\n\n    if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.max || this.gestures.isMultitouch) {\n      this.gestures.zoomLevels.correctZoomPan(true);\n    } else {\n      // we run two animations instead of one,\n      // as each axis has own pan boundaries and thus different spring function\n      // (correctZoomPan does not have this functionality,\n      //  it animates all properties with single timing function)\n      this._finishPanGestureForAxis('x');\n\n      this._finishPanGestureForAxis('y');\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   */\n\n\n  _finishPanGestureForAxis(axis) {\n    const {\n      velocity\n    } = this.gestures;\n    const {\n      currSlide\n    } = this.pswp;\n\n    if (!currSlide) {\n      return;\n    }\n\n    const {\n      pan,\n      bounds\n    } = currSlide;\n    const panPos = pan[axis];\n    const restoreBgOpacity = this.pswp.bgOpacity < 1 && axis === 'y'; // 0.995 means - scroll view loses 0.5% of its velocity per millisecond\n    // Increasing this number will reduce travel distance\n\n    const decelerationRate = 0.995; // 0.99\n    // Pan position if there is no bounds\n\n    const projectedPosition = panPos + project(velocity[axis], decelerationRate);\n\n    if (restoreBgOpacity) {\n      const vDragRatio = this._getVerticalDragRatio(panPos);\n\n      const projectedVDragRatio = this._getVerticalDragRatio(projectedPosition); // If we are above and moving upwards,\n      // or if we are below and moving downwards\n\n\n      if (vDragRatio < 0 && projectedVDragRatio < -MIN_RATIO_TO_CLOSE || vDragRatio > 0 && projectedVDragRatio > MIN_RATIO_TO_CLOSE) {\n        this.pswp.close();\n        return;\n      }\n    } // Pan position with corrected bounds\n\n\n    const correctedPanPosition = bounds.correctPan(axis, projectedPosition); // Exit if pan position should not be changed\n    // or if speed it too low\n\n    if (panPos === correctedPanPosition) {\n      return;\n    } // Overshoot if the final position is out of pan bounds\n\n\n    const dampingRatio = correctedPanPosition === projectedPosition ? 1 : 0.82;\n    const initialBgOpacity = this.pswp.bgOpacity;\n    const totalPanDist = correctedPanPosition - panPos;\n    this.pswp.animations.startSpring({\n      name: 'panGesture' + axis,\n      isPan: true,\n      start: panPos,\n      end: correctedPanPosition,\n      velocity: velocity[axis],\n      dampingRatio,\n      onUpdate: pos => {\n        // Animate opacity of background relative to Y pan position of an image\n        if (restoreBgOpacity && this.pswp.bgOpacity < 1) {\n          // 0 - start of animation, 1 - end of animation\n          const animationProgressRatio = 1 - (correctedPanPosition - pos) / totalPanDist; // We clamp opacity to keep it between 0 and 1.\n          // As progress ratio can be larger than 1 due to overshoot,\n          // and we do not want to bounce opacity.\n\n          this.pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * animationProgressRatio, 0, 1));\n        }\n\n        pan[axis] = Math.floor(pos);\n        currSlide.applyCurrentZoomPan();\n      }\n    });\n  }\n  /**\r\n   * Update position of the main scroll,\r\n   * or/and update pan position of the current slide.\r\n   *\r\n   * Should return true if it changes (or can change) main scroll.\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @returns {boolean}\r\n   */\n\n\n  _panOrMoveMainScroll(axis) {\n    const {\n      p1,\n      dragAxis,\n      prevP1,\n      isMultitouch\n    } = this.gestures;\n    const {\n      currSlide,\n      mainScroll\n    } = this.pswp;\n    const delta = p1[axis] - prevP1[axis];\n    const newMainScrollX = mainScroll.x + delta;\n\n    if (!delta || !currSlide) {\n      return false;\n    } // Always move main scroll if image can not be panned\n\n\n    if (axis === 'x' && !currSlide.isPannable() && !isMultitouch) {\n      mainScroll.moveTo(newMainScrollX, true);\n      return true; // changed main scroll\n    }\n\n    const {\n      bounds\n    } = currSlide;\n    const newPan = currSlide.pan[axis] + delta;\n\n    if (this.pswp.options.allowPanToNext && dragAxis === 'x' && axis === 'x' && !isMultitouch) {\n      const currSlideMainScrollX = mainScroll.getCurrSlideX(); // Position of the main scroll relative to the viewport\n\n      const mainScrollShiftDiff = mainScroll.x - currSlideMainScrollX;\n      const isLeftToRight = delta > 0;\n      const isRightToLeft = !isLeftToRight;\n\n      if (newPan > bounds.min[axis] && isLeftToRight) {\n        // Panning from left to right, beyond the left edge\n        // Wether the image was at minimum pan position (or less)\n        // when this drag gesture started.\n        // Minimum pan position refers to the left edge of the image.\n        const wasAtMinPanPosition = bounds.min[axis] <= this.startPan[axis];\n\n        if (wasAtMinPanPosition) {\n          mainScroll.moveTo(newMainScrollX, true);\n          return true;\n        } else {\n          this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;\n\n        }\n      } else if (newPan < bounds.max[axis] && isRightToLeft) {\n        // Paning from right to left, beyond the right edge\n        // Maximum pan position refers to the right edge of the image.\n        const wasAtMaxPanPosition = this.startPan[axis] <= bounds.max[axis];\n\n        if (wasAtMaxPanPosition) {\n          mainScroll.moveTo(newMainScrollX, true);\n          return true;\n        } else {\n          this._setPanWithFriction(axis, newPan); //currSlide.pan[axis] = newPan;\n\n        }\n      } else {\n        // If main scroll is shifted\n        if (mainScrollShiftDiff !== 0) {\n          // If main scroll is shifted right\n          if (mainScrollShiftDiff > 0\n          /*&& isRightToLeft*/\n          ) {\n            mainScroll.moveTo(Math.max(newMainScrollX, currSlideMainScrollX), true);\n            return true;\n          } else if (mainScrollShiftDiff < 0\n          /*&& isLeftToRight*/\n          ) {\n            // Main scroll is shifted left (Position is less than 0 comparing to the viewport 0)\n            mainScroll.moveTo(Math.min(newMainScrollX, currSlideMainScrollX), true);\n            return true;\n          }\n        } else {\n          // We are within pan bounds, so just pan\n          this._setPanWithFriction(axis, newPan);\n        }\n      }\n    } else {\n      if (axis === 'y') {\n        // Do not pan vertically if main scroll is shifted o\n        if (!mainScroll.isShifted() && bounds.min.y !== bounds.max.y) {\n          this._setPanWithFriction(axis, newPan);\n        }\n      } else {\n        this._setPanWithFriction(axis, newPan);\n      }\n    }\n\n    return false;\n  } // If we move above - the ratio is negative\n  // If we move below the ratio is positive\n\n  /**\r\n   * Relation between pan Y position and third of viewport height.\r\n   *\r\n   * When we are at initial position (center bounds) - the ratio is 0,\r\n   * if position is shifted upwards - the ratio is negative,\r\n   * if position is shifted downwards - the ratio is positive.\r\n   *\r\n   * @private\r\n   * @param {number} panY The current pan Y position.\r\n   * @returns {number}\r\n   */\n\n\n  _getVerticalDragRatio(panY) {\n    var _this$pswp$currSlide$, _this$pswp$currSlide;\n\n    return (panY - ((_this$pswp$currSlide$ = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.bounds.center.y) !== null && _this$pswp$currSlide$ !== void 0 ? _this$pswp$currSlide$ : 0)) / (this.pswp.viewportSize.y / 3);\n  }\n  /**\r\n   * Set pan position of the current slide.\r\n   * Apply friction if the position is beyond the pan bounds,\r\n   * or if custom friction is defined.\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} potentialPan\r\n   * @param {number} [customFriction] (0.1 - 1)\r\n   */\n\n\n  _setPanWithFriction(axis, potentialPan, customFriction) {\n    const {\n      currSlide\n    } = this.pswp;\n\n    if (!currSlide) {\n      return;\n    }\n\n    const {\n      pan,\n      bounds\n    } = currSlide;\n    const correctedPan = bounds.correctPan(axis, potentialPan); // If we are out of pan bounds\n\n    if (correctedPan !== potentialPan || customFriction) {\n      const delta = Math.round(potentialPan - pan[axis]);\n      pan[axis] += delta * (customFriction || PAN_END_FRICTION);\n    } else {\n      pan[axis] = potentialPan;\n    }\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/** @typedef {import('./gestures.js').default} Gestures */\n\nconst UPPER_ZOOM_FRICTION = 0.05;\nconst LOWER_ZOOM_FRICTION = 0.15;\n/**\r\n * Get center point between two points\r\n *\r\n * @param {Point} p\r\n * @param {Point} p1\r\n * @param {Point} p2\r\n * @returns {Point}\r\n */\n\nfunction getZoomPointsCenter(p, p1, p2) {\n  p.x = (p1.x + p2.x) / 2;\n  p.y = (p1.y + p2.y) / 2;\n  return p;\n}\n\nclass ZoomHandler {\n  /**\r\n   * @param {Gestures} gestures\r\n   */\n  constructor(gestures) {\n    this.gestures = gestures;\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\n\n    this._startPan = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\n\n    this._startZoomPoint = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * @private\r\n     * @type {Point}\r\n     */\n\n    this._zoomPoint = {\n      x: 0,\n      y: 0\n    };\n    /** @private */\n\n    this._wasOverFitZoomLevel = false;\n    /** @private */\n\n    this._startZoomLevel = 1;\n  }\n\n  start() {\n    const {\n      currSlide\n    } = this.gestures.pswp;\n\n    if (currSlide) {\n      this._startZoomLevel = currSlide.currZoomLevel;\n      equalizePoints(this._startPan, currSlide.pan);\n    }\n\n    this.gestures.pswp.animations.stopAllPan();\n    this._wasOverFitZoomLevel = false;\n  }\n\n  change() {\n    const {\n      p1,\n      startP1,\n      p2,\n      startP2,\n      pswp\n    } = this.gestures;\n    const {\n      currSlide\n    } = pswp;\n\n    if (!currSlide) {\n      return;\n    }\n\n    const minZoomLevel = currSlide.zoomLevels.min;\n    const maxZoomLevel = currSlide.zoomLevels.max;\n\n    if (!currSlide.isZoomable() || pswp.mainScroll.isShifted()) {\n      return;\n    }\n\n    getZoomPointsCenter(this._startZoomPoint, startP1, startP2);\n    getZoomPointsCenter(this._zoomPoint, p1, p2);\n\n    let currZoomLevel = 1 / getDistanceBetween(startP1, startP2) * getDistanceBetween(p1, p2) * this._startZoomLevel; // slightly over the zoom.fit\n\n\n    if (currZoomLevel > currSlide.zoomLevels.initial + currSlide.zoomLevels.initial / 15) {\n      this._wasOverFitZoomLevel = true;\n    }\n\n    if (currZoomLevel < minZoomLevel) {\n      if (pswp.options.pinchToClose && !this._wasOverFitZoomLevel && this._startZoomLevel <= currSlide.zoomLevels.initial) {\n        // fade out background if zooming out\n        const bgOpacity = 1 - (minZoomLevel - currZoomLevel) / (minZoomLevel / 1.2);\n\n        if (!pswp.dispatch('pinchClose', {\n          bgOpacity\n        }).defaultPrevented) {\n          pswp.applyBgOpacity(bgOpacity);\n        }\n      } else {\n        // Apply the friction if zoom level is below the min\n        currZoomLevel = minZoomLevel - (minZoomLevel - currZoomLevel) * LOWER_ZOOM_FRICTION;\n      }\n    } else if (currZoomLevel > maxZoomLevel) {\n      // Apply the friction if zoom level is above the max\n      currZoomLevel = maxZoomLevel + (currZoomLevel - maxZoomLevel) * UPPER_ZOOM_FRICTION;\n    }\n\n    currSlide.pan.x = this._calculatePanForZoomLevel('x', currZoomLevel);\n    currSlide.pan.y = this._calculatePanForZoomLevel('y', currZoomLevel);\n    currSlide.setZoomLevel(currZoomLevel);\n    currSlide.applyCurrentZoomPan();\n  }\n\n  end() {\n    const {\n      pswp\n    } = this.gestures;\n    const {\n      currSlide\n    } = pswp;\n\n    if ((!currSlide || currSlide.currZoomLevel < currSlide.zoomLevels.initial) && !this._wasOverFitZoomLevel && pswp.options.pinchToClose) {\n      pswp.close();\n    } else {\n      this.correctZoomPan();\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} currZoomLevel\r\n   * @returns {number}\r\n   */\n\n\n  _calculatePanForZoomLevel(axis, currZoomLevel) {\n    const zoomFactor = currZoomLevel / this._startZoomLevel;\n    return this._zoomPoint[axis] - (this._startZoomPoint[axis] - this._startPan[axis]) * zoomFactor;\n  }\n  /**\r\n   * Correct currZoomLevel and pan if they are\r\n   * beyond minimum or maximum values.\r\n   * With animation.\r\n   *\r\n   * @param {boolean} [ignoreGesture]\r\n   * Wether gesture coordinates should be ignored when calculating destination pan position.\r\n   */\n\n\n  correctZoomPan(ignoreGesture) {\n    const {\n      pswp\n    } = this.gestures;\n    const {\n      currSlide\n    } = pswp;\n\n    if (!(currSlide !== null && currSlide !== void 0 && currSlide.isZoomable())) {\n      return;\n    }\n\n    if (this._zoomPoint.x === 0) {\n      ignoreGesture = true;\n    }\n\n    const prevZoomLevel = currSlide.currZoomLevel;\n    /** @type {number} */\n\n    let destinationZoomLevel;\n    let currZoomLevelNeedsChange = true;\n\n    if (prevZoomLevel < currSlide.zoomLevels.initial) {\n      destinationZoomLevel = currSlide.zoomLevels.initial; // zoom to min\n    } else if (prevZoomLevel > currSlide.zoomLevels.max) {\n      destinationZoomLevel = currSlide.zoomLevels.max; // zoom to max\n    } else {\n      currZoomLevelNeedsChange = false;\n      destinationZoomLevel = prevZoomLevel;\n    }\n\n    const initialBgOpacity = pswp.bgOpacity;\n    const restoreBgOpacity = pswp.bgOpacity < 1;\n    const initialPan = equalizePoints({\n      x: 0,\n      y: 0\n    }, currSlide.pan);\n    let destinationPan = equalizePoints({\n      x: 0,\n      y: 0\n    }, initialPan);\n\n    if (ignoreGesture) {\n      this._zoomPoint.x = 0;\n      this._zoomPoint.y = 0;\n      this._startZoomPoint.x = 0;\n      this._startZoomPoint.y = 0;\n      this._startZoomLevel = prevZoomLevel;\n      equalizePoints(this._startPan, initialPan);\n    }\n\n    if (currZoomLevelNeedsChange) {\n      destinationPan = {\n        x: this._calculatePanForZoomLevel('x', destinationZoomLevel),\n        y: this._calculatePanForZoomLevel('y', destinationZoomLevel)\n      };\n    } // set zoom level, so pan bounds are updated according to it\n\n\n    currSlide.setZoomLevel(destinationZoomLevel);\n    destinationPan = {\n      x: currSlide.bounds.correctPan('x', destinationPan.x),\n      y: currSlide.bounds.correctPan('y', destinationPan.y)\n    }; // return zoom level and its bounds to initial\n\n    currSlide.setZoomLevel(prevZoomLevel);\n    const panNeedsChange = !pointsEqual(destinationPan, initialPan);\n\n    if (!panNeedsChange && !currZoomLevelNeedsChange && !restoreBgOpacity) {\n      // update resolution after gesture\n      currSlide._setResolution(destinationZoomLevel);\n\n      currSlide.applyCurrentZoomPan(); // nothing to animate\n\n      return;\n    }\n\n    pswp.animations.stopAllPan();\n    pswp.animations.startSpring({\n      isPan: true,\n      start: 0,\n      end: 1000,\n      velocity: 0,\n      dampingRatio: 1,\n      naturalFrequency: 40,\n      onUpdate: now => {\n        now /= 1000; // 0 - start, 1 - end\n\n        if (panNeedsChange || currZoomLevelNeedsChange) {\n          if (panNeedsChange) {\n            currSlide.pan.x = initialPan.x + (destinationPan.x - initialPan.x) * now;\n            currSlide.pan.y = initialPan.y + (destinationPan.y - initialPan.y) * now;\n          }\n\n          if (currZoomLevelNeedsChange) {\n            const newZoomLevel = prevZoomLevel + (destinationZoomLevel - prevZoomLevel) * now;\n            currSlide.setZoomLevel(newZoomLevel);\n          }\n\n          currSlide.applyCurrentZoomPan();\n        } // Restore background opacity\n\n\n        if (restoreBgOpacity && pswp.bgOpacity < 1) {\n          // We clamp opacity to keep it between 0 and 1.\n          // As progress ratio can be larger than 1 due to overshoot,\n          // and we do not want to bounce opacity.\n          pswp.applyBgOpacity(clamp(initialBgOpacity + (1 - initialBgOpacity) * now, 0, 1));\n        }\n      },\n      onComplete: () => {\n        // update resolution after transition ends\n        currSlide._setResolution(destinationZoomLevel);\n\n        currSlide.applyCurrentZoomPan();\n      }\n    });\n  }\n\n}\n\n/**\r\n * @template {string} T\r\n * @template {string} P\r\n * @typedef {import('../types.js').AddPostfix<T, P>} AddPostfix<T, P>\r\n */\n\n/** @typedef {import('./gestures.js').default} Gestures */\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n\n/** @typedef {'imageClick' | 'bgClick' | 'tap' | 'doubleTap'} Actions */\n\n/**\r\n * Whether the tap was performed on the main slide\r\n * (rather than controls or caption).\r\n *\r\n * @param {PointerEvent} event\r\n * @returns {boolean}\r\n */\nfunction didTapOnMainContent(event) {\n  return !!\n  /** @type {HTMLElement} */\n  event.target.closest('.pswp__container');\n}\n/**\r\n * Tap, double-tap handler.\r\n */\n\n\nclass TapHandler {\n  /**\r\n   * @param {Gestures} gestures\r\n   */\n  constructor(gestures) {\n    this.gestures = gestures;\n  }\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\n\n\n  click(point, originalEvent) {\n    const targetClassList =\n    /** @type {HTMLElement} */\n    originalEvent.target.classList;\n    const isImageClick = targetClassList.contains('pswp__img');\n    const isBackgroundClick = targetClassList.contains('pswp__item') || targetClassList.contains('pswp__zoom-wrap');\n\n    if (isImageClick) {\n      this._doClickOrTapAction('imageClick', point, originalEvent);\n    } else if (isBackgroundClick) {\n      this._doClickOrTapAction('bgClick', point, originalEvent);\n    }\n  }\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\n\n\n  tap(point, originalEvent) {\n    if (didTapOnMainContent(originalEvent)) {\n      this._doClickOrTapAction('tap', point, originalEvent);\n    }\n  }\n  /**\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\n\n\n  doubleTap(point, originalEvent) {\n    if (didTapOnMainContent(originalEvent)) {\n      this._doClickOrTapAction('doubleTap', point, originalEvent);\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {Actions} actionName\r\n   * @param {Point} point\r\n   * @param {PointerEvent} originalEvent\r\n   */\n\n\n  _doClickOrTapAction(actionName, point, originalEvent) {\n    var _this$gestures$pswp$e;\n\n    const {\n      pswp\n    } = this.gestures;\n    const {\n      currSlide\n    } = pswp;\n    const actionFullName =\n    /** @type {AddPostfix<Actions, 'Action'>} */\n    actionName + 'Action';\n    const optionValue = pswp.options[actionFullName];\n\n    if (pswp.dispatch(actionFullName, {\n      point,\n      originalEvent\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (typeof optionValue === 'function') {\n      optionValue.call(pswp, point, originalEvent);\n      return;\n    }\n\n    switch (optionValue) {\n      case 'close':\n      case 'next':\n        pswp[optionValue]();\n        break;\n\n      case 'zoom':\n        currSlide === null || currSlide === void 0 || currSlide.toggleZoom(point);\n        break;\n\n      case 'zoom-or-close':\n        // by default click zooms current image,\n        // if it can not be zoomed - gallery will be closed\n        if (currSlide !== null && currSlide !== void 0 && currSlide.isZoomable() && currSlide.zoomLevels.secondary !== currSlide.zoomLevels.initial) {\n          currSlide.toggleZoom(point);\n        } else if (pswp.options.clickToCloseNonZoomable) {\n          pswp.close();\n        }\n\n        break;\n\n      case 'toggle-controls':\n        (_this$gestures$pswp$e = this.gestures.pswp.element) === null || _this$gestures$pswp$e === void 0 || _this$gestures$pswp$e.classList.toggle('pswp--ui-visible'); // if (_controlsVisible) {\n        //   _ui.hideControls();\n        // } else {\n        //   _ui.showControls();\n        // }\n\n        break;\n    }\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('../photoswipe.js').Point} Point */\n// How far should user should drag\n// until we can determine that the gesture is swipe and its direction\n\nconst AXIS_SWIPE_HYSTERISIS = 10; //const PAN_END_FRICTION = 0.35;\n\nconst DOUBLE_TAP_DELAY = 300; // ms\n\nconst MIN_TAP_DISTANCE = 25; // px\n\n/**\r\n * Gestures class bind touch, pointer or mouse events\r\n * and emits drag to drag-handler and zoom events zoom-handler.\r\n *\r\n * Drag and zoom events are emited in requestAnimationFrame,\r\n * and only when one of pointers was actually changed.\r\n */\n\nclass Gestures {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    /** @type {'x' | 'y' | null} */\n\n    this.dragAxis = null; // point objects are defined once and reused\n    // PhotoSwipe keeps track only of two pointers, others are ignored\n\n    /** @type {Point} */\n\n    this.p1 = {\n      x: 0,\n      y: 0\n    }; // the first pressed pointer\n\n    /** @type {Point} */\n\n    this.p2 = {\n      x: 0,\n      y: 0\n    }; // the second pressed pointer\n\n    /** @type {Point} */\n\n    this.prevP1 = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point} */\n\n    this.prevP2 = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point} */\n\n    this.startP1 = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point} */\n\n    this.startP2 = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point} */\n\n    this.velocity = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point}\r\n     * @private\r\n     */\n\n    this._lastStartP1 = {\n      x: 0,\n      y: 0\n    };\n    /** @type {Point}\r\n     * @private\r\n     */\n\n    this._intervalP1 = {\n      x: 0,\n      y: 0\n    };\n    /** @private */\n\n    this._numActivePoints = 0;\n    /** @type {Point[]}\r\n     * @private\r\n     */\n\n    this._ongoingPointers = [];\n    /** @private */\n\n    this._touchEventEnabled = 'ontouchstart' in window;\n    /** @private */\n\n    this._pointerEventEnabled = !!window.PointerEvent;\n    this.supportsTouch = this._touchEventEnabled || this._pointerEventEnabled && navigator.maxTouchPoints > 1;\n    /** @private */\n\n    this._numActivePoints = 0;\n    /** @private */\n\n    this._intervalTime = 0;\n    /** @private */\n\n    this._velocityCalculated = false;\n    this.isMultitouch = false;\n    this.isDragging = false;\n    this.isZooming = false;\n    /** @type {number | null} */\n\n    this.raf = null;\n    /** @type {NodeJS.Timeout | null}\r\n     * @private\r\n     */\n\n    this._tapTimer = null;\n\n    if (!this.supportsTouch) {\n      // disable pan to next slide for non-touch devices\n      pswp.options.allowPanToNext = false;\n    }\n\n    this.drag = new DragHandler(this);\n    this.zoomLevels = new ZoomHandler(this);\n    this.tapHandler = new TapHandler(this);\n    pswp.on('bindEvents', () => {\n      pswp.events.add(pswp.scrollWrap, 'click',\n      /** @type EventListener */\n      this._onClick.bind(this));\n\n      if (this._pointerEventEnabled) {\n        this._bindEvents('pointer', 'down', 'up', 'cancel');\n      } else if (this._touchEventEnabled) {\n        this._bindEvents('touch', 'start', 'end', 'cancel'); // In previous versions we also bound mouse event here,\n        // in case device supports both touch and mouse events,\n        // but newer versions of browsers now support PointerEvent.\n        // on iOS10 if you bind touchmove/end after touchstart,\n        // and you don't preventDefault touchstart (which PhotoSwipe does),\n        // preventDefault will have no effect on touchmove and touchend.\n        // Unless you bind it previously.\n\n\n        if (pswp.scrollWrap) {\n          pswp.scrollWrap.ontouchmove = () => {};\n\n          pswp.scrollWrap.ontouchend = () => {};\n        }\n      } else {\n        this._bindEvents('mouse', 'down', 'up');\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * @param {'mouse' | 'touch' | 'pointer'} pref\r\n   * @param {'down' | 'start'} down\r\n   * @param {'up' | 'end'} up\r\n   * @param {'cancel'} [cancel]\r\n   */\n\n\n  _bindEvents(pref, down, up, cancel) {\n    const {\n      pswp\n    } = this;\n    const {\n      events\n    } = pswp;\n    const cancelEvent = cancel ? pref + cancel : '';\n    events.add(pswp.scrollWrap, pref + down,\n    /** @type EventListener */\n    this.onPointerDown.bind(this));\n    events.add(window, pref + 'move',\n    /** @type EventListener */\n    this.onPointerMove.bind(this));\n    events.add(window, pref + up,\n    /** @type EventListener */\n    this.onPointerUp.bind(this));\n\n    if (cancelEvent) {\n      events.add(pswp.scrollWrap, cancelEvent,\n      /** @type EventListener */\n      this.onPointerUp.bind(this));\n    }\n  }\n  /**\r\n   * @param {PointerEvent} e\r\n   */\n\n\n  onPointerDown(e) {\n    // We do not call preventDefault for touch events\n    // to allow browser to show native dialog on longpress\n    // (the one that allows to save image or open it in new tab).\n    //\n    // Desktop Safari allows to drag images when preventDefault isn't called on mousedown,\n    // even though preventDefault IS called on mousemove. That's why we preventDefault mousedown.\n    const isMousePointer = e.type === 'mousedown' || e.pointerType === 'mouse'; // Allow dragging only via left mouse button.\n    // http://www.quirksmode.org/js/events_properties.html\n    // https://developer.mozilla.org/en-US/docs/Web/API/event.button\n\n    if (isMousePointer && e.button > 0) {\n      return;\n    }\n\n    const {\n      pswp\n    } = this; // if PhotoSwipe is opening or closing\n\n    if (!pswp.opener.isOpen) {\n      e.preventDefault();\n      return;\n    }\n\n    if (pswp.dispatch('pointerDown', {\n      originalEvent: e\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (isMousePointer) {\n      pswp.mouseDetected(); // preventDefault mouse event to prevent\n      // browser image drag feature\n\n      this._preventPointerEventBehaviour(e, 'down');\n    }\n\n    pswp.animations.stopAll();\n\n    this._updatePoints(e, 'down');\n\n    if (this._numActivePoints === 1) {\n      this.dragAxis = null; // we need to store initial point to determine the main axis,\n      // drag is activated only after the axis is determined\n\n      equalizePoints(this.startP1, this.p1);\n    }\n\n    if (this._numActivePoints > 1) {\n      // Tap or double tap should not trigger if more than one pointer\n      this._clearTapTimer();\n\n      this.isMultitouch = true;\n    } else {\n      this.isMultitouch = false;\n    }\n  }\n  /**\r\n   * @param {PointerEvent} e\r\n   */\n\n\n  onPointerMove(e) {\n    this._preventPointerEventBehaviour(e, 'move');\n\n    if (!this._numActivePoints) {\n      return;\n    }\n\n    this._updatePoints(e, 'move');\n\n    if (this.pswp.dispatch('pointerMove', {\n      originalEvent: e\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this._numActivePoints === 1 && !this.isDragging) {\n      if (!this.dragAxis) {\n        this._calculateDragDirection();\n      } // Drag axis was detected, emit drag.start\n\n\n      if (this.dragAxis && !this.isDragging) {\n        if (this.isZooming) {\n          this.isZooming = false;\n          this.zoomLevels.end();\n        }\n\n        this.isDragging = true;\n\n        this._clearTapTimer(); // Tap can not trigger after drag\n        // Adjust starting point\n\n\n        this._updateStartPoints();\n\n        this._intervalTime = Date.now(); //this._startTime = this._intervalTime;\n\n        this._velocityCalculated = false;\n        equalizePoints(this._intervalP1, this.p1);\n        this.velocity.x = 0;\n        this.velocity.y = 0;\n        this.drag.start();\n\n        this._rafStopLoop();\n\n        this._rafRenderLoop();\n      }\n    } else if (this._numActivePoints > 1 && !this.isZooming) {\n      this._finishDrag();\n\n      this.isZooming = true; // Adjust starting points\n\n      this._updateStartPoints();\n\n      this.zoomLevels.start();\n\n      this._rafStopLoop();\n\n      this._rafRenderLoop();\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _finishDrag() {\n    if (this.isDragging) {\n      this.isDragging = false; // Try to calculate velocity,\n      // if it wasn't calculated yet in drag.change\n\n      if (!this._velocityCalculated) {\n        this._updateVelocity(true);\n      }\n\n      this.drag.end();\n      this.dragAxis = null;\n    }\n  }\n  /**\r\n   * @param {PointerEvent} e\r\n   */\n\n\n  onPointerUp(e) {\n    if (!this._numActivePoints) {\n      return;\n    }\n\n    this._updatePoints(e, 'up');\n\n    if (this.pswp.dispatch('pointerUp', {\n      originalEvent: e\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this._numActivePoints === 0) {\n      this._rafStopLoop();\n\n      if (this.isDragging) {\n        this._finishDrag();\n      } else if (!this.isZooming && !this.isMultitouch) {\n        //this.zoomLevels.correctZoomPan();\n        this._finishTap(e);\n      }\n    }\n\n    if (this._numActivePoints < 2 && this.isZooming) {\n      this.isZooming = false;\n      this.zoomLevels.end();\n\n      if (this._numActivePoints === 1) {\n        // Since we have 1 point left, we need to reinitiate drag\n        this.dragAxis = null;\n\n        this._updateStartPoints();\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _rafRenderLoop() {\n    if (this.isDragging || this.isZooming) {\n      this._updateVelocity();\n\n      if (this.isDragging) {\n        // make sure that pointer moved since the last update\n        if (!pointsEqual(this.p1, this.prevP1)) {\n          this.drag.change();\n        }\n      } else\n        /* if (this.isZooming) */\n        {\n          if (!pointsEqual(this.p1, this.prevP1) || !pointsEqual(this.p2, this.prevP2)) {\n            this.zoomLevels.change();\n          }\n        }\n\n      this._updatePrevPoints();\n\n      this.raf = requestAnimationFrame(this._rafRenderLoop.bind(this));\n    }\n  }\n  /**\r\n   * Update velocity at 50ms interval\r\n   *\r\n   * @private\r\n   * @param {boolean} [force]\r\n   */\n\n\n  _updateVelocity(force) {\n    const time = Date.now();\n    const duration = time - this._intervalTime;\n\n    if (duration < 50 && !force) {\n      return;\n    }\n\n    this.velocity.x = this._getVelocity('x', duration);\n    this.velocity.y = this._getVelocity('y', duration);\n    this._intervalTime = time;\n    equalizePoints(this._intervalP1, this.p1);\n    this._velocityCalculated = true;\n  }\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   */\n\n\n  _finishTap(e) {\n    const {\n      mainScroll\n    } = this.pswp; // Do not trigger tap events if main scroll is shifted\n\n    if (mainScroll.isShifted()) {\n      // restore main scroll position\n      // (usually happens if stopped in the middle of animation)\n      mainScroll.moveIndexBy(0, true);\n      return;\n    } // Do not trigger tap for touchcancel or pointercancel\n\n\n    if (e.type.indexOf('cancel') > 0) {\n      return;\n    } // Trigger click instead of tap for mouse events\n\n\n    if (e.type === 'mouseup' || e.pointerType === 'mouse') {\n      this.tapHandler.click(this.startP1, e);\n      return;\n    } // Disable delay if there is no doubleTapAction\n\n\n    const tapDelay = this.pswp.options.doubleTapAction ? DOUBLE_TAP_DELAY : 0; // If tapTimer is defined - we tapped recently,\n    // check if the current tap is close to the previous one,\n    // if yes - trigger double tap\n\n    if (this._tapTimer) {\n      this._clearTapTimer(); // Check if two taps were more or less on the same place\n\n\n      if (getDistanceBetween(this._lastStartP1, this.startP1) < MIN_TAP_DISTANCE) {\n        this.tapHandler.doubleTap(this.startP1, e);\n      }\n    } else {\n      equalizePoints(this._lastStartP1, this.startP1);\n      this._tapTimer = setTimeout(() => {\n        this.tapHandler.tap(this.startP1, e);\n\n        this._clearTapTimer();\n      }, tapDelay);\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _clearTapTimer() {\n    if (this._tapTimer) {\n      clearTimeout(this._tapTimer);\n      this._tapTimer = null;\n    }\n  }\n  /**\r\n   * Get velocity for axis\r\n   *\r\n   * @private\r\n   * @param {'x' | 'y'} axis\r\n   * @param {number} duration\r\n   * @returns {number}\r\n   */\n\n\n  _getVelocity(axis, duration) {\n    // displacement is like distance, but can be negative.\n    const displacement = this.p1[axis] - this._intervalP1[axis];\n\n    if (Math.abs(displacement) > 1 && duration > 5) {\n      return displacement / duration;\n    }\n\n    return 0;\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _rafStopLoop() {\n    if (this.raf) {\n      cancelAnimationFrame(this.raf);\n      this.raf = null;\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type\r\n   */\n\n\n  _preventPointerEventBehaviour(e, pointerType) {\n    const preventPointerEvent = this.pswp.applyFilters('preventPointerEvent', true, e, pointerType);\n\n    if (preventPointerEvent) {\n      e.preventDefault();\n    }\n  }\n  /**\r\n   * Parses and normalizes points from the touch, mouse or pointer event.\r\n   * Updates p1 and p2.\r\n   *\r\n   * @private\r\n   * @param {PointerEvent | TouchEvent} e\r\n   * @param {'up' | 'down' | 'move'} pointerType Normalized pointer type\r\n   */\n\n\n  _updatePoints(e, pointerType) {\n    if (this._pointerEventEnabled) {\n      const pointerEvent =\n      /** @type {PointerEvent} */\n      e; // Try to find the current pointer in ongoing pointers by its ID\n\n      const pointerIndex = this._ongoingPointers.findIndex(ongoingPointer => {\n        return ongoingPointer.id === pointerEvent.pointerId;\n      });\n\n      if (pointerType === 'up' && pointerIndex > -1) {\n        // release the pointer - remove it from ongoing\n        this._ongoingPointers.splice(pointerIndex, 1);\n      } else if (pointerType === 'down' && pointerIndex === -1) {\n        // add new pointer\n        this._ongoingPointers.push(this._convertEventPosToPoint(pointerEvent, {\n          x: 0,\n          y: 0\n        }));\n      } else if (pointerIndex > -1) {\n        // update existing pointer\n        this._convertEventPosToPoint(pointerEvent, this._ongoingPointers[pointerIndex]);\n      }\n\n      this._numActivePoints = this._ongoingPointers.length; // update points that PhotoSwipe uses\n      // to calculate position and scale\n\n      if (this._numActivePoints > 0) {\n        equalizePoints(this.p1, this._ongoingPointers[0]);\n      }\n\n      if (this._numActivePoints > 1) {\n        equalizePoints(this.p2, this._ongoingPointers[1]);\n      }\n    } else {\n      const touchEvent =\n      /** @type {TouchEvent} */\n      e;\n      this._numActivePoints = 0;\n\n      if (touchEvent.type.indexOf('touch') > -1) {\n        // Touch Event\n        // https://developer.mozilla.org/en-US/docs/Web/API/TouchEvent\n        if (touchEvent.touches && touchEvent.touches.length > 0) {\n          this._convertEventPosToPoint(touchEvent.touches[0], this.p1);\n\n          this._numActivePoints++;\n\n          if (touchEvent.touches.length > 1) {\n            this._convertEventPosToPoint(touchEvent.touches[1], this.p2);\n\n            this._numActivePoints++;\n          }\n        }\n      } else {\n        // Mouse Event\n        this._convertEventPosToPoint(\n        /** @type {PointerEvent} */\n        e, this.p1);\n\n        if (pointerType === 'up') {\n          // clear all points on mouseup\n          this._numActivePoints = 0;\n        } else {\n          this._numActivePoints++;\n        }\n      }\n    }\n  }\n  /** update points that were used during previous rAF tick\r\n   * @private\r\n   */\n\n\n  _updatePrevPoints() {\n    equalizePoints(this.prevP1, this.p1);\n    equalizePoints(this.prevP2, this.p2);\n  }\n  /** update points at the start of gesture\r\n   * @private\r\n   */\n\n\n  _updateStartPoints() {\n    equalizePoints(this.startP1, this.p1);\n    equalizePoints(this.startP2, this.p2);\n\n    this._updatePrevPoints();\n  }\n  /** @private */\n\n\n  _calculateDragDirection() {\n    if (this.pswp.mainScroll.isShifted()) {\n      // if main scroll position is shifted – direction is always horizontal\n      this.dragAxis = 'x';\n    } else {\n      // calculate delta of the last touchmove tick\n      const diff = Math.abs(this.p1.x - this.startP1.x) - Math.abs(this.p1.y - this.startP1.y);\n\n      if (diff !== 0) {\n        // check if pointer was shifted horizontally or vertically\n        const axisToCheck = diff > 0 ? 'x' : 'y';\n\n        if (Math.abs(this.p1[axisToCheck] - this.startP1[axisToCheck]) >= AXIS_SWIPE_HYSTERISIS) {\n          this.dragAxis = axisToCheck;\n        }\n      }\n    }\n  }\n  /**\r\n   * Converts touch, pointer or mouse event\r\n   * to PhotoSwipe point.\r\n   *\r\n   * @private\r\n   * @param {Touch | PointerEvent} e\r\n   * @param {Point} p\r\n   * @returns {Point}\r\n   */\n\n\n  _convertEventPosToPoint(e, p) {\n    p.x = e.pageX - this.pswp.offset.x;\n    p.y = e.pageY - this.pswp.offset.y;\n\n    if ('pointerId' in e) {\n      p.id = e.pointerId;\n    } else if (e.identifier !== undefined) {\n      p.id = e.identifier;\n    }\n\n    return p;\n  }\n  /**\r\n   * @private\r\n   * @param {PointerEvent} e\r\n   */\n\n\n  _onClick(e) {\n    // Do not allow click event to pass through after drag\n    if (this.pswp.mainScroll.isShifted()) {\n      e.preventDefault();\n      e.stopPropagation();\n    }\n  }\n\n}\n\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('./slide/slide.js').default} Slide */\n\n/** @typedef {{ el: HTMLDivElement; slide?: Slide }} ItemHolder */\n\nconst MAIN_SCROLL_END_FRICTION = 0.35; // const MIN_SWIPE_TRANSITION_DURATION = 250;\n// const MAX_SWIPE_TRABSITION_DURATION = 500;\n// const DEFAULT_SWIPE_TRANSITION_DURATION = 333;\n\n/**\r\n * Handles movement of the main scrolling container\r\n * (for example, it repositions when user swipes left or right).\r\n *\r\n * Also stores its state.\r\n */\n\nclass MainScroll {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    this.x = 0;\n    this.slideWidth = 0;\n    /** @private */\n\n    this._currPositionIndex = 0;\n    /** @private */\n\n    this._prevPositionIndex = 0;\n    /** @private */\n\n    this._containerShiftIndex = -1;\n    /** @type {ItemHolder[]} */\n\n    this.itemHolders = [];\n  }\n  /**\r\n   * Position the scroller and slide containers\r\n   * according to viewport size.\r\n   *\r\n   * @param {boolean} [resizeSlides] Whether slides content should resized\r\n   */\n\n\n  resize(resizeSlides) {\n    const {\n      pswp\n    } = this;\n    const newSlideWidth = Math.round(pswp.viewportSize.x + pswp.viewportSize.x * pswp.options.spacing); // Mobile browsers might trigger a resize event during a gesture.\n    // (due to toolbar appearing or hiding).\n    // Avoid re-adjusting main scroll position if width wasn't changed\n\n    const slideWidthChanged = newSlideWidth !== this.slideWidth;\n\n    if (slideWidthChanged) {\n      this.slideWidth = newSlideWidth;\n      this.moveTo(this.getCurrSlideX());\n    }\n\n    this.itemHolders.forEach((itemHolder, index) => {\n      if (slideWidthChanged) {\n        setTransform(itemHolder.el, (index + this._containerShiftIndex) * this.slideWidth);\n      }\n\n      if (resizeSlides && itemHolder.slide) {\n        itemHolder.slide.resize();\n      }\n    });\n  }\n  /**\r\n   * Reset X position of the main scroller to zero\r\n   */\n\n\n  resetPosition() {\n    // Position on the main scroller (offset)\n    // it is independent from slide index\n    this._currPositionIndex = 0;\n    this._prevPositionIndex = 0; // This will force recalculation of size on next resize()\n\n    this.slideWidth = 0; // _containerShiftIndex*viewportSize will give you amount of transform of the current slide\n\n    this._containerShiftIndex = -1;\n  }\n  /**\r\n   * Create and append array of three items\r\n   * that hold data about slides in DOM\r\n   */\n\n\n  appendHolders() {\n    this.itemHolders = []; // append our three slide holders -\n    // previous, current, and next\n\n    for (let i = 0; i < 3; i++) {\n      const el = createElement('pswp__item', 'div', this.pswp.container);\n      el.setAttribute('role', 'group');\n      el.setAttribute('aria-roledescription', 'slide');\n      el.setAttribute('aria-hidden', 'true'); // hide nearby item holders until initial zoom animation finishes (to avoid extra Paints)\n\n      el.style.display = i === 1 ? 'block' : 'none';\n      this.itemHolders.push({\n        el //index: -1\n\n      });\n    }\n  }\n  /**\r\n   * Whether the main scroll can be horizontally swiped to the next or previous slide.\r\n   * @returns {boolean}\r\n   */\n\n\n  canBeSwiped() {\n    return this.pswp.getNumItems() > 1;\n  }\n  /**\r\n   * Move main scroll by X amount of slides.\r\n   * For example:\r\n   *   `-1` will move to the previous slide,\r\n   *    `0` will reset the scroll position of the current slide,\r\n   *    `3` will move three slides forward\r\n   *\r\n   * If loop option is enabled - index will be automatically looped too,\r\n   * (for example `-1` will move to the last slide of the gallery).\r\n   *\r\n   * @param {number} diff\r\n   * @param {boolean} [animate]\r\n   * @param {number} [velocityX]\r\n   * @returns {boolean} whether index was changed or not\r\n   */\n\n\n  moveIndexBy(diff, animate, velocityX) {\n    const {\n      pswp\n    } = this;\n    let newIndex = pswp.potentialIndex + diff;\n    const numSlides = pswp.getNumItems();\n\n    if (pswp.canLoop()) {\n      newIndex = pswp.getLoopedIndex(newIndex);\n      const distance = (diff + numSlides) % numSlides;\n\n      if (distance <= numSlides / 2) {\n        // go forward\n        diff = distance;\n      } else {\n        // go backwards\n        diff = distance - numSlides;\n      }\n    } else {\n      if (newIndex < 0) {\n        newIndex = 0;\n      } else if (newIndex >= numSlides) {\n        newIndex = numSlides - 1;\n      }\n\n      diff = newIndex - pswp.potentialIndex;\n    }\n\n    pswp.potentialIndex = newIndex;\n    this._currPositionIndex -= diff;\n    pswp.animations.stopMainScroll();\n    const destinationX = this.getCurrSlideX();\n\n    if (!animate) {\n      this.moveTo(destinationX);\n      this.updateCurrItem();\n    } else {\n      pswp.animations.startSpring({\n        isMainScroll: true,\n        start: this.x,\n        end: destinationX,\n        velocity: velocityX || 0,\n        naturalFrequency: 30,\n        dampingRatio: 1,\n        //0.7,\n        onUpdate: x => {\n          this.moveTo(x);\n        },\n        onComplete: () => {\n          this.updateCurrItem();\n          pswp.appendHeavy();\n        }\n      });\n      let currDiff = pswp.potentialIndex - pswp.currIndex;\n\n      if (pswp.canLoop()) {\n        const currDistance = (currDiff + numSlides) % numSlides;\n\n        if (currDistance <= numSlides / 2) {\n          // go forward\n          currDiff = currDistance;\n        } else {\n          // go backwards\n          currDiff = currDistance - numSlides;\n        }\n      } // Force-append new slides during transition\n      // if difference between slides is more than 1\n\n\n      if (Math.abs(currDiff) > 1) {\n        this.updateCurrItem();\n      }\n    }\n\n    return Boolean(diff);\n  }\n  /**\r\n   * X position of the main scroll for the current slide\r\n   * (ignores position during dragging)\r\n   * @returns {number}\r\n   */\n\n\n  getCurrSlideX() {\n    return this.slideWidth * this._currPositionIndex;\n  }\n  /**\r\n   * Whether scroll position is shifted.\r\n   * For example, it will return true if the scroll is being dragged or animated.\r\n   * @returns {boolean}\r\n   */\n\n\n  isShifted() {\n    return this.x !== this.getCurrSlideX();\n  }\n  /**\r\n   * Update slides X positions and set their content\r\n   */\n\n\n  updateCurrItem() {\n    var _this$itemHolders$;\n\n    const {\n      pswp\n    } = this;\n    const positionDifference = this._prevPositionIndex - this._currPositionIndex;\n\n    if (!positionDifference) {\n      return;\n    }\n\n    this._prevPositionIndex = this._currPositionIndex;\n    pswp.currIndex = pswp.potentialIndex;\n    let diffAbs = Math.abs(positionDifference);\n    /** @type {ItemHolder | undefined} */\n\n    let tempHolder;\n\n    if (diffAbs >= 3) {\n      this._containerShiftIndex += positionDifference + (positionDifference > 0 ? -3 : 3);\n      diffAbs = 3; // If slides are changed by 3 screens or more - clean up previous slides\n\n      this.itemHolders.forEach(itemHolder => {\n        var _itemHolder$slide;\n\n        (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.destroy();\n        itemHolder.slide = undefined;\n      });\n    }\n\n    for (let i = 0; i < diffAbs; i++) {\n      if (positionDifference > 0) {\n        tempHolder = this.itemHolders.shift();\n\n        if (tempHolder) {\n          this.itemHolders[2] = tempHolder; // move first to last\n\n          this._containerShiftIndex++;\n          setTransform(tempHolder.el, (this._containerShiftIndex + 2) * this.slideWidth);\n          pswp.setContent(tempHolder, pswp.currIndex - diffAbs + i + 2);\n        }\n      } else {\n        tempHolder = this.itemHolders.pop();\n\n        if (tempHolder) {\n          this.itemHolders.unshift(tempHolder); // move last to first\n\n          this._containerShiftIndex--;\n          setTransform(tempHolder.el, this._containerShiftIndex * this.slideWidth);\n          pswp.setContent(tempHolder, pswp.currIndex + diffAbs - i - 2);\n        }\n      }\n    } // Reset transfrom every 50ish navigations in one direction.\n    //\n    // Otherwise transform will keep growing indefinitely,\n    // which might cause issues as browsers have a maximum transform limit.\n    // I wasn't able to reach it, but just to be safe.\n    // This should not cause noticable lag.\n\n\n    if (Math.abs(this._containerShiftIndex) > 50 && !this.isShifted()) {\n      this.resetPosition();\n      this.resize();\n    } // Pan transition might be running (and consntantly updating pan position)\n\n\n    pswp.animations.stopAllPan();\n    this.itemHolders.forEach((itemHolder, i) => {\n      if (itemHolder.slide) {\n        // Slide in the 2nd holder is always active\n        itemHolder.slide.setIsActive(i === 1);\n      }\n    });\n    pswp.currSlide = (_this$itemHolders$ = this.itemHolders[1]) === null || _this$itemHolders$ === void 0 ? void 0 : _this$itemHolders$.slide;\n    pswp.contentLoader.updateLazy(positionDifference);\n\n    if (pswp.currSlide) {\n      pswp.currSlide.applyCurrentZoomPan();\n    }\n\n    pswp.dispatch('change');\n  }\n  /**\r\n   * Move the X position of the main scroll container\r\n   *\r\n   * @param {number} x\r\n   * @param {boolean} [dragging]\r\n   */\n\n\n  moveTo(x, dragging) {\n    if (!this.pswp.canLoop() && dragging) {\n      // Apply friction\n      let newSlideIndexOffset = (this.slideWidth * this._currPositionIndex - x) / this.slideWidth;\n      newSlideIndexOffset += this.pswp.currIndex;\n      const delta = Math.round(x - this.x);\n\n      if (newSlideIndexOffset < 0 && delta > 0 || newSlideIndexOffset >= this.pswp.getNumItems() - 1 && delta < 0) {\n        x = this.x + delta * MAIN_SCROLL_END_FRICTION;\n      }\n    }\n\n    this.x = x;\n\n    if (this.pswp.container) {\n      setTransform(this.pswp.container, x);\n    }\n\n    this.pswp.dispatch('moveMainScroll', {\n      x,\n      dragging: dragging !== null && dragging !== void 0 ? dragging : false\n    });\n  }\n\n}\n\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\n\n/**\r\n * @template T\r\n * @typedef {import('./types.js').Methods<T>} Methods<T>\r\n */\n\nconst KeyboardKeyCodesMap = {\n  Escape: 27,\n  z: 90,\n  ArrowLeft: 37,\n  ArrowUp: 38,\n  ArrowRight: 39,\n  ArrowDown: 40,\n  Tab: 9\n};\n/**\r\n * @template {keyof KeyboardKeyCodesMap} T\r\n * @param {T} key\r\n * @param {boolean} isKeySupported\r\n * @returns {T | number | undefined}\r\n */\n\nconst getKeyboardEventKey = (key, isKeySupported) => {\n  return isKeySupported ? key : KeyboardKeyCodesMap[key];\n};\n/**\r\n * - Manages keyboard shortcuts.\r\n * - Helps trap focus within photoswipe.\r\n */\n\n\nclass Keyboard {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    /** @private */\n\n    this._wasFocused = false;\n    pswp.on('bindEvents', () => {\n      if (pswp.options.trapFocus) {\n        // Dialog was likely opened by keyboard if initial point is not defined\n        if (!pswp.options.initialPointerPos) {\n          // focus causes layout,\n          // which causes lag during the animation,\n          // that's why we delay it until the opener transition ends\n          this._focusRoot();\n        }\n\n        pswp.events.add(document, 'focusin',\n        /** @type EventListener */\n        this._onFocusIn.bind(this));\n      }\n\n      pswp.events.add(document, 'keydown',\n      /** @type EventListener */\n      this._onKeyDown.bind(this));\n    });\n    const lastActiveElement =\n    /** @type {HTMLElement} */\n    document.activeElement;\n    pswp.on('destroy', () => {\n      if (pswp.options.returnFocus && lastActiveElement && this._wasFocused) {\n        lastActiveElement.focus();\n      }\n    });\n  }\n  /** @private */\n\n\n  _focusRoot() {\n    if (!this._wasFocused && this.pswp.element) {\n      this.pswp.element.focus();\n      this._wasFocused = true;\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {KeyboardEvent} e\r\n   */\n\n\n  _onKeyDown(e) {\n    const {\n      pswp\n    } = this;\n\n    if (pswp.dispatch('keydown', {\n      originalEvent: e\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (specialKeyUsed(e)) {\n      // don't do anything if special key pressed\n      // to prevent from overriding default browser actions\n      // for example, in Chrome on Mac cmd+arrow-left returns to previous page\n      return;\n    }\n    /** @type {Methods<PhotoSwipe> | undefined} */\n\n\n    let keydownAction;\n    /** @type {'x' | 'y' | undefined} */\n\n    let axis;\n    let isForward = false;\n    const isKeySupported = ('key' in e);\n\n    switch (isKeySupported ? e.key : e.keyCode) {\n      case getKeyboardEventKey('Escape', isKeySupported):\n        if (pswp.options.escKey) {\n          keydownAction = 'close';\n        }\n\n        break;\n\n      case getKeyboardEventKey('z', isKeySupported):\n        keydownAction = 'toggleZoom';\n        break;\n\n      case getKeyboardEventKey('ArrowLeft', isKeySupported):\n        axis = 'x';\n        break;\n\n      case getKeyboardEventKey('ArrowUp', isKeySupported):\n        axis = 'y';\n        break;\n\n      case getKeyboardEventKey('ArrowRight', isKeySupported):\n        axis = 'x';\n        isForward = true;\n        break;\n\n      case getKeyboardEventKey('ArrowDown', isKeySupported):\n        isForward = true;\n        axis = 'y';\n        break;\n\n      case getKeyboardEventKey('Tab', isKeySupported):\n        this._focusRoot();\n\n        break;\n    } // if left/right/top/bottom key\n\n\n    if (axis) {\n      // prevent page scroll\n      e.preventDefault();\n      const {\n        currSlide\n      } = pswp;\n\n      if (pswp.options.arrowKeys && axis === 'x' && pswp.getNumItems() > 1) {\n        keydownAction = isForward ? 'next' : 'prev';\n      } else if (currSlide && currSlide.currZoomLevel > currSlide.zoomLevels.fit) {\n        // up/down arrow keys pan the image vertically\n        // left/right arrow keys pan horizontally.\n        // Unless there is only one image,\n        // or arrowKeys option is disabled\n        currSlide.pan[axis] += isForward ? -80 : 80;\n        currSlide.panTo(currSlide.pan.x, currSlide.pan.y);\n      }\n    }\n\n    if (keydownAction) {\n      e.preventDefault(); // @ts-ignore\n\n      pswp[keydownAction]();\n    }\n  }\n  /**\r\n   * Trap focus inside photoswipe\r\n   *\r\n   * @private\r\n   * @param {FocusEvent} e\r\n   */\n\n\n  _onFocusIn(e) {\n    const {\n      template\n    } = this.pswp;\n\n    if (template && document !== e.target && template !== e.target && !template.contains(\n    /** @type {Node} */\n    e.target)) {\n      // focus root element\n      template.focus();\n    }\n  }\n\n}\n\nconst DEFAULT_EASING = 'cubic-bezier(.4,0,.22,1)';\n/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */\n\n/** @typedef {Object} DefaultCssAnimationProps\r\n *\r\n * @prop {HTMLElement} target\r\n * @prop {number} [duration]\r\n * @prop {string} [easing]\r\n * @prop {string} [transform]\r\n * @prop {string} [opacity]\r\n * */\n\n/** @typedef {SharedAnimationProps & DefaultCssAnimationProps} CssAnimationProps */\n\n/**\r\n * Runs CSS transition.\r\n */\n\nclass CSSAnimation {\n  /**\r\n   * onComplete can be unpredictable, be careful about current state\r\n   *\r\n   * @param {CssAnimationProps} props\r\n   */\n  constructor(props) {\n    var _props$prop;\n\n    this.props = props;\n    const {\n      target,\n      onComplete,\n      transform,\n      onFinish = () => {},\n      duration = 333,\n      easing = DEFAULT_EASING\n    } = props;\n    this.onFinish = onFinish; // support only transform and opacity\n\n    const prop = transform ? 'transform' : 'opacity';\n    const propValue = (_props$prop = props[prop]) !== null && _props$prop !== void 0 ? _props$prop : '';\n    /** @private */\n\n    this._target = target;\n    /** @private */\n\n    this._onComplete = onComplete;\n    /** @private */\n\n    this._finished = false;\n    /** @private */\n\n    this._onTransitionEnd = this._onTransitionEnd.bind(this); // Using timeout hack to make sure that animation\n    // starts even if the animated property was changed recently,\n    // otherwise transitionend might not fire or transition won't start.\n    // https://drafts.csswg.org/css-transitions/#starting\n    //\n    // ¯\\_(ツ)_/¯\n\n    /** @private */\n\n    this._helperTimeout = setTimeout(() => {\n      setTransitionStyle(target, prop, duration, easing);\n      this._helperTimeout = setTimeout(() => {\n        target.addEventListener('transitionend', this._onTransitionEnd, false);\n        target.addEventListener('transitioncancel', this._onTransitionEnd, false); // Safari occasionally does not emit transitionend event\n        // if element property was modified during the transition,\n        // which may be caused by resize or third party component,\n        // using timeout as a safety fallback\n\n        this._helperTimeout = setTimeout(() => {\n          this._finalizeAnimation();\n        }, duration + 500);\n        target.style[prop] = propValue;\n      }, 30); // Do not reduce this number\n    }, 0);\n  }\n  /**\r\n   * @private\r\n   * @param {TransitionEvent} e\r\n   */\n\n\n  _onTransitionEnd(e) {\n    if (e.target === this._target) {\n      this._finalizeAnimation();\n    }\n  }\n  /**\r\n   * @private\r\n   */\n\n\n  _finalizeAnimation() {\n    if (!this._finished) {\n      this._finished = true;\n      this.onFinish();\n\n      if (this._onComplete) {\n        this._onComplete();\n      }\n    }\n  } // Destroy is called automatically onFinish\n\n\n  destroy() {\n    if (this._helperTimeout) {\n      clearTimeout(this._helperTimeout);\n    }\n\n    removeTransitionStyle(this._target);\n\n    this._target.removeEventListener('transitionend', this._onTransitionEnd, false);\n\n    this._target.removeEventListener('transitioncancel', this._onTransitionEnd, false);\n\n    if (!this._finished) {\n      this._finalizeAnimation();\n    }\n  }\n\n}\n\nconst DEFAULT_NATURAL_FREQUENCY = 12;\nconst DEFAULT_DAMPING_RATIO = 0.75;\n/**\r\n * Spring easing helper\r\n */\n\nclass SpringEaser {\n  /**\r\n   * @param {number} initialVelocity Initial velocity, px per ms.\r\n   *\r\n   * @param {number} [dampingRatio]\r\n   * Determines how bouncy animation will be.\r\n   * From 0 to 1, 0 - always overshoot, 1 - do not overshoot.\r\n   * \"overshoot\" refers to part of animation that\r\n   * goes beyond the final value.\r\n   *\r\n   * @param {number} [naturalFrequency]\r\n   * Determines how fast animation will slow down.\r\n   * The higher value - the stiffer the transition will be,\r\n   * and the faster it will slow down.\r\n   * Recommended value from 10 to 50\r\n   */\n  constructor(initialVelocity, dampingRatio, naturalFrequency) {\n    this.velocity = initialVelocity * 1000; // convert to \"pixels per second\"\n    // https://en.wikipedia.org/wiki/Damping_ratio\n\n    this._dampingRatio = dampingRatio || DEFAULT_DAMPING_RATIO; // https://en.wikipedia.org/wiki/Natural_frequency\n\n    this._naturalFrequency = naturalFrequency || DEFAULT_NATURAL_FREQUENCY;\n    this._dampedFrequency = this._naturalFrequency;\n\n    if (this._dampingRatio < 1) {\n      this._dampedFrequency *= Math.sqrt(1 - this._dampingRatio * this._dampingRatio);\n    }\n  }\n  /**\r\n   * @param {number} deltaPosition Difference between current and end position of the animation\r\n   * @param {number} deltaTime Frame duration in milliseconds\r\n   *\r\n   * @returns {number} Displacement, relative to the end position.\r\n   */\n\n\n  easeFrame(deltaPosition, deltaTime) {\n    // Inspired by Apple Webkit and Android spring function implementation\n    // https://en.wikipedia.org/wiki/Oscillation\n    // https://en.wikipedia.org/wiki/Damping_ratio\n    // we ignore mass (assume that it's 1kg)\n    let displacement = 0;\n    let coeff;\n    deltaTime /= 1000;\n    const naturalDumpingPow = Math.E ** (-this._dampingRatio * this._naturalFrequency * deltaTime);\n\n    if (this._dampingRatio === 1) {\n      coeff = this.velocity + this._naturalFrequency * deltaPosition;\n      displacement = (deltaPosition + coeff * deltaTime) * naturalDumpingPow;\n      this.velocity = displacement * -this._naturalFrequency + coeff * naturalDumpingPow;\n    } else if (this._dampingRatio < 1) {\n      coeff = 1 / this._dampedFrequency * (this._dampingRatio * this._naturalFrequency * deltaPosition + this.velocity);\n      const dumpedFCos = Math.cos(this._dampedFrequency * deltaTime);\n      const dumpedFSin = Math.sin(this._dampedFrequency * deltaTime);\n      displacement = naturalDumpingPow * (deltaPosition * dumpedFCos + coeff * dumpedFSin);\n      this.velocity = displacement * -this._naturalFrequency * this._dampingRatio + naturalDumpingPow * (-this._dampedFrequency * deltaPosition * dumpedFSin + this._dampedFrequency * coeff * dumpedFCos);\n    } // Overdamped (>1) damping ratio is not supported\n\n\n    return displacement;\n  }\n\n}\n\n/** @typedef {import('./animations.js').SharedAnimationProps} SharedAnimationProps */\n\n/**\r\n * @typedef {Object} DefaultSpringAnimationProps\r\n *\r\n * @prop {number} start\r\n * @prop {number} end\r\n * @prop {number} velocity\r\n * @prop {number} [dampingRatio]\r\n * @prop {number} [naturalFrequency]\r\n * @prop {(end: number) => void} onUpdate\r\n */\n\n/** @typedef {SharedAnimationProps & DefaultSpringAnimationProps} SpringAnimationProps */\n\nclass SpringAnimation {\n  /**\r\n   * @param {SpringAnimationProps} props\r\n   */\n  constructor(props) {\n    this.props = props;\n    this._raf = 0;\n    const {\n      start,\n      end,\n      velocity,\n      onUpdate,\n      onComplete,\n      onFinish = () => {},\n      dampingRatio,\n      naturalFrequency\n    } = props;\n    this.onFinish = onFinish;\n    const easer = new SpringEaser(velocity, dampingRatio, naturalFrequency);\n    let prevTime = Date.now();\n    let deltaPosition = start - end;\n\n    const animationLoop = () => {\n      if (this._raf) {\n        deltaPosition = easer.easeFrame(deltaPosition, Date.now() - prevTime); // Stop the animation if velocity is low and position is close to end\n\n        if (Math.abs(deltaPosition) < 1 && Math.abs(easer.velocity) < 50) {\n          // Finalize the animation\n          onUpdate(end);\n\n          if (onComplete) {\n            onComplete();\n          }\n\n          this.onFinish();\n        } else {\n          prevTime = Date.now();\n          onUpdate(deltaPosition + end);\n          this._raf = requestAnimationFrame(animationLoop);\n        }\n      }\n    };\n\n    this._raf = requestAnimationFrame(animationLoop);\n  } // Destroy is called automatically onFinish\n\n\n  destroy() {\n    if (this._raf >= 0) {\n      cancelAnimationFrame(this._raf);\n    }\n\n    this._raf = 0;\n  }\n\n}\n\n/** @typedef {import('./css-animation.js').CssAnimationProps} CssAnimationProps */\n\n/** @typedef {import('./spring-animation.js').SpringAnimationProps} SpringAnimationProps */\n\n/** @typedef {Object} SharedAnimationProps\r\n * @prop {string} [name]\r\n * @prop {boolean} [isPan]\r\n * @prop {boolean} [isMainScroll]\r\n * @prop {VoidFunction} [onComplete]\r\n * @prop {VoidFunction} [onFinish]\r\n */\n\n/** @typedef {SpringAnimation | CSSAnimation} Animation */\n\n/** @typedef {SpringAnimationProps | CssAnimationProps} AnimationProps */\n\n/**\r\n * Manages animations\r\n */\n\nclass Animations {\n  constructor() {\n    /** @type {Animation[]} */\n    this.activeAnimations = [];\n  }\n  /**\r\n   * @param {SpringAnimationProps} props\r\n   */\n\n\n  startSpring(props) {\n    this._start(props, true);\n  }\n  /**\r\n   * @param {CssAnimationProps} props\r\n   */\n\n\n  startTransition(props) {\n    this._start(props);\n  }\n  /**\r\n   * @private\r\n   * @param {AnimationProps} props\r\n   * @param {boolean} [isSpring]\r\n   * @returns {Animation}\r\n   */\n\n\n  _start(props, isSpring) {\n    const animation = isSpring ? new SpringAnimation(\n    /** @type SpringAnimationProps */\n    props) : new CSSAnimation(\n    /** @type CssAnimationProps */\n    props);\n    this.activeAnimations.push(animation);\n\n    animation.onFinish = () => this.stop(animation);\n\n    return animation;\n  }\n  /**\r\n   * @param {Animation} animation\r\n   */\n\n\n  stop(animation) {\n    animation.destroy();\n    const index = this.activeAnimations.indexOf(animation);\n\n    if (index > -1) {\n      this.activeAnimations.splice(index, 1);\n    }\n  }\n\n  stopAll() {\n    // _stopAllAnimations\n    this.activeAnimations.forEach(animation => {\n      animation.destroy();\n    });\n    this.activeAnimations = [];\n  }\n  /**\r\n   * Stop all pan or zoom transitions\r\n   */\n\n\n  stopAllPan() {\n    this.activeAnimations = this.activeAnimations.filter(animation => {\n      if (animation.props.isPan) {\n        animation.destroy();\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  stopMainScroll() {\n    this.activeAnimations = this.activeAnimations.filter(animation => {\n      if (animation.props.isMainScroll) {\n        animation.destroy();\n        return false;\n      }\n\n      return true;\n    });\n  }\n  /**\r\n   * Returns true if main scroll transition is running\r\n   */\n  // isMainScrollRunning() {\n  //   return this.activeAnimations.some((animation) => {\n  //     return animation.props.isMainScroll;\n  //   });\n  // }\n\n  /**\r\n   * Returns true if any pan or zoom transition is running\r\n   */\n\n\n  isPanRunning() {\n    return this.activeAnimations.some(animation => {\n      return animation.props.isPan;\n    });\n  }\n\n}\n\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\n\n/**\r\n * Handles scroll wheel.\r\n * Can pan and zoom current slide image.\r\n */\nclass ScrollWheel {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    pswp.events.add(pswp.element, 'wheel',\n    /** @type EventListener */\n    this._onWheel.bind(this));\n  }\n  /**\r\n   * @private\r\n   * @param {WheelEvent} e\r\n   */\n\n\n  _onWheel(e) {\n    e.preventDefault();\n    const {\n      currSlide\n    } = this.pswp;\n    let {\n      deltaX,\n      deltaY\n    } = e;\n\n    if (!currSlide) {\n      return;\n    }\n\n    if (this.pswp.dispatch('wheel', {\n      originalEvent: e\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (e.ctrlKey || this.pswp.options.wheelToZoom) {\n      // zoom\n      if (currSlide.isZoomable()) {\n        let zoomFactor = -deltaY;\n\n        if (e.deltaMode === 1\n        /* DOM_DELTA_LINE */\n        ) {\n          zoomFactor *= 0.05;\n        } else {\n          zoomFactor *= e.deltaMode ? 1 : 0.002;\n        }\n\n        zoomFactor = 2 ** zoomFactor;\n        const destZoomLevel = currSlide.currZoomLevel * zoomFactor;\n        currSlide.zoomTo(destZoomLevel, {\n          x: e.clientX,\n          y: e.clientY\n        });\n      }\n    } else {\n      // pan\n      if (currSlide.isPannable()) {\n        if (e.deltaMode === 1\n        /* DOM_DELTA_LINE */\n        ) {\n          // 18 - average line height\n          deltaX *= 18;\n          deltaY *= 18;\n        }\n\n        currSlide.panTo(currSlide.pan.x - deltaX, currSlide.pan.y - deltaY);\n      }\n    }\n  }\n\n}\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/**\r\n * @template T\r\n * @typedef {import('../types.js').Methods<T>} Methods<T>\r\n */\n\n/**\r\n * @typedef {Object} UIElementMarkupProps\r\n * @prop {boolean} [isCustomSVG]\r\n * @prop {string} inner\r\n * @prop {string} [outlineID]\r\n * @prop {number | string} [size]\r\n */\n\n/**\r\n * @typedef {Object} UIElementData\r\n * @prop {DefaultUIElements | string} [name]\r\n * @prop {string} [className]\r\n * @prop {UIElementMarkup} [html]\r\n * @prop {boolean} [isButton]\r\n * @prop {keyof HTMLElementTagNameMap} [tagName]\r\n * @prop {string} [title]\r\n * @prop {string} [ariaLabel]\r\n * @prop {(element: HTMLElement, pswp: PhotoSwipe) => void} [onInit]\r\n * @prop {Methods<PhotoSwipe> | ((e: MouseEvent, element: HTMLElement, pswp: PhotoSwipe) => void)} [onClick]\r\n * @prop {'bar' | 'wrapper' | 'root'} [appendTo]\r\n * @prop {number} [order]\r\n */\n\n/** @typedef {'arrowPrev' | 'arrowNext' | 'close' | 'zoom' | 'counter'} DefaultUIElements */\n\n/** @typedef {string | UIElementMarkupProps} UIElementMarkup */\n\n/**\r\n * @param {UIElementMarkup} [htmlData]\r\n * @returns {string}\r\n */\n\nfunction addElementHTML(htmlData) {\n  if (typeof htmlData === 'string') {\n    // Allow developers to provide full svg,\n    // For example:\n    // <svg viewBox=\"0 0 32 32\" width=\"32\" height=\"32\" aria-hidden=\"true\" class=\"pswp__icn\">\n    //   <path d=\"...\" />\n    //   <circle ... />\n    // </svg>\n    // Can also be any HTML string.\n    return htmlData;\n  }\n\n  if (!htmlData || !htmlData.isCustomSVG) {\n    return '';\n  }\n\n  const svgData = htmlData;\n  let out = '<svg aria-hidden=\"true\" class=\"pswp__icn\" viewBox=\"0 0 %d %d\" width=\"%d\" height=\"%d\">'; // replace all %d with size\n\n  out = out.split('%d').join(\n  /** @type {string} */\n  svgData.size || 32); // Icons may contain outline/shadow,\n  // to make it we \"clone\" base icon shape and add border to it.\n  // Icon itself and border are styled via CSS.\n  //\n  // Property shadowID defines ID of element that should be cloned.\n\n  if (svgData.outlineID) {\n    out += '<use class=\"pswp__icn-shadow\" xlink:href=\"#' + svgData.outlineID + '\"/>';\n  }\n\n  out += svgData.inner;\n  out += '</svg>';\n  return out;\n}\n\nclass UIElement {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   * @param {UIElementData} data\r\n   */\n  constructor(pswp, data) {\n    var _container;\n\n    const name = data.name || data.className;\n    let elementHTML = data.html; // @ts-expect-error lookup only by `data.name` maybe?\n\n    if (pswp.options[name] === false) {\n      // exit if element is disabled from options\n      return;\n    } // Allow to override SVG icons from options\n    // @ts-expect-error lookup only by `data.name` maybe?\n\n\n    if (typeof pswp.options[name + 'SVG'] === 'string') {\n      // arrowPrevSVG\n      // arrowNextSVG\n      // closeSVG\n      // zoomSVG\n      // @ts-expect-error lookup only by `data.name` maybe?\n      elementHTML = pswp.options[name + 'SVG'];\n    }\n\n    pswp.dispatch('uiElementCreate', {\n      data\n    });\n    let className = '';\n\n    if (data.isButton) {\n      className += 'pswp__button ';\n      className += data.className || `pswp__button--${data.name}`;\n    } else {\n      className += data.className || `pswp__${data.name}`;\n    }\n\n    let tagName = data.isButton ? data.tagName || 'button' : data.tagName || 'div';\n    tagName =\n    /** @type {keyof HTMLElementTagNameMap} */\n    tagName.toLowerCase();\n    /** @type {HTMLElement} */\n\n    const element = createElement(className, tagName);\n\n    if (data.isButton) {\n      if (tagName === 'button') {\n        /** @type {HTMLButtonElement} */\n        element.type = 'button';\n      }\n\n      let {\n        title\n      } = data;\n      const {\n        ariaLabel\n      } = data; // @ts-expect-error lookup only by `data.name` maybe?\n\n      if (typeof pswp.options[name + 'Title'] === 'string') {\n        // @ts-expect-error lookup only by `data.name` maybe?\n        title = pswp.options[name + 'Title'];\n      }\n\n      if (title) {\n        element.title = title;\n      }\n\n      const ariaText = ariaLabel || title;\n\n      if (ariaText) {\n        element.setAttribute('aria-label', ariaText);\n      }\n    }\n\n    element.innerHTML = addElementHTML(elementHTML);\n\n    if (data.onInit) {\n      data.onInit(element, pswp);\n    }\n\n    if (data.onClick) {\n      element.onclick = e => {\n        if (typeof data.onClick === 'string') {\n          // @ts-ignore\n          pswp[data.onClick]();\n        } else if (typeof data.onClick === 'function') {\n          data.onClick(e, element, pswp);\n        }\n      };\n    } // Top bar is default position\n\n\n    const appendTo = data.appendTo || 'bar';\n    /** @type {HTMLElement | undefined} root element by default */\n\n    let container = pswp.element;\n\n    if (appendTo === 'bar') {\n      if (!pswp.topBar) {\n        pswp.topBar = createElement('pswp__top-bar pswp__hide-on-close', 'div', pswp.scrollWrap);\n      }\n\n      container = pswp.topBar;\n    } else {\n      // element outside of top bar gets a secondary class\n      // that makes element fade out on close\n      element.classList.add('pswp__hide-on-close');\n\n      if (appendTo === 'wrapper') {\n        container = pswp.scrollWrap;\n      }\n    }\n\n    (_container = container) === null || _container === void 0 || _container.appendChild(pswp.applyFilters('uiElement', element, data));\n  }\n\n}\n\n/*\r\n  Backward and forward arrow buttons\r\n */\n\n/** @typedef {import('./ui-element.js').UIElementData} UIElementData */\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/**\r\n *\r\n * @param {HTMLElement} element\r\n * @param {PhotoSwipe} pswp\r\n * @param {boolean} [isNextButton]\r\n */\nfunction initArrowButton(element, pswp, isNextButton) {\n  element.classList.add('pswp__button--arrow'); // TODO: this should point to a unique id for this instance\n\n  element.setAttribute('aria-controls', 'pswp__items');\n  pswp.on('change', () => {\n    if (!pswp.options.loop) {\n      if (isNextButton) {\n        /** @type {HTMLButtonElement} */\n        element.disabled = !(pswp.currIndex < pswp.getNumItems() - 1);\n      } else {\n        /** @type {HTMLButtonElement} */\n        element.disabled = !(pswp.currIndex > 0);\n      }\n    }\n  });\n}\n/** @type {UIElementData} */\n\n\nconst arrowPrev = {\n  name: 'arrowPrev',\n  className: 'pswp__button--arrow--prev',\n  title: 'Previous',\n  order: 10,\n  isButton: true,\n  appendTo: 'wrapper',\n  html: {\n    isCustomSVG: true,\n    size: 60,\n    inner: '<path d=\"M29 43l-3 3-16-16 16-16 3 3-13 13 13 13z\" id=\"pswp__icn-arrow\"/>',\n    outlineID: 'pswp__icn-arrow'\n  },\n  onClick: 'prev',\n  onInit: initArrowButton\n};\n/** @type {UIElementData} */\n\nconst arrowNext = {\n  name: 'arrowNext',\n  className: 'pswp__button--arrow--next',\n  title: 'Next',\n  order: 11,\n  isButton: true,\n  appendTo: 'wrapper',\n  html: {\n    isCustomSVG: true,\n    size: 60,\n    inner: '<use xlink:href=\"#pswp__icn-arrow\"/>',\n    outlineID: 'pswp__icn-arrow'\n  },\n  onClick: 'next',\n  onInit: (el, pswp) => {\n    initArrowButton(el, pswp, true);\n  }\n};\n\n/** @type {import('./ui-element.js').UIElementData} UIElementData */\nconst closeButton = {\n  name: 'close',\n  title: 'Close',\n  order: 20,\n  isButton: true,\n  html: {\n    isCustomSVG: true,\n    inner: '<path d=\"M24 10l-2-2-6 6-6-6-2 2 6 6-6 6 2 2 6-6 6 6 2-2-6-6z\" id=\"pswp__icn-close\"/>',\n    outlineID: 'pswp__icn-close'\n  },\n  onClick: 'close'\n};\n\n/** @type {import('./ui-element.js').UIElementData} UIElementData */\nconst zoomButton = {\n  name: 'zoom',\n  title: 'Zoom',\n  order: 10,\n  isButton: true,\n  html: {\n    isCustomSVG: true,\n    // eslint-disable-next-line max-len\n    inner: '<path d=\"M17.426 19.926a6 6 0 1 1 1.5-1.5L23 22.5 21.5 24l-4.074-4.074z\" id=\"pswp__icn-zoom\"/>' + '<path fill=\"currentColor\" class=\"pswp__zoom-icn-bar-h\" d=\"M11 16v-2h6v2z\"/>' + '<path fill=\"currentColor\" class=\"pswp__zoom-icn-bar-v\" d=\"M13 12h2v6h-2z\"/>',\n    outlineID: 'pswp__icn-zoom'\n  },\n  onClick: 'toggleZoom'\n};\n\n/** @type {import('./ui-element.js').UIElementData} UIElementData */\nconst loadingIndicator = {\n  name: 'preloader',\n  appendTo: 'bar',\n  order: 7,\n  html: {\n    isCustomSVG: true,\n    // eslint-disable-next-line max-len\n    inner: '<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M21.2 16a5.2 5.2 0 1 1-5.2-5.2V8a8 8 0 1 0 8 8h-2.8Z\" id=\"pswp__icn-loading\"/>',\n    outlineID: 'pswp__icn-loading'\n  },\n  onInit: (indicatorElement, pswp) => {\n    /** @type {boolean | undefined} */\n    let isVisible;\n    /** @type {NodeJS.Timeout | null} */\n\n    let delayTimeout = null;\n    /**\r\n     * @param {string} className\r\n     * @param {boolean} add\r\n     */\n\n    const toggleIndicatorClass = (className, add) => {\n      indicatorElement.classList.toggle('pswp__preloader--' + className, add);\n    };\n    /**\r\n     * @param {boolean} visible\r\n     */\n\n\n    const setIndicatorVisibility = visible => {\n      if (isVisible !== visible) {\n        isVisible = visible;\n        toggleIndicatorClass('active', visible);\n      }\n    };\n\n    const updatePreloaderVisibility = () => {\n      var _pswp$currSlide;\n\n      if (!((_pswp$currSlide = pswp.currSlide) !== null && _pswp$currSlide !== void 0 && _pswp$currSlide.content.isLoading())) {\n        setIndicatorVisibility(false);\n\n        if (delayTimeout) {\n          clearTimeout(delayTimeout);\n          delayTimeout = null;\n        }\n\n        return;\n      }\n\n      if (!delayTimeout) {\n        // display loading indicator with delay\n        delayTimeout = setTimeout(() => {\n          var _pswp$currSlide2;\n\n          setIndicatorVisibility(Boolean((_pswp$currSlide2 = pswp.currSlide) === null || _pswp$currSlide2 === void 0 ? void 0 : _pswp$currSlide2.content.isLoading()));\n          delayTimeout = null;\n        }, pswp.options.preloaderDelay);\n      }\n    };\n\n    pswp.on('change', updatePreloaderVisibility);\n    pswp.on('loadComplete', e => {\n      if (pswp.currSlide === e.slide) {\n        updatePreloaderVisibility();\n      }\n    }); // expose the method\n\n    if (pswp.ui) {\n      pswp.ui.updatePreloaderVisibility = updatePreloaderVisibility;\n    }\n  }\n};\n\n/** @type {import('./ui-element.js').UIElementData} UIElementData */\nconst counterIndicator = {\n  name: 'counter',\n  order: 5,\n  onInit: (counterElement, pswp) => {\n    pswp.on('change', () => {\n      counterElement.innerText = pswp.currIndex + 1 + pswp.options.indexIndicatorSep + pswp.getNumItems();\n    });\n  }\n};\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('./ui-element.js').UIElementData} UIElementData */\n\n/**\r\n * Set special class on element when image is zoomed.\r\n *\r\n * By default, it is used to adjust\r\n * zoom icon and zoom cursor via CSS.\r\n *\r\n * @param {HTMLElement} el\r\n * @param {boolean} isZoomedIn\r\n */\n\nfunction setZoomedIn(el, isZoomedIn) {\n  el.classList.toggle('pswp--zoomed-in', isZoomedIn);\n}\n\nclass UI {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    this.isRegistered = false;\n    /** @type {UIElementData[]} */\n\n    this.uiElementsData = [];\n    /** @type {(UIElement | UIElementData)[]} */\n\n    this.items = [];\n    /** @type {() => void} */\n\n    this.updatePreloaderVisibility = () => {};\n    /**\r\n     * @private\r\n     * @type {number | undefined}\r\n     */\n\n\n    this._lastUpdatedZoomLevel = undefined;\n  }\n\n  init() {\n    const {\n      pswp\n    } = this;\n    this.isRegistered = false;\n    this.uiElementsData = [closeButton, arrowPrev, arrowNext, zoomButton, loadingIndicator, counterIndicator];\n    pswp.dispatch('uiRegister'); // sort by order\n\n    this.uiElementsData.sort((a, b) => {\n      // default order is 0\n      return (a.order || 0) - (b.order || 0);\n    });\n    this.items = [];\n    this.isRegistered = true;\n    this.uiElementsData.forEach(uiElementData => {\n      this.registerElement(uiElementData);\n    });\n    pswp.on('change', () => {\n      var _pswp$element;\n\n      (_pswp$element = pswp.element) === null || _pswp$element === void 0 || _pswp$element.classList.toggle('pswp--one-slide', pswp.getNumItems() === 1);\n    });\n    pswp.on('zoomPanUpdate', () => this._onZoomPanUpdate());\n  }\n  /**\r\n   * @param {UIElementData} elementData\r\n   */\n\n\n  registerElement(elementData) {\n    if (this.isRegistered) {\n      this.items.push(new UIElement(this.pswp, elementData));\n    } else {\n      this.uiElementsData.push(elementData);\n    }\n  }\n  /**\r\n   * Fired each time zoom or pan position is changed.\r\n   * Update classes that control visibility of zoom button and cursor icon.\r\n   *\r\n   * @private\r\n   */\n\n\n  _onZoomPanUpdate() {\n    const {\n      template,\n      currSlide,\n      options\n    } = this.pswp;\n\n    if (this.pswp.opener.isClosing || !template || !currSlide) {\n      return;\n    }\n\n    let {\n      currZoomLevel\n    } = currSlide; // if not open yet - check against initial zoom level\n\n    if (!this.pswp.opener.isOpen) {\n      currZoomLevel = currSlide.zoomLevels.initial;\n    }\n\n    if (currZoomLevel === this._lastUpdatedZoomLevel) {\n      return;\n    }\n\n    this._lastUpdatedZoomLevel = currZoomLevel;\n    const currZoomLevelDiff = currSlide.zoomLevels.initial - currSlide.zoomLevels.secondary; // Initial and secondary zoom levels are almost equal\n\n    if (Math.abs(currZoomLevelDiff) < 0.01 || !currSlide.isZoomable()) {\n      // disable zoom\n      setZoomedIn(template, false);\n      template.classList.remove('pswp--zoom-allowed');\n      return;\n    }\n\n    template.classList.add('pswp--zoom-allowed');\n    const potentialZoomLevel = currZoomLevel === currSlide.zoomLevels.initial ? currSlide.zoomLevels.secondary : currSlide.zoomLevels.initial;\n    setZoomedIn(template, potentialZoomLevel <= currZoomLevel);\n\n    if (options.imageClickAction === 'zoom' || options.imageClickAction === 'zoom-or-close') {\n      template.classList.add('pswp--click-to-zoom');\n    }\n  }\n\n}\n\n/** @typedef {import('./slide.js').SlideData} SlideData */\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {{ x: number; y: number; w: number; innerRect?: { w: number; h: number; x: number; y: number } }} Bounds */\n\n/**\r\n * @param {HTMLElement} el\r\n * @returns Bounds\r\n */\nfunction getBoundsByElement(el) {\n  const thumbAreaRect = el.getBoundingClientRect();\n  return {\n    x: thumbAreaRect.left,\n    y: thumbAreaRect.top,\n    w: thumbAreaRect.width\n  };\n}\n/**\r\n * @param {HTMLElement} el\r\n * @param {number} imageWidth\r\n * @param {number} imageHeight\r\n * @returns Bounds\r\n */\n\n\nfunction getCroppedBoundsByElement(el, imageWidth, imageHeight) {\n  const thumbAreaRect = el.getBoundingClientRect(); // fill image into the area\n  // (do they same as object-fit:cover does to retrieve coordinates)\n\n  const hRatio = thumbAreaRect.width / imageWidth;\n  const vRatio = thumbAreaRect.height / imageHeight;\n  const fillZoomLevel = hRatio > vRatio ? hRatio : vRatio;\n  const offsetX = (thumbAreaRect.width - imageWidth * fillZoomLevel) / 2;\n  const offsetY = (thumbAreaRect.height - imageHeight * fillZoomLevel) / 2;\n  /**\r\n   * Coordinates of the image,\r\n   * as if it was not cropped,\r\n   * height is calculated automatically\r\n   *\r\n   * @type {Bounds}\r\n   */\n\n  const bounds = {\n    x: thumbAreaRect.left + offsetX,\n    y: thumbAreaRect.top + offsetY,\n    w: imageWidth * fillZoomLevel\n  }; // Coordinates of inner crop area\n  // relative to the image\n\n  bounds.innerRect = {\n    w: thumbAreaRect.width,\n    h: thumbAreaRect.height,\n    x: offsetX,\n    y: offsetY\n  };\n  return bounds;\n}\n/**\r\n * Get dimensions of thumbnail image\r\n * (click on which opens photoswipe or closes photoswipe to)\r\n *\r\n * @param {number} index\r\n * @param {SlideData} itemData\r\n * @param {PhotoSwipe} instance PhotoSwipe instance\r\n * @returns {Bounds | undefined}\r\n */\n\n\nfunction getThumbBounds(index, itemData, instance) {\n  // legacy event, before filters were introduced\n  const event = instance.dispatch('thumbBounds', {\n    index,\n    itemData,\n    instance\n  }); // @ts-expect-error\n\n  if (event.thumbBounds) {\n    // @ts-expect-error\n    return event.thumbBounds;\n  }\n\n  const {\n    element\n  } = itemData;\n  /** @type {Bounds | undefined} */\n\n  let thumbBounds;\n  /** @type {HTMLElement | null | undefined} */\n\n  let thumbnail;\n\n  if (element && instance.options.thumbSelector !== false) {\n    const thumbSelector = instance.options.thumbSelector || 'img';\n    thumbnail = element.matches(thumbSelector) ? element :\n    /** @type {HTMLElement | null} */\n    element.querySelector(thumbSelector);\n  }\n\n  thumbnail = instance.applyFilters('thumbEl', thumbnail, itemData, index);\n\n  if (thumbnail) {\n    if (!itemData.thumbCropped) {\n      thumbBounds = getBoundsByElement(thumbnail);\n    } else {\n      thumbBounds = getCroppedBoundsByElement(thumbnail, itemData.width || itemData.w || 0, itemData.height || itemData.h || 0);\n    }\n  }\n\n  return instance.applyFilters('thumbBounds', thumbBounds, itemData, index);\n}\n\n/** @typedef {import('../lightbox/lightbox.js').default} PhotoSwipeLightbox */\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('../photoswipe.js').PhotoSwipeOptions} PhotoSwipeOptions */\n\n/** @typedef {import('../photoswipe.js').DataSource} DataSource */\n\n/** @typedef {import('../ui/ui-element.js').UIElementData} UIElementData */\n\n/** @typedef {import('../slide/content.js').default} ContentDefault */\n\n/** @typedef {import('../slide/slide.js').default} Slide */\n\n/** @typedef {import('../slide/slide.js').SlideData} SlideData */\n\n/** @typedef {import('../slide/zoom-level.js').default} ZoomLevel */\n\n/** @typedef {import('../slide/get-thumb-bounds.js').Bounds} Bounds */\n\n/**\r\n * Allow adding an arbitrary props to the Content\r\n * https://photoswipe.com/custom-content/#using-webp-image-format\r\n * @typedef {ContentDefault & Record<string, any>} Content\r\n */\n\n/** @typedef {{ x?: number; y?: number }} Point */\n\n/**\r\n * @typedef {Object} PhotoSwipeEventsMap https://photoswipe.com/events/\r\n *\r\n *\r\n * https://photoswipe.com/adding-ui-elements/\r\n *\r\n * @prop {undefined} uiRegister\r\n * @prop {{ data: UIElementData }} uiElementCreate\r\n *\r\n *\r\n * https://photoswipe.com/events/#initialization-events\r\n *\r\n * @prop {undefined} beforeOpen\r\n * @prop {undefined} firstUpdate\r\n * @prop {undefined} initialLayout\r\n * @prop {undefined} change\r\n * @prop {undefined} afterInit\r\n * @prop {undefined} bindEvents\r\n *\r\n *\r\n * https://photoswipe.com/events/#opening-or-closing-transition-events\r\n *\r\n * @prop {undefined} openingAnimationStart\r\n * @prop {undefined} openingAnimationEnd\r\n * @prop {undefined} closingAnimationStart\r\n * @prop {undefined} closingAnimationEnd\r\n *\r\n *\r\n * https://photoswipe.com/events/#closing-events\r\n *\r\n * @prop {undefined} close\r\n * @prop {undefined} destroy\r\n *\r\n *\r\n * https://photoswipe.com/events/#pointer-and-gesture-events\r\n *\r\n * @prop {{ originalEvent: PointerEvent }} pointerDown\r\n * @prop {{ originalEvent: PointerEvent }} pointerMove\r\n * @prop {{ originalEvent: PointerEvent }} pointerUp\r\n * @prop {{ bgOpacity: number }} pinchClose can be default prevented\r\n * @prop {{ panY: number }} verticalDrag can be default prevented\r\n *\r\n *\r\n * https://photoswipe.com/events/#slide-content-events\r\n *\r\n * @prop {{ content: Content }} contentInit\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoad can be default prevented\r\n * @prop {{ content: Content; isLazy: boolean }} contentLoadImage can be default prevented\r\n * @prop {{ content: Content; slide: Slide; isError?: boolean }} loadComplete\r\n * @prop {{ content: Content; slide: Slide }} loadError\r\n * @prop {{ content: Content; width: number; height: number }} contentResize can be default prevented\r\n * @prop {{ content: Content; width: number; height: number; slide: Slide }} imageSizeChange\r\n * @prop {{ content: Content }} contentLazyLoad can be default prevented\r\n * @prop {{ content: Content }} contentAppend can be default prevented\r\n * @prop {{ content: Content }} contentActivate can be default prevented\r\n * @prop {{ content: Content }} contentDeactivate can be default prevented\r\n * @prop {{ content: Content }} contentRemove can be default prevented\r\n * @prop {{ content: Content }} contentDestroy can be default prevented\r\n *\r\n *\r\n * undocumented\r\n *\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} imageClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} bgClickAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} tapAction can be default prevented\r\n * @prop {{ point: Point; originalEvent: PointerEvent }} doubleTapAction can be default prevented\r\n *\r\n * @prop {{ originalEvent: KeyboardEvent }} keydown can be default prevented\r\n * @prop {{ x: number; dragging: boolean }} moveMainScroll\r\n * @prop {{ slide: Slide }} firstZoomPan\r\n * @prop {{ slide: Slide | undefined, data: SlideData, index: number }} gettingData\r\n * @prop {undefined} beforeResize\r\n * @prop {undefined} resize\r\n * @prop {undefined} viewportSize\r\n * @prop {undefined} updateScrollOffset\r\n * @prop {{ slide: Slide }} slideInit\r\n * @prop {{ slide: Slide }} afterSetContent\r\n * @prop {{ slide: Slide }} slideLoad\r\n * @prop {{ slide: Slide }} appendHeavy can be default prevented\r\n * @prop {{ slide: Slide }} appendHeavyContent\r\n * @prop {{ slide: Slide }} slideActivate\r\n * @prop {{ slide: Slide }} slideDeactivate\r\n * @prop {{ slide: Slide }} slideDestroy\r\n * @prop {{ destZoomLevel: number, centerPoint: Point | undefined, transitionDuration: number | false | undefined }} beforeZoomTo\r\n * @prop {{ slide: Slide }} zoomPanUpdate\r\n * @prop {{ slide: Slide }} initialZoomPan\r\n * @prop {{ slide: Slide }} calcSlideSize\r\n * @prop {undefined} resolutionChanged\r\n * @prop {{ originalEvent: WheelEvent }} wheel can be default prevented\r\n * @prop {{ content: Content }} contentAppendImage can be default prevented\r\n * @prop {{ index: number; itemData: SlideData }} lazyLoadSlide can be default prevented\r\n * @prop {undefined} lazyLoad\r\n * @prop {{ slide: Slide }} calcBounds\r\n * @prop {{ zoomLevels: ZoomLevel, slideData: SlideData }} zoomLevelsUpdate\r\n *\r\n *\r\n * legacy\r\n *\r\n * @prop {undefined} init\r\n * @prop {undefined} initialZoomIn\r\n * @prop {undefined} initialZoomOut\r\n * @prop {undefined} initialZoomInEnd\r\n * @prop {undefined} initialZoomOutEnd\r\n * @prop {{ dataSource: DataSource | undefined, numItems: number }} numItems\r\n * @prop {{ itemData: SlideData; index: number }} itemData\r\n * @prop {{ index: number, itemData: SlideData, instance: PhotoSwipe }} thumbBounds\r\n */\n\n/**\r\n * @typedef {Object} PhotoSwipeFiltersMap https://photoswipe.com/filters/\r\n *\r\n * @prop {(numItems: number, dataSource: DataSource | undefined) => number} numItems\r\n * Modify the total amount of slides. Example on Data sources page.\r\n * https://photoswipe.com/filters/#numitems\r\n *\r\n * @prop {(itemData: SlideData, index: number) => SlideData} itemData\r\n * Modify slide item data. Example on Data sources page.\r\n * https://photoswipe.com/filters/#itemdata\r\n *\r\n * @prop {(itemData: SlideData, element: HTMLElement, linkEl: HTMLAnchorElement) => SlideData} domItemData\r\n * Modify item data when it's parsed from DOM element. Example on Data sources page.\r\n * https://photoswipe.com/filters/#domitemdata\r\n *\r\n * @prop {(clickedIndex: number, e: MouseEvent, instance: PhotoSwipeLightbox) => number} clickedIndex\r\n * Modify clicked gallery item index.\r\n * https://photoswipe.com/filters/#clickedindex\r\n *\r\n * @prop {(placeholderSrc: string | false, content: Content) => string | false} placeholderSrc\r\n * Modify placeholder image source.\r\n * https://photoswipe.com/filters/#placeholdersrc\r\n *\r\n * @prop {(isContentLoading: boolean, content: Content) => boolean} isContentLoading\r\n * Modify if the content is currently loading.\r\n * https://photoswipe.com/filters/#iscontentloading\r\n *\r\n * @prop {(isContentZoomable: boolean, content: Content) => boolean} isContentZoomable\r\n * Modify if the content can be zoomed.\r\n * https://photoswipe.com/filters/#iscontentzoomable\r\n *\r\n * @prop {(useContentPlaceholder: boolean, content: Content) => boolean} useContentPlaceholder\r\n * Modify if the placeholder should be used for the content.\r\n * https://photoswipe.com/filters/#usecontentplaceholder\r\n *\r\n * @prop {(isKeepingPlaceholder: boolean, content: Content) => boolean} isKeepingPlaceholder\r\n * Modify if the placeholder should be kept after the content is loaded.\r\n * https://photoswipe.com/filters/#iskeepingplaceholder\r\n *\r\n *\r\n * @prop {(contentErrorElement: HTMLElement, content: Content) => HTMLElement} contentErrorElement\r\n * Modify an element when the content has error state (for example, if image cannot be loaded).\r\n * https://photoswipe.com/filters/#contenterrorelement\r\n *\r\n * @prop {(element: HTMLElement, data: UIElementData) => HTMLElement} uiElement\r\n * Modify a UI element that's being created.\r\n * https://photoswipe.com/filters/#uielement\r\n *\r\n * @prop {(thumbnail: HTMLElement | null | undefined, itemData: SlideData, index: number) => HTMLElement} thumbEl\r\n * Modify the thumbnail element from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbel\r\n *\r\n * @prop {(thumbBounds: Bounds | undefined, itemData: SlideData, index: number) => Bounds} thumbBounds\r\n * Modify the thumbnail bounds from which opening zoom animation starts or ends.\r\n * https://photoswipe.com/filters/#thumbbounds\r\n *\r\n * @prop {(srcsetSizesWidth: number, content: Content) => number} srcsetSizesWidth\r\n *\r\n * @prop {(preventPointerEvent: boolean, event: PointerEvent, pointerType: string) => boolean} preventPointerEvent\r\n *\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeFiltersMap} T\r\n * @typedef {{ fn: PhotoSwipeFiltersMap[T], priority: number }} Filter\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {PhotoSwipeEventsMap[T] extends undefined ? PhotoSwipeEvent<T> : PhotoSwipeEvent<T> & PhotoSwipeEventsMap[T]} AugmentedEvent\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {(event: AugmentedEvent<T>) => void} EventCallback\r\n */\n\n/**\r\n * Base PhotoSwipe event object\r\n *\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n */\nclass PhotoSwipeEvent {\n  /**\r\n   * @param {T} type\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   */\n  constructor(type, details) {\n    this.type = type;\n    this.defaultPrevented = false;\n\n    if (details) {\n      Object.assign(this, details);\n    }\n  }\n\n  preventDefault() {\n    this.defaultPrevented = true;\n  }\n\n}\n/**\r\n * PhotoSwipe base class that can listen and dispatch for events.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox, extended by base.js\r\n */\n\n\nclass Eventable {\n  constructor() {\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeEventsMap]?: ((event: AugmentedEvent<T>) => void)[] }}\r\n     */\n    this._listeners = {};\n    /**\r\n     * @type {{ [T in keyof PhotoSwipeFiltersMap]?: Filter<T>[] }}\r\n     */\n\n    this._filters = {};\n    /** @type {PhotoSwipe | undefined} */\n\n    this.pswp = undefined;\n    /** @type {PhotoSwipeOptions | undefined} */\n\n    this.options = undefined;\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   * @param {number} priority\r\n   */\n\n\n  addFilter(name, fn, priority = 100) {\n    var _this$_filters$name, _this$_filters$name2, _this$pswp;\n\n    if (!this._filters[name]) {\n      this._filters[name] = [];\n    }\n\n    (_this$_filters$name = this._filters[name]) === null || _this$_filters$name === void 0 || _this$_filters$name.push({\n      fn,\n      priority\n    });\n    (_this$_filters$name2 = this._filters[name]) === null || _this$_filters$name2 === void 0 || _this$_filters$name2.sort((f1, f2) => f1.priority - f2.priority);\n    (_this$pswp = this.pswp) === null || _this$pswp === void 0 || _this$pswp.addFilter(name, fn, priority);\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeFiltersMap[T]} fn\r\n   */\n\n\n  removeFilter(name, fn) {\n    if (this._filters[name]) {\n      // @ts-expect-error\n      this._filters[name] = this._filters[name].filter(filter => filter.fn !== fn);\n    }\n\n    if (this.pswp) {\n      this.pswp.removeFilter(name, fn);\n    }\n  }\n  /**\r\n   * @template {keyof PhotoSwipeFiltersMap} T\r\n   * @param {T} name\r\n   * @param {Parameters<PhotoSwipeFiltersMap[T]>} args\r\n   * @returns {Parameters<PhotoSwipeFiltersMap[T]>[0]}\r\n   */\n\n\n  applyFilters(name, ...args) {\n    var _this$_filters$name3;\n\n    (_this$_filters$name3 = this._filters[name]) === null || _this$_filters$name3 === void 0 || _this$_filters$name3.forEach(filter => {\n      // @ts-expect-error\n      args[0] = filter.fn.apply(this, args);\n    });\n    return args[0];\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\n\n\n  on(name, fn) {\n    var _this$_listeners$name, _this$pswp2;\n\n    if (!this._listeners[name]) {\n      this._listeners[name] = [];\n    }\n\n    (_this$_listeners$name = this._listeners[name]) === null || _this$_listeners$name === void 0 || _this$_listeners$name.push(fn); // When binding events to lightbox,\n    // also bind events to PhotoSwipe Core,\n    // if it's open.\n\n    (_this$pswp2 = this.pswp) === null || _this$pswp2 === void 0 || _this$pswp2.on(name, fn);\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {EventCallback<T>} fn\r\n   */\n\n\n  off(name, fn) {\n    var _this$pswp3;\n\n    if (this._listeners[name]) {\n      // @ts-expect-error\n      this._listeners[name] = this._listeners[name].filter(listener => fn !== listener);\n    }\n\n    (_this$pswp3 = this.pswp) === null || _this$pswp3 === void 0 || _this$pswp3.off(name, fn);\n  }\n  /**\r\n   * @template {keyof PhotoSwipeEventsMap} T\r\n   * @param {T} name\r\n   * @param {PhotoSwipeEventsMap[T]} [details]\r\n   * @returns {AugmentedEvent<T>}\r\n   */\n\n\n  dispatch(name, details) {\n    var _this$_listeners$name2;\n\n    if (this.pswp) {\n      return this.pswp.dispatch(name, details);\n    }\n\n    const event =\n    /** @type {AugmentedEvent<T>} */\n    new PhotoSwipeEvent(name, details);\n    (_this$_listeners$name2 = this._listeners[name]) === null || _this$_listeners$name2 === void 0 || _this$_listeners$name2.forEach(listener => {\n      listener.call(this, event);\n    });\n    return event;\n  }\n\n}\n\nclass Placeholder {\n  /**\r\n   * @param {string | false} imageSrc\r\n   * @param {HTMLElement} container\r\n   */\n  constructor(imageSrc, container) {\n    // Create placeholder\n    // (stretched thumbnail or simple div behind the main image)\n\n    /** @type {HTMLImageElement | HTMLDivElement | null} */\n    this.element = createElement('pswp__img pswp__img--placeholder', imageSrc ? 'img' : 'div', container);\n\n    if (imageSrc) {\n      const imgEl =\n      /** @type {HTMLImageElement} */\n      this.element;\n      imgEl.decoding = 'async';\n      imgEl.alt = '';\n      imgEl.src = imageSrc;\n      imgEl.setAttribute('role', 'presentation');\n    }\n\n    this.element.setAttribute('aria-hidden', 'true');\n  }\n  /**\r\n   * @param {number} width\r\n   * @param {number} height\r\n   */\n\n\n  setDisplayedSize(width, height) {\n    if (!this.element) {\n      return;\n    }\n\n    if (this.element.tagName === 'IMG') {\n      // Use transform scale() to modify img placeholder size\n      // (instead of changing width/height directly).\n      // This helps with performance, specifically in iOS15 Safari.\n      setWidthHeight(this.element, 250, 'auto');\n      this.element.style.transformOrigin = '0 0';\n      this.element.style.transform = toTransformString(0, 0, width / 250);\n    } else {\n      setWidthHeight(this.element, width, height);\n    }\n  }\n\n  destroy() {\n    var _this$element;\n\n    if ((_this$element = this.element) !== null && _this$element !== void 0 && _this$element.parentNode) {\n      this.element.remove();\n    }\n\n    this.element = null;\n  }\n\n}\n\n/** @typedef {import('./slide.js').default} Slide */\n\n/** @typedef {import('./slide.js').SlideData} SlideData */\n\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\n\n/** @typedef {import('../util/util.js').LoadState} LoadState */\n\nclass Content {\n  /**\r\n   * @param {SlideData} itemData Slide data\r\n   * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n   * @param {number} index\r\n   */\n  constructor(itemData, instance, index) {\n    this.instance = instance;\n    this.data = itemData;\n    this.index = index;\n    /** @type {HTMLImageElement | HTMLDivElement | undefined} */\n\n    this.element = undefined;\n    /** @type {Placeholder | undefined} */\n\n    this.placeholder = undefined;\n    /** @type {Slide | undefined} */\n\n    this.slide = undefined;\n    this.displayedImageWidth = 0;\n    this.displayedImageHeight = 0;\n    this.width = Number(this.data.w) || Number(this.data.width) || 0;\n    this.height = Number(this.data.h) || Number(this.data.height) || 0;\n    this.isAttached = false;\n    this.hasSlide = false;\n    this.isDecoding = false;\n    /** @type {LoadState} */\n\n    this.state = LOAD_STATE.IDLE;\n\n    if (this.data.type) {\n      this.type = this.data.type;\n    } else if (this.data.src) {\n      this.type = 'image';\n    } else {\n      this.type = 'html';\n    }\n\n    this.instance.dispatch('contentInit', {\n      content: this\n    });\n  }\n\n  removePlaceholder() {\n    if (this.placeholder && !this.keepPlaceholder()) {\n      // With delay, as image might be loaded, but not rendered\n      setTimeout(() => {\n        if (this.placeholder) {\n          this.placeholder.destroy();\n          this.placeholder = undefined;\n        }\n      }, 1000);\n    }\n  }\n  /**\r\n   * Preload content\r\n   *\r\n   * @param {boolean} isLazy\r\n   * @param {boolean} [reload]\r\n   */\n\n\n  load(isLazy, reload) {\n    if (this.slide && this.usePlaceholder()) {\n      if (!this.placeholder) {\n        const placeholderSrc = this.instance.applyFilters('placeholderSrc', // use  image-based placeholder only for the first slide,\n        // as rendering (even small stretched thumbnail) is an expensive operation\n        this.data.msrc && this.slide.isFirstSlide ? this.data.msrc : false, this);\n        this.placeholder = new Placeholder(placeholderSrc, this.slide.container);\n      } else {\n        const placeholderEl = this.placeholder.element; // Add placeholder to DOM if it was already created\n\n        if (placeholderEl && !placeholderEl.parentElement) {\n          this.slide.container.prepend(placeholderEl);\n        }\n      }\n    }\n\n    if (this.element && !reload) {\n      return;\n    }\n\n    if (this.instance.dispatch('contentLoad', {\n      content: this,\n      isLazy\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.isImageContent()) {\n      this.element = createElement('pswp__img', 'img'); // Start loading only after width is defined, as sizes might depend on it.\n      // Due to Safari feature, we must define sizes before srcset.\n\n      if (this.displayedImageWidth) {\n        this.loadImage(isLazy);\n      }\n    } else {\n      this.element = createElement('pswp__content', 'div');\n      this.element.innerHTML = this.data.html || '';\n    }\n\n    if (reload && this.slide) {\n      this.slide.updateContentSize(true);\n    }\n  }\n  /**\r\n   * Preload image\r\n   *\r\n   * @param {boolean} isLazy\r\n   */\n\n\n  loadImage(isLazy) {\n    var _this$data$src, _this$data$alt;\n\n    if (!this.isImageContent() || !this.element || this.instance.dispatch('contentLoadImage', {\n      content: this,\n      isLazy\n    }).defaultPrevented) {\n      return;\n    }\n\n    const imageElement =\n    /** @type HTMLImageElement */\n    this.element;\n    this.updateSrcsetSizes();\n\n    if (this.data.srcset) {\n      imageElement.srcset = this.data.srcset;\n    }\n\n    imageElement.src = (_this$data$src = this.data.src) !== null && _this$data$src !== void 0 ? _this$data$src : '';\n    imageElement.alt = (_this$data$alt = this.data.alt) !== null && _this$data$alt !== void 0 ? _this$data$alt : '';\n    this.state = LOAD_STATE.LOADING;\n\n    if (imageElement.complete) {\n      this.onLoaded();\n    } else {\n      imageElement.onload = () => {\n        this.onLoaded();\n      };\n\n      imageElement.onerror = () => {\n        this.onError();\n      };\n    }\n  }\n  /**\r\n   * Assign slide to content\r\n   *\r\n   * @param {Slide} slide\r\n   */\n\n\n  setSlide(slide) {\n    this.slide = slide;\n    this.hasSlide = true;\n    this.instance = slide.pswp; // todo: do we need to unset slide?\n  }\n  /**\r\n   * Content load success handler\r\n   */\n\n\n  onLoaded() {\n    this.state = LOAD_STATE.LOADED;\n\n    if (this.slide && this.element) {\n      this.instance.dispatch('loadComplete', {\n        slide: this.slide,\n        content: this\n      }); // if content is reloaded\n\n      if (this.slide.isActive && this.slide.heavyAppended && !this.element.parentNode) {\n        this.append();\n        this.slide.updateContentSize(true);\n      }\n\n      if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\n        this.removePlaceholder();\n      }\n    }\n  }\n  /**\r\n   * Content load error handler\r\n   */\n\n\n  onError() {\n    this.state = LOAD_STATE.ERROR;\n\n    if (this.slide) {\n      this.displayError();\n      this.instance.dispatch('loadComplete', {\n        slide: this.slide,\n        isError: true,\n        content: this\n      });\n      this.instance.dispatch('loadError', {\n        slide: this.slide,\n        content: this\n      });\n    }\n  }\n  /**\r\n   * @returns {Boolean} If the content is currently loading\r\n   */\n\n\n  isLoading() {\n    return this.instance.applyFilters('isContentLoading', this.state === LOAD_STATE.LOADING, this);\n  }\n  /**\r\n   * @returns {Boolean} If the content is in error state\r\n   */\n\n\n  isError() {\n    return this.state === LOAD_STATE.ERROR;\n  }\n  /**\r\n   * @returns {boolean} If the content is image\r\n   */\n\n\n  isImageContent() {\n    return this.type === 'image';\n  }\n  /**\r\n   * Update content size\r\n   *\r\n   * @param {Number} width\r\n   * @param {Number} height\r\n   */\n\n\n  setDisplayedSize(width, height) {\n    if (!this.element) {\n      return;\n    }\n\n    if (this.placeholder) {\n      this.placeholder.setDisplayedSize(width, height);\n    }\n\n    if (this.instance.dispatch('contentResize', {\n      content: this,\n      width,\n      height\n    }).defaultPrevented) {\n      return;\n    }\n\n    setWidthHeight(this.element, width, height);\n\n    if (this.isImageContent() && !this.isError()) {\n      const isInitialSizeUpdate = !this.displayedImageWidth && width;\n      this.displayedImageWidth = width;\n      this.displayedImageHeight = height;\n\n      if (isInitialSizeUpdate) {\n        this.loadImage(false);\n      } else {\n        this.updateSrcsetSizes();\n      }\n\n      if (this.slide) {\n        this.instance.dispatch('imageSizeChange', {\n          slide: this.slide,\n          width,\n          height,\n          content: this\n        });\n      }\n    }\n  }\n  /**\r\n   * @returns {boolean} If the content can be zoomed\r\n   */\n\n\n  isZoomable() {\n    return this.instance.applyFilters('isContentZoomable', this.isImageContent() && this.state !== LOAD_STATE.ERROR, this);\n  }\n  /**\r\n   * Update image srcset sizes attribute based on width and height\r\n   */\n\n\n  updateSrcsetSizes() {\n    // Handle srcset sizes attribute.\n    //\n    // Never lower quality, if it was increased previously.\n    // Chrome does this automatically, Firefox and Safari do not,\n    // so we store largest used size in dataset.\n    if (!this.isImageContent() || !this.element || !this.data.srcset) {\n      return;\n    }\n\n    const image =\n    /** @type HTMLImageElement */\n    this.element;\n    const sizesWidth = this.instance.applyFilters('srcsetSizesWidth', this.displayedImageWidth, this);\n\n    if (!image.dataset.largestUsedSize || sizesWidth > parseInt(image.dataset.largestUsedSize, 10)) {\n      image.sizes = sizesWidth + 'px';\n      image.dataset.largestUsedSize = String(sizesWidth);\n    }\n  }\n  /**\r\n   * @returns {boolean} If content should use a placeholder (from msrc by default)\r\n   */\n\n\n  usePlaceholder() {\n    return this.instance.applyFilters('useContentPlaceholder', this.isImageContent(), this);\n  }\n  /**\r\n   * Preload content with lazy-loading param\r\n   */\n\n\n  lazyLoad() {\n    if (this.instance.dispatch('contentLazyLoad', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    this.load(true);\n  }\n  /**\r\n   * @returns {boolean} If placeholder should be kept after content is loaded\r\n   */\n\n\n  keepPlaceholder() {\n    return this.instance.applyFilters('isKeepingPlaceholder', this.isLoading(), this);\n  }\n  /**\r\n   * Destroy the content\r\n   */\n\n\n  destroy() {\n    this.hasSlide = false;\n    this.slide = undefined;\n\n    if (this.instance.dispatch('contentDestroy', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    this.remove();\n\n    if (this.placeholder) {\n      this.placeholder.destroy();\n      this.placeholder = undefined;\n    }\n\n    if (this.isImageContent() && this.element) {\n      this.element.onload = null;\n      this.element.onerror = null;\n      this.element = undefined;\n    }\n  }\n  /**\r\n   * Display error message\r\n   */\n\n\n  displayError() {\n    if (this.slide) {\n      var _this$instance$option, _this$instance$option2;\n\n      let errorMsgEl = createElement('pswp__error-msg', 'div');\n      errorMsgEl.innerText = (_this$instance$option = (_this$instance$option2 = this.instance.options) === null || _this$instance$option2 === void 0 ? void 0 : _this$instance$option2.errorMsg) !== null && _this$instance$option !== void 0 ? _this$instance$option : '';\n      errorMsgEl =\n      /** @type {HTMLDivElement} */\n      this.instance.applyFilters('contentErrorElement', errorMsgEl, this);\n      this.element = createElement('pswp__content pswp__error-msg-container', 'div');\n      this.element.appendChild(errorMsgEl);\n      this.slide.container.innerText = '';\n      this.slide.container.appendChild(this.element);\n      this.slide.updateContentSize(true);\n      this.removePlaceholder();\n    }\n  }\n  /**\r\n   * Append the content\r\n   */\n\n\n  append() {\n    if (this.isAttached || !this.element) {\n      return;\n    }\n\n    this.isAttached = true;\n\n    if (this.state === LOAD_STATE.ERROR) {\n      this.displayError();\n      return;\n    }\n\n    if (this.instance.dispatch('contentAppend', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    const supportsDecode = ('decode' in this.element);\n\n    if (this.isImageContent()) {\n      // Use decode() on nearby slides\n      //\n      // Nearby slide images are in DOM and not hidden via display:none.\n      // However, they are placed offscreen (to the left and right side).\n      //\n      // Some browsers do not composite the image until it's actually visible,\n      // using decode() helps.\n      //\n      // You might ask \"why dont you just decode() and then append all images\",\n      // that's because I want to show image before it's fully loaded,\n      // as browser can render parts of image while it is loading.\n      // We do not do this in Safari due to partial loading bug.\n      if (supportsDecode && this.slide && (!this.slide.isActive || isSafari())) {\n        this.isDecoding = true; // purposefully using finally instead of then,\n        // as if srcset sizes changes dynamically - it may cause decode error\n\n        /** @type {HTMLImageElement} */\n\n        this.element.decode().catch(() => {}).finally(() => {\n          this.isDecoding = false;\n          this.appendImage();\n        });\n      } else {\n        this.appendImage();\n      }\n    } else if (this.slide && !this.element.parentNode) {\n      this.slide.container.appendChild(this.element);\n    }\n  }\n  /**\r\n   * Activate the slide,\r\n   * active slide is generally the current one,\r\n   * meaning the user can see it.\r\n   */\n\n\n  activate() {\n    if (this.instance.dispatch('contentActivate', {\n      content: this\n    }).defaultPrevented || !this.slide) {\n      return;\n    }\n\n    if (this.isImageContent() && this.isDecoding && !isSafari()) {\n      // add image to slide when it becomes active,\n      // even if it's not finished decoding\n      this.appendImage();\n    } else if (this.isError()) {\n      this.load(false, true); // try to reload\n    }\n\n    if (this.slide.holderElement) {\n      this.slide.holderElement.setAttribute('aria-hidden', 'false');\n    }\n  }\n  /**\r\n   * Deactivate the content\r\n   */\n\n\n  deactivate() {\n    this.instance.dispatch('contentDeactivate', {\n      content: this\n    });\n\n    if (this.slide && this.slide.holderElement) {\n      this.slide.holderElement.setAttribute('aria-hidden', 'true');\n    }\n  }\n  /**\r\n   * Remove the content from DOM\r\n   */\n\n\n  remove() {\n    this.isAttached = false;\n\n    if (this.instance.dispatch('contentRemove', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    }\n\n    if (this.element && this.element.parentNode) {\n      this.element.remove();\n    }\n\n    if (this.placeholder && this.placeholder.element) {\n      this.placeholder.element.remove();\n    }\n  }\n  /**\r\n   * Append the image content to slide container\r\n   */\n\n\n  appendImage() {\n    if (!this.isAttached) {\n      return;\n    }\n\n    if (this.instance.dispatch('contentAppendImage', {\n      content: this\n    }).defaultPrevented) {\n      return;\n    } // ensure that element exists and is not already appended\n\n\n    if (this.slide && this.element && !this.element.parentNode) {\n      this.slide.container.appendChild(this.element);\n    }\n\n    if (this.state === LOAD_STATE.LOADED || this.state === LOAD_STATE.ERROR) {\n      this.removePlaceholder();\n    }\n  }\n\n}\n\n/** @typedef {import('./content.js').default} Content */\n\n/** @typedef {import('./slide.js').default} Slide */\n\n/** @typedef {import('./slide.js').SlideData} SlideData */\n\n/** @typedef {import('../core/base.js').default} PhotoSwipeBase */\n\n/** @typedef {import('../photoswipe.js').default} PhotoSwipe */\n\nconst MIN_SLIDES_TO_CACHE = 5;\n/**\r\n * Lazy-load an image\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * @param {SlideData} itemData Data about the slide\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox instance\r\n * @param {number} index\r\n * @returns {Content} Image that is being decoded or false.\r\n */\n\nfunction lazyLoadData(itemData, instance, index) {\n  const content = instance.createContentFromData(itemData, index);\n  /** @type {ZoomLevel | undefined} */\n\n  let zoomLevel;\n  const {\n    options\n  } = instance; // We need to know dimensions of the image to preload it,\n  // as it might use srcset, and we need to define sizes\n\n  if (options) {\n    zoomLevel = new ZoomLevel(options, itemData, -1);\n    let viewportSize;\n\n    if (instance.pswp) {\n      viewportSize = instance.pswp.viewportSize;\n    } else {\n      viewportSize = getViewportSize(options, instance);\n    }\n\n    const panAreaSize = getPanAreaSize(options, viewportSize, itemData, index);\n    zoomLevel.update(content.width, content.height, panAreaSize);\n  }\n\n  content.lazyLoad();\n\n  if (zoomLevel) {\n    content.setDisplayedSize(Math.ceil(content.width * zoomLevel.initial), Math.ceil(content.height * zoomLevel.initial));\n  }\n\n  return content;\n}\n/**\r\n * Lazy-loads specific slide.\r\n * This function is used both by Lightbox and PhotoSwipe core,\r\n * thus it can be called before dialog is opened.\r\n *\r\n * By default, it loads image based on viewport size and initial zoom level.\r\n *\r\n * @param {number} index Slide index\r\n * @param {PhotoSwipeBase} instance PhotoSwipe or PhotoSwipeLightbox eventable instance\r\n * @returns {Content | undefined}\r\n */\n\nfunction lazyLoadSlide(index, instance) {\n  const itemData = instance.getItemData(index);\n\n  if (instance.dispatch('lazyLoadSlide', {\n    index,\n    itemData\n  }).defaultPrevented) {\n    return;\n  }\n\n  return lazyLoadData(itemData, instance, index);\n}\n\nclass ContentLoader {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp; // Total amount of cached images\n\n    this.limit = Math.max(pswp.options.preload[0] + pswp.options.preload[1] + 1, MIN_SLIDES_TO_CACHE);\n    /** @type {Content[]} */\n\n    this._cachedItems = [];\n  }\n  /**\r\n   * Lazy load nearby slides based on `preload` option.\r\n   *\r\n   * @param {number} [diff] Difference between slide indexes that was changed recently, or 0.\r\n   */\n\n\n  updateLazy(diff) {\n    const {\n      pswp\n    } = this;\n\n    if (pswp.dispatch('lazyLoad').defaultPrevented) {\n      return;\n    }\n\n    const {\n      preload\n    } = pswp.options;\n    const isForward = diff === undefined ? true : diff >= 0;\n    let i; // preload[1] - num items to preload in forward direction\n\n    for (i = 0; i <= preload[1]; i++) {\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? i : -i));\n    } // preload[0] - num items to preload in backward direction\n\n\n    for (i = 1; i <= preload[0]; i++) {\n      this.loadSlideByIndex(pswp.currIndex + (isForward ? -i : i));\n    }\n  }\n  /**\r\n   * @param {number} initialIndex\r\n   */\n\n\n  loadSlideByIndex(initialIndex) {\n    const index = this.pswp.getLoopedIndex(initialIndex); // try to get cached content\n\n    let content = this.getContentByIndex(index);\n\n    if (!content) {\n      // no cached content, so try to load from scratch:\n      content = lazyLoadSlide(index, this.pswp); // if content can be loaded, add it to cache:\n\n      if (content) {\n        this.addToCache(content);\n      }\n    }\n  }\n  /**\r\n   * @param {Slide} slide\r\n   * @returns {Content}\r\n   */\n\n\n  getContentBySlide(slide) {\n    let content = this.getContentByIndex(slide.index);\n\n    if (!content) {\n      // create content if not found in cache\n      content = this.pswp.createContentFromData(slide.data, slide.index);\n      this.addToCache(content);\n    } // assign slide to content\n\n\n    content.setSlide(slide);\n    return content;\n  }\n  /**\r\n   * @param {Content} content\r\n   */\n\n\n  addToCache(content) {\n    // move to the end of array\n    this.removeByIndex(content.index);\n\n    this._cachedItems.push(content);\n\n    if (this._cachedItems.length > this.limit) {\n      // Destroy the first content that's not attached\n      const indexToRemove = this._cachedItems.findIndex(item => {\n        return !item.isAttached && !item.hasSlide;\n      });\n\n      if (indexToRemove !== -1) {\n        const removedItem = this._cachedItems.splice(indexToRemove, 1)[0];\n\n        removedItem.destroy();\n      }\n    }\n  }\n  /**\r\n   * Removes an image from cache, does not destroy() it, just removes.\r\n   *\r\n   * @param {number} index\r\n   */\n\n\n  removeByIndex(index) {\n    const indexToRemove = this._cachedItems.findIndex(item => item.index === index);\n\n    if (indexToRemove !== -1) {\n      this._cachedItems.splice(indexToRemove, 1);\n    }\n  }\n  /**\r\n   * @param {number} index\r\n   * @returns {Content | undefined}\r\n   */\n\n\n  getContentByIndex(index) {\n    return this._cachedItems.find(content => content.index === index);\n  }\n\n  destroy() {\n    this._cachedItems.forEach(content => content.destroy());\n\n    this._cachedItems = [];\n  }\n\n}\n\n/** @typedef {import(\"../photoswipe.js\").default} PhotoSwipe */\n\n/** @typedef {import(\"../slide/slide.js\").SlideData} SlideData */\n\n/**\r\n * PhotoSwipe base class that can retrieve data about every slide.\r\n * Shared by PhotoSwipe Core and PhotoSwipe Lightbox\r\n */\n\nclass PhotoSwipeBase extends Eventable {\n  /**\r\n   * Get total number of slides\r\n   *\r\n   * @returns {number}\r\n   */\n  getNumItems() {\n    var _this$options;\n\n    let numItems = 0;\n    const dataSource = (_this$options = this.options) === null || _this$options === void 0 ? void 0 : _this$options.dataSource;\n\n    if (dataSource && 'length' in dataSource) {\n      // may be an array or just object with length property\n      numItems = dataSource.length;\n    } else if (dataSource && 'gallery' in dataSource) {\n      // query DOM elements\n      if (!dataSource.items) {\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\n      }\n\n      if (dataSource.items) {\n        numItems = dataSource.items.length;\n      }\n    } // legacy event, before filters were introduced\n\n\n    const event = this.dispatch('numItems', {\n      dataSource,\n      numItems\n    });\n    return this.applyFilters('numItems', event.numItems, dataSource);\n  }\n  /**\r\n   * @param {SlideData} slideData\r\n   * @param {number} index\r\n   * @returns {Content}\r\n   */\n\n\n  createContentFromData(slideData, index) {\n    return new Content(slideData, this, index);\n  }\n  /**\r\n   * Get item data by index.\r\n   *\r\n   * \"item data\" should contain normalized information that PhotoSwipe needs to generate a slide.\r\n   * For example, it may contain properties like\r\n   * `src`, `srcset`, `w`, `h`, which will be used to generate a slide with image.\r\n   *\r\n   * @param {number} index\r\n   * @returns {SlideData}\r\n   */\n\n\n  getItemData(index) {\n    var _this$options2;\n\n    const dataSource = (_this$options2 = this.options) === null || _this$options2 === void 0 ? void 0 : _this$options2.dataSource;\n    /** @type {SlideData | HTMLElement} */\n\n    let dataSourceItem = {};\n\n    if (Array.isArray(dataSource)) {\n      // Datasource is an array of elements\n      dataSourceItem = dataSource[index];\n    } else if (dataSource && 'gallery' in dataSource) {\n      // dataSource has gallery property,\n      // thus it was created by Lightbox, based on\n      // gallery and children options\n      // query DOM elements\n      if (!dataSource.items) {\n        dataSource.items = this._getGalleryDOMElements(dataSource.gallery);\n      }\n\n      dataSourceItem = dataSource.items[index];\n    }\n\n    let itemData = dataSourceItem;\n\n    if (itemData instanceof Element) {\n      itemData = this._domElementToItemData(itemData);\n    } // Dispatching the itemData event,\n    // it's a legacy verion before filters were introduced\n\n\n    const event = this.dispatch('itemData', {\n      itemData: itemData || {},\n      index\n    });\n    return this.applyFilters('itemData', event.itemData, index);\n  }\n  /**\r\n   * Get array of gallery DOM elements,\r\n   * based on childSelector and gallery element.\r\n   *\r\n   * @param {HTMLElement} galleryElement\r\n   * @returns {HTMLElement[]}\r\n   */\n\n\n  _getGalleryDOMElements(galleryElement) {\n    var _this$options3, _this$options4;\n\n    if ((_this$options3 = this.options) !== null && _this$options3 !== void 0 && _this$options3.children || (_this$options4 = this.options) !== null && _this$options4 !== void 0 && _this$options4.childSelector) {\n      return getElementsFromOption(this.options.children, this.options.childSelector, galleryElement) || [];\n    }\n\n    return [galleryElement];\n  }\n  /**\r\n   * Converts DOM element to item data object.\r\n   *\r\n   * @param {HTMLElement} element DOM element\r\n   * @returns {SlideData}\r\n   */\n\n\n  _domElementToItemData(element) {\n    /** @type {SlideData} */\n    const itemData = {\n      element\n    };\n    const linkEl =\n    /** @type {HTMLAnchorElement} */\n    element.tagName === 'A' ? element : element.querySelector('a');\n\n    if (linkEl) {\n      // src comes from data-pswp-src attribute,\n      // if it's empty link href is used\n      itemData.src = linkEl.dataset.pswpSrc || linkEl.href;\n\n      if (linkEl.dataset.pswpSrcset) {\n        itemData.srcset = linkEl.dataset.pswpSrcset;\n      }\n\n      itemData.width = linkEl.dataset.pswpWidth ? parseInt(linkEl.dataset.pswpWidth, 10) : 0;\n      itemData.height = linkEl.dataset.pswpHeight ? parseInt(linkEl.dataset.pswpHeight, 10) : 0; // support legacy w & h properties\n\n      itemData.w = itemData.width;\n      itemData.h = itemData.height;\n\n      if (linkEl.dataset.pswpType) {\n        itemData.type = linkEl.dataset.pswpType;\n      }\n\n      const thumbnailEl = element.querySelector('img');\n\n      if (thumbnailEl) {\n        var _thumbnailEl$getAttri;\n\n        // msrc is URL to placeholder image that's displayed before large image is loaded\n        // by default it's displayed only for the first slide\n        itemData.msrc = thumbnailEl.currentSrc || thumbnailEl.src;\n        itemData.alt = (_thumbnailEl$getAttri = thumbnailEl.getAttribute('alt')) !== null && _thumbnailEl$getAttri !== void 0 ? _thumbnailEl$getAttri : '';\n      }\n\n      if (linkEl.dataset.pswpCropped || linkEl.dataset.cropped) {\n        itemData.thumbCropped = true;\n      }\n    }\n\n    return this.applyFilters('domItemData', itemData, element, linkEl);\n  }\n  /**\r\n   * Lazy-load by slide data\r\n   *\r\n   * @param {SlideData} itemData Data about the slide\r\n   * @param {number} index\r\n   * @returns {Content} Image that is being decoded or false.\r\n   */\n\n\n  lazyLoadData(itemData, index) {\n    return lazyLoadData(itemData, this, index);\n  }\n\n}\n\n/** @typedef {import('./photoswipe.js').default} PhotoSwipe */\n\n/** @typedef {import('./slide/get-thumb-bounds.js').Bounds} Bounds */\n\n/** @typedef {import('./util/animations.js').AnimationProps} AnimationProps */\n// some browsers do not paint\n// elements which opacity is set to 0,\n// since we need to pre-render elements for the animation -\n// we set it to the minimum amount\n\nconst MIN_OPACITY = 0.003;\n/**\r\n * Manages opening and closing transitions of the PhotoSwipe.\r\n *\r\n * It can perform zoom, fade or no transition.\r\n */\n\nclass Opener {\n  /**\r\n   * @param {PhotoSwipe} pswp\r\n   */\n  constructor(pswp) {\n    this.pswp = pswp;\n    this.isClosed = true;\n    this.isOpen = false;\n    this.isClosing = false;\n    this.isOpening = false;\n    /**\r\n     * @private\r\n     * @type {number | false | undefined}\r\n     */\n\n    this._duration = undefined;\n    /** @private */\n\n    this._useAnimation = false;\n    /** @private */\n\n    this._croppedZoom = false;\n    /** @private */\n\n    this._animateRootOpacity = false;\n    /** @private */\n\n    this._animateBgOpacity = false;\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | HTMLImageElement | null | undefined }\r\n     */\n\n    this._placeholder = undefined;\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | undefined }\r\n     */\n\n    this._opacityElement = undefined;\n    /**\r\n     * @private\r\n     * @type { HTMLDivElement | undefined }\r\n     */\n\n    this._cropContainer1 = undefined;\n    /**\r\n     * @private\r\n     * @type { HTMLElement | null | undefined }\r\n     */\n\n    this._cropContainer2 = undefined;\n    /**\r\n     * @private\r\n     * @type {Bounds | undefined}\r\n     */\n\n    this._thumbBounds = undefined;\n    this._prepareOpen = this._prepareOpen.bind(this); // Override initial zoom and pan position\n\n    pswp.on('firstZoomPan', this._prepareOpen);\n  }\n\n  open() {\n    this._prepareOpen();\n\n    this._start();\n  }\n\n  close() {\n    if (this.isClosed || this.isClosing || this.isOpening) {\n      // if we close during opening animation\n      // for now do nothing,\n      // browsers aren't good at changing the direction of the CSS transition\n      return;\n    }\n\n    const slide = this.pswp.currSlide;\n    this.isOpen = false;\n    this.isOpening = false;\n    this.isClosing = true;\n    this._duration = this.pswp.options.hideAnimationDuration;\n\n    if (slide && slide.currZoomLevel * slide.width >= this.pswp.options.maxWidthToAnimate) {\n      this._duration = 0;\n    }\n\n    this._applyStartProps();\n\n    setTimeout(() => {\n      this._start();\n    }, this._croppedZoom ? 30 : 0);\n  }\n  /** @private */\n\n\n  _prepareOpen() {\n    this.pswp.off('firstZoomPan', this._prepareOpen);\n\n    if (!this.isOpening) {\n      const slide = this.pswp.currSlide;\n      this.isOpening = true;\n      this.isClosing = false;\n      this._duration = this.pswp.options.showAnimationDuration;\n\n      if (slide && slide.zoomLevels.initial * slide.width >= this.pswp.options.maxWidthToAnimate) {\n        this._duration = 0;\n      }\n\n      this._applyStartProps();\n    }\n  }\n  /** @private */\n\n\n  _applyStartProps() {\n    const {\n      pswp\n    } = this;\n    const slide = this.pswp.currSlide;\n    const {\n      options\n    } = pswp;\n\n    if (options.showHideAnimationType === 'fade') {\n      options.showHideOpacity = true;\n      this._thumbBounds = undefined;\n    } else if (options.showHideAnimationType === 'none') {\n      options.showHideOpacity = false;\n      this._duration = 0;\n      this._thumbBounds = undefined;\n    } else if (this.isOpening && pswp._initialThumbBounds) {\n      // Use initial bounds if defined\n      this._thumbBounds = pswp._initialThumbBounds;\n    } else {\n      this._thumbBounds = this.pswp.getThumbBounds();\n    }\n\n    this._placeholder = slide === null || slide === void 0 ? void 0 : slide.getPlaceholderElement();\n    pswp.animations.stopAll(); // Discard animations when duration is less than 50ms\n\n    this._useAnimation = Boolean(this._duration && this._duration > 50);\n    this._animateZoom = Boolean(this._thumbBounds) && (slide === null || slide === void 0 ? void 0 : slide.content.usePlaceholder()) && (!this.isClosing || !pswp.mainScroll.isShifted());\n\n    if (!this._animateZoom) {\n      this._animateRootOpacity = true;\n\n      if (this.isOpening && slide) {\n        slide.zoomAndPanToInitial();\n        slide.applyCurrentZoomPan();\n      }\n    } else {\n      var _options$showHideOpac;\n\n      this._animateRootOpacity = (_options$showHideOpac = options.showHideOpacity) !== null && _options$showHideOpac !== void 0 ? _options$showHideOpac : false;\n    }\n\n    this._animateBgOpacity = !this._animateRootOpacity && this.pswp.options.bgOpacity > MIN_OPACITY;\n    this._opacityElement = this._animateRootOpacity ? pswp.element : pswp.bg;\n\n    if (!this._useAnimation) {\n      this._duration = 0;\n      this._animateZoom = false;\n      this._animateBgOpacity = false;\n      this._animateRootOpacity = true;\n\n      if (this.isOpening) {\n        if (pswp.element) {\n          pswp.element.style.opacity = String(MIN_OPACITY);\n        }\n\n        pswp.applyBgOpacity(1);\n      }\n\n      return;\n    }\n\n    if (this._animateZoom && this._thumbBounds && this._thumbBounds.innerRect) {\n      var _this$pswp$currSlide;\n\n      // Properties are used when animation from cropped thumbnail\n      this._croppedZoom = true;\n      this._cropContainer1 = this.pswp.container;\n      this._cropContainer2 = (_this$pswp$currSlide = this.pswp.currSlide) === null || _this$pswp$currSlide === void 0 ? void 0 : _this$pswp$currSlide.holderElement;\n\n      if (pswp.container) {\n        pswp.container.style.overflow = 'hidden';\n        pswp.container.style.width = pswp.viewportSize.x + 'px';\n      }\n    } else {\n      this._croppedZoom = false;\n    }\n\n    if (this.isOpening) {\n      // Apply styles before opening transition\n      if (this._animateRootOpacity) {\n        if (pswp.element) {\n          pswp.element.style.opacity = String(MIN_OPACITY);\n        }\n\n        pswp.applyBgOpacity(1);\n      } else {\n        if (this._animateBgOpacity && pswp.bg) {\n          pswp.bg.style.opacity = String(MIN_OPACITY);\n        }\n\n        if (pswp.element) {\n          pswp.element.style.opacity = '1';\n        }\n      }\n\n      if (this._animateZoom) {\n        this._setClosedStateZoomPan();\n\n        if (this._placeholder) {\n          // tell browser that we plan to animate the placeholder\n          this._placeholder.style.willChange = 'transform'; // hide placeholder to allow hiding of\n          // elements that overlap it (such as icons over the thumbnail)\n\n          this._placeholder.style.opacity = String(MIN_OPACITY);\n        }\n      }\n    } else if (this.isClosing) {\n      // hide nearby slides to make sure that\n      // they are not painted during the transition\n      if (pswp.mainScroll.itemHolders[0]) {\n        pswp.mainScroll.itemHolders[0].el.style.display = 'none';\n      }\n\n      if (pswp.mainScroll.itemHolders[2]) {\n        pswp.mainScroll.itemHolders[2].el.style.display = 'none';\n      }\n\n      if (this._croppedZoom) {\n        if (pswp.mainScroll.x !== 0) {\n          // shift the main scroller to zero position\n          pswp.mainScroll.resetPosition();\n          pswp.mainScroll.resize();\n        }\n      }\n    }\n  }\n  /** @private */\n\n\n  _start() {\n    if (this.isOpening && this._useAnimation && this._placeholder && this._placeholder.tagName === 'IMG') {\n      // To ensure smooth animation\n      // we wait till the current slide image placeholder is decoded,\n      // but no longer than 250ms,\n      // and no shorter than 50ms\n      // (just using requestanimationframe is not enough in Firefox,\n      // for some reason)\n      new Promise(resolve => {\n        let decoded = false;\n        let isDelaying = true;\n        decodeImage(\n        /** @type {HTMLImageElement} */\n        this._placeholder).finally(() => {\n          decoded = true;\n\n          if (!isDelaying) {\n            resolve(true);\n          }\n        });\n        setTimeout(() => {\n          isDelaying = false;\n\n          if (decoded) {\n            resolve(true);\n          }\n        }, 50);\n        setTimeout(resolve, 250);\n      }).finally(() => this._initiate());\n    } else {\n      this._initiate();\n    }\n  }\n  /** @private */\n\n\n  _initiate() {\n    var _this$pswp$element, _this$pswp$element2;\n\n    (_this$pswp$element = this.pswp.element) === null || _this$pswp$element === void 0 || _this$pswp$element.style.setProperty('--pswp-transition-duration', this._duration + 'ms');\n    this.pswp.dispatch(this.isOpening ? 'openingAnimationStart' : 'closingAnimationStart'); // legacy event\n\n    this.pswp.dispatch(\n    /** @type {'initialZoomIn' | 'initialZoomOut'} */\n    'initialZoom' + (this.isOpening ? 'In' : 'Out'));\n    (_this$pswp$element2 = this.pswp.element) === null || _this$pswp$element2 === void 0 || _this$pswp$element2.classList.toggle('pswp--ui-visible', this.isOpening);\n\n    if (this.isOpening) {\n      if (this._placeholder) {\n        // unhide the placeholder\n        this._placeholder.style.opacity = '1';\n      }\n\n      this._animateToOpenState();\n    } else if (this.isClosing) {\n      this._animateToClosedState();\n    }\n\n    if (!this._useAnimation) {\n      this._onAnimationComplete();\n    }\n  }\n  /** @private */\n\n\n  _onAnimationComplete() {\n    const {\n      pswp\n    } = this;\n    this.isOpen = this.isOpening;\n    this.isClosed = this.isClosing;\n    this.isOpening = false;\n    this.isClosing = false;\n    pswp.dispatch(this.isOpen ? 'openingAnimationEnd' : 'closingAnimationEnd'); // legacy event\n\n    pswp.dispatch(\n    /** @type {'initialZoomInEnd' | 'initialZoomOutEnd'} */\n    'initialZoom' + (this.isOpen ? 'InEnd' : 'OutEnd'));\n\n    if (this.isClosed) {\n      pswp.destroy();\n    } else if (this.isOpen) {\n      var _pswp$currSlide;\n\n      if (this._animateZoom && pswp.container) {\n        pswp.container.style.overflow = 'visible';\n        pswp.container.style.width = '100%';\n      }\n\n      (_pswp$currSlide = pswp.currSlide) === null || _pswp$currSlide === void 0 || _pswp$currSlide.applyCurrentZoomPan();\n    }\n  }\n  /** @private */\n\n\n  _animateToOpenState() {\n    const {\n      pswp\n    } = this;\n\n    if (this._animateZoom) {\n      if (this._croppedZoom && this._cropContainer1 && this._cropContainer2) {\n        this._animateTo(this._cropContainer1, 'transform', 'translate3d(0,0,0)');\n\n        this._animateTo(this._cropContainer2, 'transform', 'none');\n      }\n\n      if (pswp.currSlide) {\n        pswp.currSlide.zoomAndPanToInitial();\n\n        this._animateTo(pswp.currSlide.container, 'transform', pswp.currSlide.getCurrentTransform());\n      }\n    }\n\n    if (this._animateBgOpacity && pswp.bg) {\n      this._animateTo(pswp.bg, 'opacity', String(pswp.options.bgOpacity));\n    }\n\n    if (this._animateRootOpacity && pswp.element) {\n      this._animateTo(pswp.element, 'opacity', '1');\n    }\n  }\n  /** @private */\n\n\n  _animateToClosedState() {\n    const {\n      pswp\n    } = this;\n\n    if (this._animateZoom) {\n      this._setClosedStateZoomPan(true);\n    } // do not animate opacity if it's already at 0\n\n\n    if (this._animateBgOpacity && pswp.bgOpacity > 0.01 && pswp.bg) {\n      this._animateTo(pswp.bg, 'opacity', '0');\n    }\n\n    if (this._animateRootOpacity && pswp.element) {\n      this._animateTo(pswp.element, 'opacity', '0');\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {boolean} [animate]\r\n   */\n\n\n  _setClosedStateZoomPan(animate) {\n    if (!this._thumbBounds) return;\n    const {\n      pswp\n    } = this;\n    const {\n      innerRect\n    } = this._thumbBounds;\n    const {\n      currSlide,\n      viewportSize\n    } = pswp;\n\n    if (this._croppedZoom && innerRect && this._cropContainer1 && this._cropContainer2) {\n      const containerOnePanX = -viewportSize.x + (this._thumbBounds.x - innerRect.x) + innerRect.w;\n      const containerOnePanY = -viewportSize.y + (this._thumbBounds.y - innerRect.y) + innerRect.h;\n      const containerTwoPanX = viewportSize.x - innerRect.w;\n      const containerTwoPanY = viewportSize.y - innerRect.h;\n\n      if (animate) {\n        this._animateTo(this._cropContainer1, 'transform', toTransformString(containerOnePanX, containerOnePanY));\n\n        this._animateTo(this._cropContainer2, 'transform', toTransformString(containerTwoPanX, containerTwoPanY));\n      } else {\n        setTransform(this._cropContainer1, containerOnePanX, containerOnePanY);\n        setTransform(this._cropContainer2, containerTwoPanX, containerTwoPanY);\n      }\n    }\n\n    if (currSlide) {\n      equalizePoints(currSlide.pan, innerRect || this._thumbBounds);\n      currSlide.currZoomLevel = this._thumbBounds.w / currSlide.width;\n\n      if (animate) {\n        this._animateTo(currSlide.container, 'transform', currSlide.getCurrentTransform());\n      } else {\n        currSlide.applyCurrentZoomPan();\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   * @param {HTMLElement} target\r\n   * @param {'transform' | 'opacity'} prop\r\n   * @param {string} propValue\r\n   */\n\n\n  _animateTo(target, prop, propValue) {\n    if (!this._duration) {\n      target.style[prop] = propValue;\n      return;\n    }\n\n    const {\n      animations\n    } = this.pswp;\n    /** @type {AnimationProps} */\n\n    const animProps = {\n      duration: this._duration,\n      easing: this.pswp.options.easing,\n      onComplete: () => {\n        if (!animations.activeAnimations.length) {\n          this._onAnimationComplete();\n        }\n      },\n      target\n    };\n    animProps[prop] = propValue;\n    animations.startTransition(animProps);\n  }\n\n}\n\n/**\r\n * @template T\r\n * @typedef {import('./types.js').Type<T>} Type<T>\r\n */\n\n/** @typedef {import('./slide/slide.js').SlideData} SlideData */\n\n/** @typedef {import('./slide/zoom-level.js').ZoomLevelOption} ZoomLevelOption */\n\n/** @typedef {import('./ui/ui-element.js').UIElementData} UIElementData */\n\n/** @typedef {import('./main-scroll.js').ItemHolder} ItemHolder */\n\n/** @typedef {import('./core/eventable.js').PhotoSwipeEventsMap} PhotoSwipeEventsMap */\n\n/** @typedef {import('./core/eventable.js').PhotoSwipeFiltersMap} PhotoSwipeFiltersMap */\n\n/** @typedef {import('./slide/get-thumb-bounds').Bounds} Bounds */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {import('./core/eventable.js').EventCallback<T>} EventCallback<T>\r\n */\n\n/**\r\n * @template {keyof PhotoSwipeEventsMap} T\r\n * @typedef {import('./core/eventable.js').AugmentedEvent<T>} AugmentedEvent<T>\r\n */\n\n/** @typedef {{ x: number; y: number; id?: string | number }} Point */\n\n/** @typedef {{ top: number; bottom: number; left: number; right: number }} Padding */\n\n/** @typedef {SlideData[]} DataSourceArray */\n\n/** @typedef {{ gallery: HTMLElement; items?: HTMLElement[] }} DataSourceObject */\n\n/** @typedef {DataSourceArray | DataSourceObject} DataSource */\n\n/** @typedef {(point: Point, originalEvent: PointerEvent) => void} ActionFn */\n\n/** @typedef {'close' | 'next' | 'zoom' | 'zoom-or-close' | 'toggle-controls'} ActionType */\n\n/** @typedef {Type<PhotoSwipe> | { default: Type<PhotoSwipe> }} PhotoSwipeModule */\n\n/** @typedef {PhotoSwipeModule | Promise<PhotoSwipeModule> | (() => Promise<PhotoSwipeModule>)} PhotoSwipeModuleOption */\n\n/**\r\n * @typedef {string | NodeListOf<HTMLElement> | HTMLElement[] | HTMLElement} ElementProvider\r\n */\n\n/** @typedef {Partial<PreparedPhotoSwipeOptions>} PhotoSwipeOptions https://photoswipe.com/options/ */\n\n/**\r\n * @typedef {Object} PreparedPhotoSwipeOptions\r\n *\r\n * @prop {DataSource} [dataSource]\r\n * Pass an array of any items via dataSource option. Its length will determine amount of slides\r\n * (which may be modified further from numItems event).\r\n *\r\n * Each item should contain data that you need to generate slide\r\n * (for image slide it would be src (image URL), width (image width), height, srcset, alt).\r\n *\r\n * If these properties are not present in your initial array, you may \"pre-parse\" each item from itemData filter.\r\n *\r\n * @prop {number} bgOpacity\r\n * Background backdrop opacity, always define it via this option and not via CSS rgba color.\r\n *\r\n * @prop {number} spacing\r\n * Spacing between slides. Defined as ratio relative to the viewport width (0.1 = 10% of viewport).\r\n *\r\n * @prop {boolean} allowPanToNext\r\n * Allow swipe navigation to the next slide when the current slide is zoomed. Does not apply to mouse events.\r\n *\r\n * @prop {boolean} loop\r\n * If set to true you'll be able to swipe from the last to the first image.\r\n * Option is always false when there are less than 3 slides.\r\n *\r\n * @prop {boolean} [wheelToZoom]\r\n * By default PhotoSwipe zooms image with ctrl-wheel, if you enable this option - image will zoom just via wheel.\r\n *\r\n * @prop {boolean} pinchToClose\r\n * Pinch touch gesture to close the gallery.\r\n *\r\n * @prop {boolean} closeOnVerticalDrag\r\n * Vertical drag gesture to close the PhotoSwipe.\r\n *\r\n * @prop {Padding} [padding]\r\n * Slide area padding (in pixels).\r\n *\r\n * @prop {(viewportSize: Point, itemData: SlideData, index: number) => Padding} [paddingFn]\r\n * The option is checked frequently, so make sure it's performant. Overrides padding option if defined. For example:\r\n *\r\n * @prop {number | false} hideAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {number | false} showAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {number | false} zoomAnimationDuration\r\n * Transition duration in milliseconds, can be 0.\r\n *\r\n * @prop {string} easing\r\n * String, 'cubic-bezier(.4,0,.22,1)'. CSS easing function for open/close/zoom transitions.\r\n *\r\n * @prop {boolean} escKey\r\n * Esc key to close.\r\n *\r\n * @prop {boolean} arrowKeys\r\n * Left/right arrow keys for navigation.\r\n *\r\n * @prop {boolean} trapFocus\r\n * Trap focus within PhotoSwipe element while it's open.\r\n *\r\n * @prop {boolean} returnFocus\r\n * Restore focus the last active element after PhotoSwipe is closed.\r\n *\r\n * @prop {boolean} clickToCloseNonZoomable\r\n * If image is not zoomable (for example, smaller than viewport) it can be closed by clicking on it.\r\n *\r\n * @prop {ActionType | ActionFn | false} imageClickAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} bgClickAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} tapAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {ActionType | ActionFn | false} doubleTapAction\r\n * Refer to click and tap actions page.\r\n *\r\n * @prop {number} preloaderDelay\r\n * Delay before the loading indicator will be displayed,\r\n * if image is loaded during it - the indicator will not be displayed at all. Can be zero.\r\n *\r\n * @prop {string} indexIndicatorSep\r\n * Used for slide count indicator (\"1 of 10 \").\r\n *\r\n * @prop {(options: PhotoSwipeOptions, pswp: PhotoSwipeBase) => Point} [getViewportSizeFn]\r\n * A function that should return slide viewport width and height, in format {x: 100, y: 100}.\r\n *\r\n * @prop {string} errorMsg\r\n * Message to display when the image wasn't able to load. If you need to display HTML - use contentErrorElement filter.\r\n *\r\n * @prop {[number, number]} preload\r\n * Lazy loading of nearby slides based on direction of movement. Should be an array with two integers,\r\n * first one - number of items to preload before the current image, second one - after the current image.\r\n * Two nearby images are always loaded.\r\n *\r\n * @prop {string} [mainClass]\r\n * Class that will be added to the root element of PhotoSwipe, may contain multiple separated by space.\r\n * Example on Styling page.\r\n *\r\n * @prop {HTMLElement} [appendToEl]\r\n * Element to which PhotoSwipe dialog will be appended when it opens.\r\n *\r\n * @prop {number} maxWidthToAnimate\r\n * Maximum width of image to animate, if initial rendered image width\r\n * is larger than this value - the opening/closing transition will be automatically disabled.\r\n *\r\n * @prop {string} [closeTitle]\r\n * Translating\r\n *\r\n * @prop {string} [zoomTitle]\r\n * Translating\r\n *\r\n * @prop {string} [arrowPrevTitle]\r\n * Translating\r\n *\r\n * @prop {string} [arrowNextTitle]\r\n * Translating\r\n *\r\n * @prop {'zoom' | 'fade' | 'none'} [showHideAnimationType]\r\n * To adjust opening or closing transition type use lightbox option `showHideAnimationType` (`String`).\r\n * It supports three values - `zoom` (default), `fade` (default if there is no thumbnail) and `none`.\r\n *\r\n * Animations are automatically disabled if user `(prefers-reduced-motion: reduce)`.\r\n *\r\n * @prop {number} index\r\n * Defines start slide index.\r\n *\r\n * @prop {(e: MouseEvent) => number} [getClickedIndexFn]\r\n *\r\n * @prop {boolean} [arrowPrev]\r\n * @prop {boolean} [arrowNext]\r\n * @prop {boolean} [zoom]\r\n * @prop {boolean} [close]\r\n * @prop {boolean} [counter]\r\n *\r\n * @prop {string} [arrowPrevSVG]\r\n * @prop {string} [arrowNextSVG]\r\n * @prop {string} [zoomSVG]\r\n * @prop {string} [closeSVG]\r\n * @prop {string} [counterSVG]\r\n *\r\n * @prop {string} [arrowPrevTitle]\r\n * @prop {string} [arrowNextTitle]\r\n * @prop {string} [zoomTitle]\r\n * @prop {string} [closeTitle]\r\n * @prop {string} [counterTitle]\r\n *\r\n * @prop {ZoomLevelOption} [initialZoomLevel]\r\n * @prop {ZoomLevelOption} [secondaryZoomLevel]\r\n * @prop {ZoomLevelOption} [maxZoomLevel]\r\n *\r\n * @prop {boolean} [mouseMovePan]\r\n * @prop {Point | null} [initialPointerPos]\r\n * @prop {boolean} [showHideOpacity]\r\n *\r\n * @prop {PhotoSwipeModuleOption} [pswpModule]\r\n * @prop {() => Promise<any>} [openPromise]\r\n * @prop {boolean} [preloadFirstSlide]\r\n * @prop {ElementProvider} [gallery]\r\n * @prop {string} [gallerySelector]\r\n * @prop {ElementProvider} [children]\r\n * @prop {string} [childSelector]\r\n * @prop {string | false} [thumbSelector]\r\n */\n\n/** @type {PreparedPhotoSwipeOptions} */\n\nconst defaultOptions = {\n  allowPanToNext: true,\n  spacing: 0.1,\n  loop: true,\n  pinchToClose: true,\n  closeOnVerticalDrag: true,\n  hideAnimationDuration: 333,\n  showAnimationDuration: 333,\n  zoomAnimationDuration: 333,\n  escKey: true,\n  arrowKeys: true,\n  trapFocus: true,\n  returnFocus: true,\n  maxWidthToAnimate: 4000,\n  clickToCloseNonZoomable: true,\n  imageClickAction: 'zoom-or-close',\n  bgClickAction: 'close',\n  tapAction: 'toggle-controls',\n  doubleTapAction: 'zoom',\n  indexIndicatorSep: ' / ',\n  preloaderDelay: 2000,\n  bgOpacity: 0.8,\n  index: 0,\n  errorMsg: 'The image cannot be loaded',\n  preload: [1, 2],\n  easing: 'cubic-bezier(.4,0,.22,1)'\n};\n/**\r\n * PhotoSwipe Core\r\n */\n\nclass PhotoSwipe extends PhotoSwipeBase {\n  /**\r\n   * @param {PhotoSwipeOptions} [options]\r\n   */\n  constructor(options) {\n    super();\n    this.options = this._prepareOptions(options || {});\n    /**\r\n     * offset of viewport relative to document\r\n     *\r\n     * @type {Point}\r\n     */\n\n    this.offset = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * @type {Point}\r\n     * @private\r\n     */\n\n    this._prevViewportSize = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * Size of scrollable PhotoSwipe viewport\r\n     *\r\n     * @type {Point}\r\n     */\n\n    this.viewportSize = {\n      x: 0,\n      y: 0\n    };\n    /**\r\n     * background (backdrop) opacity\r\n     */\n\n    this.bgOpacity = 1;\n    this.currIndex = 0;\n    this.potentialIndex = 0;\n    this.isOpen = false;\n    this.isDestroying = false;\n    this.hasMouse = false;\n    /**\r\n     * @private\r\n     * @type {SlideData}\r\n     */\n\n    this._initialItemData = {};\n    /** @type {Bounds | undefined} */\n\n    this._initialThumbBounds = undefined;\n    /** @type {HTMLDivElement | undefined} */\n\n    this.topBar = undefined;\n    /** @type {HTMLDivElement | undefined} */\n\n    this.element = undefined;\n    /** @type {HTMLDivElement | undefined} */\n\n    this.template = undefined;\n    /** @type {HTMLDivElement | undefined} */\n\n    this.container = undefined;\n    /** @type {HTMLElement | undefined} */\n\n    this.scrollWrap = undefined;\n    /** @type {Slide | undefined} */\n\n    this.currSlide = undefined;\n    this.events = new DOMEvents();\n    this.animations = new Animations();\n    this.mainScroll = new MainScroll(this);\n    this.gestures = new Gestures(this);\n    this.opener = new Opener(this);\n    this.keyboard = new Keyboard(this);\n    this.contentLoader = new ContentLoader(this);\n  }\n  /** @returns {boolean} */\n\n\n  init() {\n    if (this.isOpen || this.isDestroying) {\n      return false;\n    }\n\n    this.isOpen = true;\n    this.dispatch('init'); // legacy\n\n    this.dispatch('beforeOpen');\n\n    this._createMainStructure(); // add classes to the root element of PhotoSwipe\n\n\n    let rootClasses = 'pswp--open';\n\n    if (this.gestures.supportsTouch) {\n      rootClasses += ' pswp--touch';\n    }\n\n    if (this.options.mainClass) {\n      rootClasses += ' ' + this.options.mainClass;\n    }\n\n    if (this.element) {\n      this.element.className += ' ' + rootClasses;\n    }\n\n    this.currIndex = this.options.index || 0;\n    this.potentialIndex = this.currIndex;\n    this.dispatch('firstUpdate'); // starting index can be modified here\n    // initialize scroll wheel handler to block the scroll\n\n    this.scrollWheel = new ScrollWheel(this); // sanitize index\n\n    if (Number.isNaN(this.currIndex) || this.currIndex < 0 || this.currIndex >= this.getNumItems()) {\n      this.currIndex = 0;\n    }\n\n    if (!this.gestures.supportsTouch) {\n      // enable mouse features if no touch support detected\n      this.mouseDetected();\n    } // causes forced synchronous layout\n\n\n    this.updateSize();\n    this.offset.y = window.pageYOffset;\n    this._initialItemData = this.getItemData(this.currIndex);\n    this.dispatch('gettingData', {\n      index: this.currIndex,\n      data: this._initialItemData,\n      slide: undefined\n    }); // *Layout* - calculate size and position of elements here\n\n    this._initialThumbBounds = this.getThumbBounds();\n    this.dispatch('initialLayout');\n    this.on('openingAnimationEnd', () => {\n      const {\n        itemHolders\n      } = this.mainScroll; // Add content to the previous and next slide\n\n      if (itemHolders[0]) {\n        itemHolders[0].el.style.display = 'block';\n        this.setContent(itemHolders[0], this.currIndex - 1);\n      }\n\n      if (itemHolders[2]) {\n        itemHolders[2].el.style.display = 'block';\n        this.setContent(itemHolders[2], this.currIndex + 1);\n      }\n\n      this.appendHeavy();\n      this.contentLoader.updateLazy();\n      this.events.add(window, 'resize', this._handlePageResize.bind(this));\n      this.events.add(window, 'scroll', this._updatePageScrollOffset.bind(this));\n      this.dispatch('bindEvents');\n    }); // set content for center slide (first time)\n\n    if (this.mainScroll.itemHolders[1]) {\n      this.setContent(this.mainScroll.itemHolders[1], this.currIndex);\n    }\n\n    this.dispatch('change');\n    this.opener.open();\n    this.dispatch('afterInit');\n    return true;\n  }\n  /**\r\n   * Get looped slide index\r\n   * (for example, -1 will return the last slide)\r\n   *\r\n   * @param {number} index\r\n   * @returns {number}\r\n   */\n\n\n  getLoopedIndex(index) {\n    const numSlides = this.getNumItems();\n\n    if (this.options.loop) {\n      if (index > numSlides - 1) {\n        index -= numSlides;\n      }\n\n      if (index < 0) {\n        index += numSlides;\n      }\n    }\n\n    return clamp(index, 0, numSlides - 1);\n  }\n\n  appendHeavy() {\n    this.mainScroll.itemHolders.forEach(itemHolder => {\n      var _itemHolder$slide;\n\n      (_itemHolder$slide = itemHolder.slide) === null || _itemHolder$slide === void 0 || _itemHolder$slide.appendHeavy();\n    });\n  }\n  /**\r\n   * Change the slide\r\n   * @param {number} index New index\r\n   */\n\n\n  goTo(index) {\n    this.mainScroll.moveIndexBy(this.getLoopedIndex(index) - this.potentialIndex);\n  }\n  /**\r\n   * Go to the next slide.\r\n   */\n\n\n  next() {\n    this.goTo(this.potentialIndex + 1);\n  }\n  /**\r\n   * Go to the previous slide.\r\n   */\n\n\n  prev() {\n    this.goTo(this.potentialIndex - 1);\n  }\n  /**\r\n   * @see slide/slide.js zoomTo\r\n   *\r\n   * @param {Parameters<Slide['zoomTo']>} args\r\n   */\n\n\n  zoomTo(...args) {\n    var _this$currSlide;\n\n    (_this$currSlide = this.currSlide) === null || _this$currSlide === void 0 || _this$currSlide.zoomTo(...args);\n  }\n  /**\r\n   * @see slide/slide.js toggleZoom\r\n   */\n\n\n  toggleZoom() {\n    var _this$currSlide2;\n\n    (_this$currSlide2 = this.currSlide) === null || _this$currSlide2 === void 0 || _this$currSlide2.toggleZoom();\n  }\n  /**\r\n   * Close the gallery.\r\n   * After closing transition ends - destroy it\r\n   */\n\n\n  close() {\n    if (!this.opener.isOpen || this.isDestroying) {\n      return;\n    }\n\n    this.isDestroying = true;\n    this.dispatch('close');\n    this.events.removeAll();\n    this.opener.close();\n  }\n  /**\r\n   * Destroys the gallery:\r\n   * - instantly closes the gallery\r\n   * - unbinds events,\r\n   * - cleans intervals and timeouts\r\n   * - removes elements from DOM\r\n   */\n\n\n  destroy() {\n    var _this$element;\n\n    if (!this.isDestroying) {\n      this.options.showHideAnimationType = 'none';\n      this.close();\n      return;\n    }\n\n    this.dispatch('destroy');\n    this._listeners = {};\n\n    if (this.scrollWrap) {\n      this.scrollWrap.ontouchmove = null;\n      this.scrollWrap.ontouchend = null;\n    }\n\n    (_this$element = this.element) === null || _this$element === void 0 || _this$element.remove();\n    this.mainScroll.itemHolders.forEach(itemHolder => {\n      var _itemHolder$slide2;\n\n      (_itemHolder$slide2 = itemHolder.slide) === null || _itemHolder$slide2 === void 0 || _itemHolder$slide2.destroy();\n    });\n    this.contentLoader.destroy();\n    this.events.removeAll();\n  }\n  /**\r\n   * Refresh/reload content of a slide by its index\r\n   *\r\n   * @param {number} slideIndex\r\n   */\n\n\n  refreshSlideContent(slideIndex) {\n    this.contentLoader.removeByIndex(slideIndex);\n    this.mainScroll.itemHolders.forEach((itemHolder, i) => {\n      var _this$currSlide$index, _this$currSlide3;\n\n      let potentialHolderIndex = ((_this$currSlide$index = (_this$currSlide3 = this.currSlide) === null || _this$currSlide3 === void 0 ? void 0 : _this$currSlide3.index) !== null && _this$currSlide$index !== void 0 ? _this$currSlide$index : 0) - 1 + i;\n\n      if (this.canLoop()) {\n        potentialHolderIndex = this.getLoopedIndex(potentialHolderIndex);\n      }\n\n      if (potentialHolderIndex === slideIndex) {\n        // set the new slide content\n        this.setContent(itemHolder, slideIndex, true); // activate the new slide if it's current\n\n        if (i === 1) {\n          var _itemHolder$slide3;\n\n          this.currSlide = itemHolder.slide;\n          (_itemHolder$slide3 = itemHolder.slide) === null || _itemHolder$slide3 === void 0 || _itemHolder$slide3.setIsActive(true);\n        }\n      }\n    });\n    this.dispatch('change');\n  }\n  /**\r\n   * Set slide content\r\n   *\r\n   * @param {ItemHolder} holder mainScroll.itemHolders array item\r\n   * @param {number} index Slide index\r\n   * @param {boolean} [force] If content should be set even if index wasn't changed\r\n   */\n\n\n  setContent(holder, index, force) {\n    if (this.canLoop()) {\n      index = this.getLoopedIndex(index);\n    }\n\n    if (holder.slide) {\n      if (holder.slide.index === index && !force) {\n        // exit if holder already contains this slide\n        // this could be common when just three slides are used\n        return;\n      } // destroy previous slide\n\n\n      holder.slide.destroy();\n      holder.slide = undefined;\n    } // exit if no loop and index is out of bounds\n\n\n    if (!this.canLoop() && (index < 0 || index >= this.getNumItems())) {\n      return;\n    }\n\n    const itemData = this.getItemData(index);\n    holder.slide = new Slide(itemData, index, this); // set current slide\n\n    if (index === this.currIndex) {\n      this.currSlide = holder.slide;\n    }\n\n    holder.slide.append(holder.el);\n  }\n  /** @returns {Point} */\n\n\n  getViewportCenterPoint() {\n    return {\n      x: this.viewportSize.x / 2,\n      y: this.viewportSize.y / 2\n    };\n  }\n  /**\r\n   * Update size of all elements.\r\n   * Executed on init and on page resize.\r\n   *\r\n   * @param {boolean} [force] Update size even if size of viewport was not changed.\r\n   */\n\n\n  updateSize(force) {\n    // let item;\n    // let itemIndex;\n    if (this.isDestroying) {\n      // exit if PhotoSwipe is closed or closing\n      // (to avoid errors, as resize event might be delayed)\n      return;\n    } //const newWidth = this.scrollWrap.clientWidth;\n    //const newHeight = this.scrollWrap.clientHeight;\n\n\n    const newViewportSize = getViewportSize(this.options, this);\n\n    if (!force && pointsEqual(newViewportSize, this._prevViewportSize)) {\n      // Exit if dimensions were not changed\n      return;\n    } //this._prevViewportSize.x = newWidth;\n    //this._prevViewportSize.y = newHeight;\n\n\n    equalizePoints(this._prevViewportSize, newViewportSize);\n    this.dispatch('beforeResize');\n    equalizePoints(this.viewportSize, this._prevViewportSize);\n\n    this._updatePageScrollOffset();\n\n    this.dispatch('viewportSize'); // Resize slides only after opener animation is finished\n    // and don't re-calculate size on inital size update\n\n    this.mainScroll.resize(this.opener.isOpen);\n\n    if (!this.hasMouse && window.matchMedia('(any-hover: hover)').matches) {\n      this.mouseDetected();\n    }\n\n    this.dispatch('resize');\n  }\n  /**\r\n   * @param {number} opacity\r\n   */\n\n\n  applyBgOpacity(opacity) {\n    this.bgOpacity = Math.max(opacity, 0);\n\n    if (this.bg) {\n      this.bg.style.opacity = String(this.bgOpacity * this.options.bgOpacity);\n    }\n  }\n  /**\r\n   * Whether mouse is detected\r\n   */\n\n\n  mouseDetected() {\n    if (!this.hasMouse) {\n      var _this$element2;\n\n      this.hasMouse = true;\n      (_this$element2 = this.element) === null || _this$element2 === void 0 || _this$element2.classList.add('pswp--has_mouse');\n    }\n  }\n  /**\r\n   * Page resize event handler\r\n   *\r\n   * @private\r\n   */\n\n\n  _handlePageResize() {\n    this.updateSize(); // In iOS webview, if element size depends on document size,\n    // it'll be measured incorrectly in resize event\n    //\n    // https://bugs.webkit.org/show_bug.cgi?id=170595\n    // https://hackernoon.com/onresize-event-broken-in-mobile-safari-d8469027bf4d\n\n    if (/iPhone|iPad|iPod/i.test(window.navigator.userAgent)) {\n      setTimeout(() => {\n        this.updateSize();\n      }, 500);\n    }\n  }\n  /**\r\n   * Page scroll offset is used\r\n   * to get correct coordinates\r\n   * relative to PhotoSwipe viewport.\r\n   *\r\n   * @private\r\n   */\n\n\n  _updatePageScrollOffset() {\n    this.setScrollOffset(0, window.pageYOffset);\n  }\n  /**\r\n   * @param {number} x\r\n   * @param {number} y\r\n   */\n\n\n  setScrollOffset(x, y) {\n    this.offset.x = x;\n    this.offset.y = y;\n    this.dispatch('updateScrollOffset');\n  }\n  /**\r\n   * Create main HTML structure of PhotoSwipe,\r\n   * and add it to DOM\r\n   *\r\n   * @private\r\n   */\n\n\n  _createMainStructure() {\n    // root DOM element of PhotoSwipe (.pswp)\n    this.element = createElement('pswp', 'div');\n    this.element.setAttribute('tabindex', '-1');\n    this.element.setAttribute('role', 'dialog'); // template is legacy prop\n\n    this.template = this.element; // Background is added as a separate element,\n    // as animating opacity is faster than animating rgba()\n\n    this.bg = createElement('pswp__bg', 'div', this.element);\n    this.scrollWrap = createElement('pswp__scroll-wrap', 'section', this.element);\n    this.container = createElement('pswp__container', 'div', this.scrollWrap); // aria pattern: carousel\n\n    this.scrollWrap.setAttribute('aria-roledescription', 'carousel');\n    this.container.setAttribute('aria-live', 'off');\n    this.container.setAttribute('id', 'pswp__items');\n    this.mainScroll.appendHolders();\n    this.ui = new UI(this);\n    this.ui.init(); // append to DOM\n\n    (this.options.appendToEl || document.body).appendChild(this.element);\n  }\n  /**\r\n   * Get position and dimensions of small thumbnail\r\n   *   {x:,y:,w:}\r\n   *\r\n   * Height is optional (calculated based on the large image)\r\n   *\r\n   * @returns {Bounds | undefined}\r\n   */\n\n\n  getThumbBounds() {\n    return getThumbBounds(this.currIndex, this.currSlide ? this.currSlide.data : this._initialItemData, this);\n  }\n  /**\r\n   * If the PhotoSwipe can have continuous loop\r\n   * @returns Boolean\r\n   */\n\n\n  canLoop() {\n    return this.options.loop && this.getNumItems() > 2;\n  }\n  /**\r\n   * @private\r\n   * @param {PhotoSwipeOptions} options\r\n   * @returns {PreparedPhotoSwipeOptions}\r\n   */\n\n\n  _prepareOptions(options) {\n    if (window.matchMedia('(prefers-reduced-motion), (update: slow)').matches) {\n      options.showHideAnimationType = 'none';\n      options.zoomAnimationDuration = 0;\n    }\n    /** @type {PreparedPhotoSwipeOptions} */\n\n\n    return { ...defaultOptions,\n      ...options\n    };\n  }\n\n}\n\n\n//# sourceMappingURL=photoswipe.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9waG90b3N3aXBlQDUuNC40L25vZGVfbW9kdWxlcy9waG90b3N3aXBlL2Rpc3QvcGhvdG9zd2lwZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrQ0FBa0M7O0FBRWhEO0FBQ0EsY0FBYyw2QkFBNkI7QUFDM0MsV0FBVyxRQUFRO0FBQ25CLFdBQVcsR0FBRztBQUNkLFdBQVcsTUFBTTtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjs7QUFFQTtBQUNBLGlDQUFpQyxFQUFFLEtBQUssT0FBTzs7QUFFL0M7QUFDQSw2QkFBNkIsTUFBTSxHQUFHLE1BQU07QUFDNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBLHNEQUFzRDs7QUFFdEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7O0FBRUE7QUFDQTtBQUNB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OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG1CQUFtQjtBQUNoQyxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDJCQUEyQjs7O0FBRzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRWlDO0FBQ2pDIiwic291cmNlcyI6WyIvcHJvamVjdHMvcmczNjAvbmV3LWVjb21tZXJjZS9mcm9udGVuZC9ub2RlX21vZHVsZXMvLnBucG0vcGhvdG9zd2lwZUA1LjQuNC9ub2RlX21vZHVsZXMvcGhvdG9zd2lwZS9kaXN0L3Bob3Rvc3dpcGUuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICAqIFBob3RvU3dpcGUgNS40LjQgLSBodHRwczovL3Bob3Rvc3dpcGUuY29tXG4gICogKGMpIDIwMjQgRG15dHJvIFNlbWVub3ZcbiAgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUG9pbnR9IFBvaW50ICovXG5cbi8qKlxyXG4gKiBAdGVtcGxhdGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gVFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXHJcbiAqIEBwYXJhbSB7VH0gdGFnTmFtZVxyXG4gKiBAcGFyYW0ge05vZGV9IFthcHBlbmRUb0VsXVxyXG4gKiBAcmV0dXJucyB7SFRNTEVsZW1lbnRUYWdOYW1lTWFwW1RdfVxyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQoY2xhc3NOYW1lLCB0YWdOYW1lLCBhcHBlbmRUb0VsKSB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcblxuICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICB9XG5cbiAgaWYgKGFwcGVuZFRvRWwpIHtcbiAgICBhcHBlbmRUb0VsLmFwcGVuZENoaWxkKGVsKTtcbiAgfVxuXG4gIHJldHVybiBlbDtcbn1cbi8qKlxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMVxyXG4gKiBAcGFyYW0ge1BvaW50fSBwMlxyXG4gKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAqL1xuXG5mdW5jdGlvbiBlcXVhbGl6ZVBvaW50cyhwMSwgcDIpIHtcbiAgcDEueCA9IHAyLng7XG4gIHAxLnkgPSBwMi55O1xuXG4gIGlmIChwMi5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcDEuaWQgPSBwMi5pZDtcbiAgfVxuXG4gIHJldHVybiBwMTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0ge1BvaW50fSBwXHJcbiAqL1xuXG5mdW5jdGlvbiByb3VuZFBvaW50KHApIHtcbiAgcC54ID0gTWF0aC5yb3VuZChwLngpO1xuICBwLnkgPSBNYXRoLnJvdW5kKHAueSk7XG59XG4vKipcclxuICogUmV0dXJucyBkaXN0YW5jZSBiZXR3ZWVuIHR3byBwb2ludHMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXREaXN0YW5jZUJldHdlZW4ocDEsIHAyKSB7XG4gIGNvbnN0IHggPSBNYXRoLmFicyhwMS54IC0gcDIueCk7XG4gIGNvbnN0IHkgPSBNYXRoLmFicyhwMS55IC0gcDIueSk7XG4gIHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG59XG4vKipcclxuICogV2hldGhlciBYIGFuZCBZIHBvc2l0aW9ucyBvZiBwb2ludHMgYXJlIGVxdWFsXHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAxXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHAyXHJcbiAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gKi9cblxuZnVuY3Rpb24gcG9pbnRzRXF1YWwocDEsIHAyKSB7XG4gIHJldHVybiBwMS54ID09PSBwMi54ICYmIHAxLnkgPT09IHAyLnk7XG59XG4vKipcclxuICogVGhlIGZsb2F0IHJlc3VsdCBiZXR3ZWVuIHRoZSBtaW4gYW5kIG1heCB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWxcclxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxyXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xuXG5mdW5jdGlvbiBjbGFtcCh2YWwsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG59XG4vKipcclxuICogR2V0IHRyYW5zZm9ybSBzdHJpbmdcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IFt5XVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlXVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cblxuZnVuY3Rpb24gdG9UcmFuc2Zvcm1TdHJpbmcoeCwgeSwgc2NhbGUpIHtcbiAgbGV0IHByb3BWYWx1ZSA9IGB0cmFuc2xhdGUzZCgke3h9cHgsJHt5IHx8IDB9cHgsMClgO1xuXG4gIGlmIChzY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcHJvcFZhbHVlICs9IGAgc2NhbGUzZCgke3NjYWxlfSwke3NjYWxlfSwxKWA7XG4gIH1cblxuICByZXR1cm4gcHJvcFZhbHVlO1xufVxuLyoqXHJcbiAqIEFwcGx5IHRyYW5zZm9ybTp0cmFuc2xhdGUoeCwgeSkgc2NhbGUoc2NhbGUpIHRvIGVsZW1lbnRcclxuICpcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHBhcmFtIHtudW1iZXJ9IHhcclxuICogQHBhcmFtIHtudW1iZXJ9IFt5XVxyXG4gKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlXVxyXG4gKi9cblxuZnVuY3Rpb24gc2V0VHJhbnNmb3JtKGVsLCB4LCB5LCBzY2FsZSkge1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSB0b1RyYW5zZm9ybVN0cmluZyh4LCB5LCBzY2FsZSk7XG59XG5jb25zdCBkZWZhdWx0Q1NTRWFzaW5nID0gJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSc7XG4vKipcclxuICogQXBwbHkgQ1NTIHRyYW5zaXRpb24gdG8gZWxlbWVudFxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BdIENTUyBwcm9wZXJ0eSB0byBhbmltYXRlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbZHVyYXRpb25dIGluIG1zXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZWFzZV0gQ1NTIGVhc2luZyBmdW5jdGlvblxyXG4gKi9cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvblN0eWxlKGVsLCBwcm9wLCBkdXJhdGlvbiwgZWFzZSkge1xuICAvLyBpbk91dDogJ2N1YmljLWJlemllciguNCwgMCwgLjIyLCAxKScsIC8vIGZvciBcInRvZ2dsZSBzdGF0ZVwiIHRyYW5zaXRpb25zXG4gIC8vIG91dDogJ2N1YmljLWJlemllcigwLCAwLCAuMjIsIDEpJywgLy8gZm9yIFwic2hvd1wiIHRyYW5zaXRpb25zXG4gIC8vIGluOiAnY3ViaWMtYmV6aWVyKC40LCAwLCAxLCAxKScvLyBmb3IgXCJoaWRlXCIgdHJhbnNpdGlvbnNcbiAgZWwuc3R5bGUudHJhbnNpdGlvbiA9IHByb3AgPyBgJHtwcm9wfSAke2R1cmF0aW9ufW1zICR7ZWFzZSB8fCBkZWZhdWx0Q1NTRWFzaW5nfWAgOiAnbm9uZSc7XG59XG4vKipcclxuICogQXBwbHkgd2lkdGggYW5kIGhlaWdodCBDU1MgcHJvcGVydGllcyB0byBlbGVtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSB3XHJcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBoXHJcbiAqL1xuXG5mdW5jdGlvbiBzZXRXaWR0aEhlaWdodChlbCwgdywgaCkge1xuICBlbC5zdHlsZS53aWR0aCA9IHR5cGVvZiB3ID09PSAnbnVtYmVyJyA/IGAke3d9cHhgIDogdztcbiAgZWwuc3R5bGUuaGVpZ2h0ID0gdHlwZW9mIGggPT09ICdudW1iZXInID8gYCR7aH1weGAgOiBoO1xufVxuLyoqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqL1xuXG5mdW5jdGlvbiByZW1vdmVUcmFuc2l0aW9uU3R5bGUoZWwpIHtcbiAgc2V0VHJhbnNpdGlvblN0eWxlKGVsKTtcbn1cbi8qKlxyXG4gKiBAcGFyYW0ge0hUTUxJbWFnZUVsZW1lbnR9IGltZ1xyXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50IHwgdm9pZD59XHJcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVJbWFnZShpbWcpIHtcbiAgaWYgKCdkZWNvZGUnIGluIGltZykge1xuICAgIHJldHVybiBpbWcuZGVjb2RlKCkuY2F0Y2goKCkgPT4ge30pO1xuICB9XG5cbiAgaWYgKGltZy5jb21wbGV0ZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoaW1nKTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcblxuICAgIGltZy5vbmVycm9yID0gcmVqZWN0O1xuICB9KTtcbn1cbi8qKiBAdHlwZWRlZiB7TE9BRF9TVEFURVtrZXlvZiBMT0FEX1NUQVRFXX0gTG9hZFN0YXRlICovXG5cbi8qKiBAdHlwZSB7eyBJRExFOiAnaWRsZSc7IExPQURJTkc6ICdsb2FkaW5nJzsgTE9BREVEOiAnbG9hZGVkJzsgRVJST1I6ICdlcnJvcicgfX0gKi9cblxuY29uc3QgTE9BRF9TVEFURSA9IHtcbiAgSURMRTogJ2lkbGUnLFxuICBMT0FESU5HOiAnbG9hZGluZycsXG4gIExPQURFRDogJ2xvYWRlZCcsXG4gIEVSUk9SOiAnZXJyb3InXG59O1xuLyoqXHJcbiAqIENoZWNrIGlmIGNsaWNrIG9yIGtleWRvd24gZXZlbnQgd2FzIGRpc3BhdGNoZWRcclxuICogd2l0aCBhIHNwZWNpYWwga2V5IG9yIHZpYSBtb3VzZSB3aGVlbC5cclxuICpcclxuICogQHBhcmFtIHtNb3VzZUV2ZW50IHwgS2V5Ym9hcmRFdmVudH0gZVxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5cbmZ1bmN0aW9uIHNwZWNpYWxLZXlVc2VkKGUpIHtcbiAgcmV0dXJuICdidXR0b24nIGluIGUgJiYgZS5idXR0b24gPT09IDEgfHwgZS5jdHJsS2V5IHx8IGUubWV0YUtleSB8fCBlLmFsdEtleSB8fCBlLnNoaWZ0S2V5O1xufVxuLyoqXHJcbiAqIFBhcnNlIGBnYWxsZXJ5YCBvciBgY2hpbGRyZW5gIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuRWxlbWVudFByb3ZpZGVyfSBbb3B0aW9uXVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gW2xlZ2FjeVNlbGVjdG9yXVxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50IHwgRG9jdW1lbnR9IFtwYXJlbnRdXHJcbiAqIEByZXR1cm5zIEhUTUxFbGVtZW50W11cclxuICovXG5cbmZ1bmN0aW9uIGdldEVsZW1lbnRzRnJvbU9wdGlvbihvcHRpb24sIGxlZ2FjeVNlbGVjdG9yLCBwYXJlbnQgPSBkb2N1bWVudCkge1xuICAvKiogQHR5cGUge0hUTUxFbGVtZW50W119ICovXG4gIGxldCBlbGVtZW50cyA9IFtdO1xuXG4gIGlmIChvcHRpb24gaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgZWxlbWVudHMgPSBbb3B0aW9uXTtcbiAgfSBlbHNlIGlmIChvcHRpb24gaW5zdGFuY2VvZiBOb2RlTGlzdCB8fCBBcnJheS5pc0FycmF5KG9wdGlvbikpIHtcbiAgICBlbGVtZW50cyA9IEFycmF5LmZyb20ob3B0aW9uKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnID8gb3B0aW9uIDogbGVnYWN5U2VsZWN0b3I7XG5cbiAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgIGVsZW1lbnRzID0gQXJyYXkuZnJvbShwYXJlbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50cztcbn1cbi8qKlxyXG4gKiBDaGVjayBpZiBicm93c2VyIGlzIFNhZmFyaVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICovXG5cbmZ1bmN0aW9uIGlzU2FmYXJpKCkge1xuICByZXR1cm4gISEobmF2aWdhdG9yLnZlbmRvciAmJiBuYXZpZ2F0b3IudmVuZG9yLm1hdGNoKC9hcHBsZS9pKSk7XG59XG5cbi8vIERldGVjdCBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyIHN1cHBvcnRcbmxldCBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbi8qIGVzbGludC1kaXNhYmxlICovXG5cbnRyeSB7XG4gIC8qIEB0cy1pZ25vcmUgKi9cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgIGdldDogKCkgPT4ge1xuICAgICAgc3VwcG9ydHNQYXNzaXZlID0gdHJ1ZTtcbiAgICB9XG4gIH0pKTtcbn0gY2F0Y2ggKGUpIHt9XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQb29sSXRlbVxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnQgfCBXaW5kb3cgfCBEb2N1bWVudCB8IHVuZGVmaW5lZCB8IG51bGx9IHRhcmdldFxyXG4gKiBAcHJvcCB7c3RyaW5nfSB0eXBlXHJcbiAqIEBwcm9wIHtFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0fSBsaXN0ZW5lclxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW3Bhc3NpdmVdXHJcbiAqL1xuXG5cbmNsYXNzIERPTUV2ZW50cyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1Bvb2xJdGVtW119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG4gICAgdGhpcy5fcG9vbCA9IFtdO1xuICB9XG4gIC8qKlxyXG4gICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWyd0YXJnZXQnXX0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsndHlwZSddfSB0eXBlIENhbiBiZSBtdWx0aXBsZSwgc2VwYXJhdGVkIGJ5IHNwYWNlLlxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ2xpc3RlbmVyJ119IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsncGFzc2l2ZSddfSBbcGFzc2l2ZV1cclxuICAgKi9cblxuXG4gIGFkZCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlKSB7XG4gICAgdGhpcy5fdG9nZ2xlTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcGFzc2l2ZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3RhcmdldCddfSB0YXJnZXRcclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWyd0eXBlJ119IHR5cGVcclxuICAgKiBAcGFyYW0ge1Bvb2xJdGVtWydsaXN0ZW5lciddfSBsaXN0ZW5lclxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3Bhc3NpdmUnXX0gW3Bhc3NpdmVdXHJcbiAgICovXG5cblxuICByZW1vdmUodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcGFzc2l2ZSkge1xuICAgIHRoaXMuX3RvZ2dsZUxpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHBhc3NpdmUsIHRydWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYWxsIGJvdW5kIGV2ZW50c1xyXG4gICAqL1xuXG5cbiAgcmVtb3ZlQWxsKCkge1xuICAgIHRoaXMuX3Bvb2wuZm9yRWFjaChwb29sSXRlbSA9PiB7XG4gICAgICB0aGlzLl90b2dnbGVMaXN0ZW5lcihwb29sSXRlbS50YXJnZXQsIHBvb2xJdGVtLnR5cGUsIHBvb2xJdGVtLmxpc3RlbmVyLCBwb29sSXRlbS5wYXNzaXZlLCB0cnVlLCB0cnVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX3Bvb2wgPSBbXTtcbiAgfVxuICAvKipcclxuICAgKiBBZGRzIG9yIHJlbW92ZXMgZXZlbnRcclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsndGFyZ2V0J119IHRhcmdldFxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ3R5cGUnXX0gdHlwZVxyXG4gICAqIEBwYXJhbSB7UG9vbEl0ZW1bJ2xpc3RlbmVyJ119IGxpc3RlbmVyXHJcbiAgICogQHBhcmFtIHtQb29sSXRlbVsncGFzc2l2ZSddfSBbcGFzc2l2ZV1cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt1bmJpbmRdIFdoZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBhZGRlZCBvciByZW1vdmVkXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFBvb2xdIFdoZXRoZXIgZXZlbnRzIHBvb2wgc2hvdWxkIGJlIHNraXBwZWRcclxuICAgKi9cblxuXG4gIF90b2dnbGVMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwYXNzaXZlLCB1bmJpbmQsIHNraXBQb29sKSB7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2ROYW1lID0gdW5iaW5kID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2FkZEV2ZW50TGlzdGVuZXInO1xuICAgIGNvbnN0IHR5cGVzID0gdHlwZS5zcGxpdCgnICcpO1xuICAgIHR5cGVzLmZvckVhY2goZVR5cGUgPT4ge1xuICAgICAgaWYgKGVUeXBlKSB7XG4gICAgICAgIC8vIEV2ZW50cyBwb29sIGlzIHVzZWQgdG8gZWFzaWx5IHVuYmluZCBhbGwgZXZlbnRzIHdoZW4gUGhvdG9Td2lwZSBpcyBjbG9zZWQsXG4gICAgICAgIC8vIHNvIGRldmVsb3BlciBkb2Vzbid0IG5lZWQgdG8gZG8gdGhpcyBtYW51YWxseVxuICAgICAgICBpZiAoIXNraXBQb29sKSB7XG4gICAgICAgICAgaWYgKHVuYmluZCkge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIGV2ZW50cyBwb29sXG4gICAgICAgICAgICB0aGlzLl9wb29sID0gdGhpcy5fcG9vbC5maWx0ZXIocG9vbEl0ZW0gPT4ge1xuICAgICAgICAgICAgICByZXR1cm4gcG9vbEl0ZW0udHlwZSAhPT0gZVR5cGUgfHwgcG9vbEl0ZW0ubGlzdGVuZXIgIT09IGxpc3RlbmVyIHx8IHBvb2xJdGVtLnRhcmdldCAhPT0gdGFyZ2V0O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgZXZlbnRzIHBvb2xcbiAgICAgICAgICAgIHRoaXMuX3Bvb2wucHVzaCh7XG4gICAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgICAgdHlwZTogZVR5cGUsXG4gICAgICAgICAgICAgIGxpc3RlbmVyLFxuICAgICAgICAgICAgICBwYXNzaXZlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gbW9zdCBQaG90b1N3aXBlIGV2ZW50cyBjYWxsIHByZXZlbnREZWZhdWx0LFxuICAgICAgICAvLyBhbmQgd2UgZG8gbm90IG5lZWQgYnJvd3NlciB0byBzY3JvbGwgdGhlIHBhZ2VcblxuXG4gICAgICAgIGNvbnN0IGV2ZW50T3B0aW9ucyA9IHN1cHBvcnRzUGFzc2l2ZSA/IHtcbiAgICAgICAgICBwYXNzaXZlOiBwYXNzaXZlIHx8IGZhbHNlXG4gICAgICAgIH0gOiBmYWxzZTtcbiAgICAgICAgdGFyZ2V0W21ldGhvZE5hbWVdKGVUeXBlLCBsaXN0ZW5lciwgZXZlbnRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUGhvdG9Td2lwZU9wdGlvbnN9IFBob3RvU3dpcGVPcHRpb25zICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL2Jhc2UuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlQmFzZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xuXG4vKipcclxuICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVCYXNlfSBwc3dwXHJcbiAqIEByZXR1cm5zIHtQb2ludH1cclxuICovXG5mdW5jdGlvbiBnZXRWaWV3cG9ydFNpemUob3B0aW9ucywgcHN3cCkge1xuICBpZiAob3B0aW9ucy5nZXRWaWV3cG9ydFNpemVGbikge1xuICAgIGNvbnN0IG5ld1ZpZXdwb3J0U2l6ZSA9IG9wdGlvbnMuZ2V0Vmlld3BvcnRTaXplRm4ob3B0aW9ucywgcHN3cCk7XG5cbiAgICBpZiAobmV3Vmlld3BvcnRTaXplKSB7XG4gICAgICByZXR1cm4gbmV3Vmlld3BvcnRTaXplO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgeDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoLFxuICAgIC8vIFRPRE86IGhlaWdodCBvbiBtb2JpbGUgaXMgdmVyeSBpbmNvc2lzdGVudCBkdWUgdG8gdG9vbGJhclxuICAgIC8vIGZpbmQgYSB3YXkgdG8gaW1wcm92ZSB0aGlzXG4gICAgLy9cbiAgICAvLyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0IC0gZG9lc24ndCBzZWVtIHRvIHdvcmsgd2VsbFxuICAgIHk6IHdpbmRvdy5pbm5lckhlaWdodFxuICB9O1xufVxuLyoqXHJcbiAqIFBhcnNlcyBwYWRkaW5nIG9wdGlvbi5cclxuICogU3VwcG9ydGVkIGZvcm1hdHM6XHJcbiAqXHJcbiAqIC8vIE9iamVjdFxyXG4gKiBwYWRkaW5nOiB7XHJcbiAqICB0b3A6IDAsXHJcbiAqICBib3R0b206IDAsXHJcbiAqICBsZWZ0OiAwLFxyXG4gKiAgcmlnaHQ6IDBcclxuICogfVxyXG4gKlxyXG4gKiAvLyBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgb2JqZWN0XHJcbiAqIHBhZGRpbmdGbjogKHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSA9PiB7XHJcbiAqICByZXR1cm4ge1xyXG4gKiAgICB0b3A6IDAsXHJcbiAqICAgIGJvdHRvbTogMCxcclxuICogICAgbGVmdDogMCxcclxuICogICAgcmlnaHQ6IDBcclxuICogIH07XHJcbiAqIH1cclxuICpcclxuICogLy8gTGVnYWN5IHZhcmlhbnRcclxuICogcGFkZGluZ0xlZnQ6IDAsXHJcbiAqIHBhZGRpbmdSaWdodDogMCxcclxuICogcGFkZGluZ1RvcDogMCxcclxuICogcGFkZGluZ0JvdHRvbTogMCxcclxuICpcclxuICogQHBhcmFtIHsnbGVmdCcgfCAndG9wJyB8ICdib3R0b20nIHwgJ3JpZ2h0J30gcHJvcFxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBvcHRpb25zIFBob3RvU3dpcGUgb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1BvaW50fSB2aWV3cG9ydFNpemUgUGhvdG9Td2lwZSB2aWV3cG9ydCBzaXplLCBmb3IgZXhhbXBsZTogeyB4OjgwMCwgeTo2MDAgfVxyXG4gKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgRGF0YSBhYm91dCB0aGUgc2xpZGVcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFNsaWRlIGluZGV4XHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVBhZGRpbmdPcHRpb24ocHJvcCwgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpIHtcbiAgbGV0IHBhZGRpbmdWYWx1ZSA9IDA7XG5cbiAgaWYgKG9wdGlvbnMucGFkZGluZ0ZuKSB7XG4gICAgcGFkZGluZ1ZhbHVlID0gb3B0aW9ucy5wYWRkaW5nRm4odmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpW3Byb3BdO1xuICB9IGVsc2UgaWYgKG9wdGlvbnMucGFkZGluZykge1xuICAgIHBhZGRpbmdWYWx1ZSA9IG9wdGlvbnMucGFkZGluZ1twcm9wXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBsZWdhY3lQcm9wTmFtZSA9ICdwYWRkaW5nJyArIHByb3BbMF0udG9VcHBlckNhc2UoKSArIHByb3Auc2xpY2UoMSk7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgIGlmIChvcHRpb25zW2xlZ2FjeVByb3BOYW1lXSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgcGFkZGluZ1ZhbHVlID0gb3B0aW9uc1tsZWdhY3lQcm9wTmFtZV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIE51bWJlcihwYWRkaW5nVmFsdWUpIHx8IDA7XG59XG4vKipcclxuICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9uc1xyXG4gKiBAcGFyYW0ge1BvaW50fSB2aWV3cG9ydFNpemVcclxuICogQHBhcmFtIHtTbGlkZURhdGF9IGl0ZW1EYXRhXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gKiBAcmV0dXJucyB7UG9pbnR9XHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYW5BcmVhU2l6ZShvcHRpb25zLCB2aWV3cG9ydFNpemUsIGl0ZW1EYXRhLCBpbmRleCkge1xuICByZXR1cm4ge1xuICAgIHg6IHZpZXdwb3J0U2l6ZS54IC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdsZWZ0Jywgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdyaWdodCcsIG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KSxcbiAgICB5OiB2aWV3cG9ydFNpemUueSAtIHBhcnNlUGFkZGluZ09wdGlvbigndG9wJywgb3B0aW9ucywgdmlld3BvcnRTaXplLCBpdGVtRGF0YSwgaW5kZXgpIC0gcGFyc2VQYWRkaW5nT3B0aW9uKCdib3R0b20nLCBvcHRpb25zLCB2aWV3cG9ydFNpemUsIGl0ZW1EYXRhLCBpbmRleClcbiAgfTtcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xuXG4vKiogQHR5cGVkZWYge1JlY29yZDxBeGlzLCBudW1iZXI+fSBQb2ludCAqL1xuXG4vKiogQHR5cGVkZWYgeyd4JyB8ICd5J30gQXhpcyAqL1xuXG4vKipcclxuICogQ2FsY3VsYXRlcyBtaW5pbXVtLCBtYXhpbXVtIGFuZCBpbml0aWFsIChjZW50ZXIpIGJvdW5kcyBvZiBhIHNsaWRlXHJcbiAqL1xuXG5jbGFzcyBQYW5Cb3VuZHMge1xuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlfSBzbGlkZVxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzbGlkZSkge1xuICAgIHRoaXMuc2xpZGUgPSBzbGlkZTtcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSAxO1xuICAgIHRoaXMuY2VudGVyID1cbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xuICAgIHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICB0aGlzLm1heCA9XG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cbiAgICB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgdGhpcy5taW4gPVxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG4gICAge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG4gIC8qKlxyXG4gICAqIF9nZXRJdGVtQm91bmRzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3Vyclpvb21MZXZlbFxyXG4gICAqL1xuXG5cbiAgdXBkYXRlKGN1cnJab29tTGV2ZWwpIHtcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSBjdXJyWm9vbUxldmVsO1xuXG4gICAgaWYgKCF0aGlzLnNsaWRlLndpZHRoKSB7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUF4aXMoJ3gnKTtcblxuICAgICAgdGhpcy5fdXBkYXRlQXhpcygneScpO1xuXG4gICAgICB0aGlzLnNsaWRlLnBzd3AuZGlzcGF0Y2goJ2NhbGNCb3VuZHMnLCB7XG4gICAgICAgIHNsaWRlOiB0aGlzLnNsaWRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogX2NhbGN1bGF0ZUl0ZW1Cb3VuZHNGb3JBeGlzXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0F4aXN9IGF4aXNcclxuICAgKi9cblxuXG4gIF91cGRhdGVBeGlzKGF4aXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXMuc2xpZGU7XG4gICAgY29uc3QgZWxTaXplID0gdGhpcy5zbGlkZVtheGlzID09PSAneCcgPyAnd2lkdGgnIDogJ2hlaWdodCddICogdGhpcy5jdXJyWm9vbUxldmVsO1xuICAgIGNvbnN0IHBhZGRpbmdQcm9wID0gYXhpcyA9PT0gJ3gnID8gJ2xlZnQnIDogJ3RvcCc7XG4gICAgY29uc3QgcGFkZGluZyA9IHBhcnNlUGFkZGluZ09wdGlvbihwYWRkaW5nUHJvcCwgcHN3cC5vcHRpb25zLCBwc3dwLnZpZXdwb3J0U2l6ZSwgdGhpcy5zbGlkZS5kYXRhLCB0aGlzLnNsaWRlLmluZGV4KTtcbiAgICBjb25zdCBwYW5BcmVhU2l6ZSA9IHRoaXMuc2xpZGUucGFuQXJlYVNpemVbYXhpc107IC8vIERlZmF1bHQgcG9zaXRpb24gb2YgZWxlbWVudC5cbiAgICAvLyBCeSBkZWZhdWx0LCBpdCBpcyBjZW50ZXIgb2Ygdmlld3BvcnQ6XG5cbiAgICB0aGlzLmNlbnRlcltheGlzXSA9IE1hdGgucm91bmQoKHBhbkFyZWFTaXplIC0gZWxTaXplKSAvIDIpICsgcGFkZGluZzsgLy8gbWF4aW11bSBwYW4gcG9zaXRpb25cblxuICAgIHRoaXMubWF4W2F4aXNdID0gZWxTaXplID4gcGFuQXJlYVNpemUgPyBNYXRoLnJvdW5kKHBhbkFyZWFTaXplIC0gZWxTaXplKSArIHBhZGRpbmcgOiB0aGlzLmNlbnRlcltheGlzXTsgLy8gbWluaW11bSBwYW4gcG9zaXRpb25cblxuICAgIHRoaXMubWluW2F4aXNdID0gZWxTaXplID4gcGFuQXJlYVNpemUgPyBwYWRkaW5nIDogdGhpcy5jZW50ZXJbYXhpc107XG4gIH0gLy8gX2dldFplcm9Cb3VuZHNcblxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMuY2VudGVyLnggPSAwO1xuICAgIHRoaXMuY2VudGVyLnkgPSAwO1xuICAgIHRoaXMubWF4LnggPSAwO1xuICAgIHRoaXMubWF4LnkgPSAwO1xuICAgIHRoaXMubWluLnggPSAwO1xuICAgIHRoaXMubWluLnkgPSAwO1xuICB9XG4gIC8qKlxyXG4gICAqIENvcnJlY3QgcGFuIHBvc2l0aW9uIGlmIGl0J3MgYmV5b25kIHRoZSBib3VuZHNcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXhpc30gYXhpcyB4IG9yIHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFuT2Zmc2V0XHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cblxuXG4gIGNvcnJlY3RQYW4oYXhpcywgcGFuT2Zmc2V0KSB7XG4gICAgLy8gY2hlY2tQYW5Cb3VuZHNcbiAgICByZXR1cm4gY2xhbXAocGFuT2Zmc2V0LCB0aGlzLm1heFtheGlzXSwgdGhpcy5taW5bYXhpc10pO1xuICB9XG5cbn1cblxuY29uc3QgTUFYX0lNQUdFX1dJRFRIID0gNDAwMDtcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBob3RvU3dpcGVPcHRpb25zfSBQaG90b1N3aXBlT3B0aW9ucyAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLlBvaW50fSBQb2ludCAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xuXG4vKiogQHR5cGVkZWYgeydmaXQnIHwgJ2ZpbGwnIHwgbnVtYmVyIHwgKCh6b29tTGV2ZWxPYmplY3Q6IFpvb21MZXZlbCkgPT4gbnVtYmVyKX0gWm9vbUxldmVsT3B0aW9uICovXG5cbi8qKlxyXG4gKiBDYWxjdWxhdGVzIHpvb20gbGV2ZWxzIGZvciBzcGVjaWZpYyBzbGlkZS5cclxuICogRGVwZW5kcyBvbiB2aWV3cG9ydCBzaXplIGFuZCBpbWFnZSBzaXplLlxyXG4gKi9cblxuY2xhc3MgWm9vbUxldmVsIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9ucyBQaG90b1N3aXBlIG9wdGlvbnNcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gaXRlbURhdGEgU2xpZGUgZGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBTbGlkZSBpbmRleFxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gW3Bzd3BdIFBob3RvU3dpcGUgaW5zdGFuY2UsIGNhbiBiZSB1bmRlZmluZWQgaWYgbm90IGluaXRpYWxpemVkIHlldFxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpdGVtRGF0YSwgaW5kZXgsIHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5pdGVtRGF0YSA9IGl0ZW1EYXRhO1xuICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAvKiogQHR5cGUgeyBQb2ludCB8IG51bGwgfSAqL1xuXG4gICAgdGhpcy5wYW5BcmVhU2l6ZSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHsgUG9pbnQgfCBudWxsIH0gKi9cblxuICAgIHRoaXMuZWxlbWVudFNpemUgPSBudWxsO1xuICAgIHRoaXMuZml0ID0gMTtcbiAgICB0aGlzLmZpbGwgPSAxO1xuICAgIHRoaXMudkZpbGwgPSAxO1xuICAgIHRoaXMuaW5pdGlhbCA9IDE7XG4gICAgdGhpcy5zZWNvbmRhcnkgPSAxO1xuICAgIHRoaXMubWF4ID0gMTtcbiAgICB0aGlzLm1pbiA9IDE7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FsY3VsYXRlIGluaXRpYWwsIHNlY29uZGFyeSBhbmQgbWF4aW11bSB6b29tIGxldmVsIGZvciB0aGUgc3BlY2lmaWVkIHNsaWRlLlxyXG4gICAqXHJcbiAgICogSXQgc2hvdWxkIGJlIGNhbGxlZCB3aGVuIGVpdGhlciBpbWFnZSBvciB2aWV3cG9ydCBzaXplIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2lkdGhcclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4SGVpZ2h0XHJcbiAgICogQHBhcmFtIHtQb2ludH0gcGFuQXJlYVNpemVcclxuICAgKi9cblxuXG4gIHVwZGF0ZShtYXhXaWR0aCwgbWF4SGVpZ2h0LCBwYW5BcmVhU2l6ZSkge1xuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG4gICAgY29uc3QgZWxlbWVudFNpemUgPSB7XG4gICAgICB4OiBtYXhXaWR0aCxcbiAgICAgIHk6IG1heEhlaWdodFxuICAgIH07XG4gICAgdGhpcy5lbGVtZW50U2l6ZSA9IGVsZW1lbnRTaXplO1xuICAgIHRoaXMucGFuQXJlYVNpemUgPSBwYW5BcmVhU2l6ZTtcbiAgICBjb25zdCBoUmF0aW8gPSBwYW5BcmVhU2l6ZS54IC8gZWxlbWVudFNpemUueDtcbiAgICBjb25zdCB2UmF0aW8gPSBwYW5BcmVhU2l6ZS55IC8gZWxlbWVudFNpemUueTtcbiAgICB0aGlzLmZpdCA9IE1hdGgubWluKDEsIGhSYXRpbyA8IHZSYXRpbyA/IGhSYXRpbyA6IHZSYXRpbyk7XG4gICAgdGhpcy5maWxsID0gTWF0aC5taW4oMSwgaFJhdGlvID4gdlJhdGlvID8gaFJhdGlvIDogdlJhdGlvKTsgLy8gem9vbS52RmlsbCBkZWZpbmVzIHpvb20gbGV2ZWwgb2YgdGhlIGltYWdlXG4gICAgLy8gd2hlbiBpdCBoYXMgMTAwJSBvZiB2aWV3cG9ydCB2ZXJ0aWNhbCBzcGFjZSAoaGVpZ2h0KVxuXG4gICAgdGhpcy52RmlsbCA9IE1hdGgubWluKDEsIHZSYXRpbyk7XG4gICAgdGhpcy5pbml0aWFsID0gdGhpcy5fZ2V0SW5pdGlhbCgpO1xuICAgIHRoaXMuc2Vjb25kYXJ5ID0gdGhpcy5fZ2V0U2Vjb25kYXJ5KCk7XG4gICAgdGhpcy5tYXggPSBNYXRoLm1heCh0aGlzLmluaXRpYWwsIHRoaXMuc2Vjb25kYXJ5LCB0aGlzLl9nZXRNYXgoKSk7XG4gICAgdGhpcy5taW4gPSBNYXRoLm1pbih0aGlzLmZpdCwgdGhpcy5pbml0aWFsLCB0aGlzLnNlY29uZGFyeSk7XG5cbiAgICBpZiAodGhpcy5wc3dwKSB7XG4gICAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ3pvb21MZXZlbHNVcGRhdGUnLCB7XG4gICAgICAgIHpvb21MZXZlbHM6IHRoaXMsXG4gICAgICAgIHNsaWRlRGF0YTogdGhpcy5pdGVtRGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFBhcnNlcyB1c2VyLWRlZmluZWQgem9vbSBvcHRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J2luaXRpYWwnIHwgJ3NlY29uZGFyeScgfCAnbWF4J30gb3B0aW9uUHJlZml4IFpvb20gbGV2ZWwgb3B0aW9uIHByZWZpeCAoaW5pdGlhbCwgc2Vjb25kYXJ5LCBtYXgpXHJcbiAgICogQHJldHVybnMgeyBudW1iZXIgfCB1bmRlZmluZWQgfVxyXG4gICAqL1xuXG5cbiAgX3BhcnNlWm9vbUxldmVsT3B0aW9uKG9wdGlvblByZWZpeCkge1xuICAgIGNvbnN0IG9wdGlvbk5hbWUgPVxuICAgIC8qKiBAdHlwZSB7J2luaXRpYWxab29tTGV2ZWwnIHwgJ3NlY29uZGFyeVpvb21MZXZlbCcgfCAnbWF4Wm9vbUxldmVsJ30gKi9cbiAgICBvcHRpb25QcmVmaXggKyAnWm9vbUxldmVsJztcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IHRoaXMub3B0aW9uc1tvcHRpb25OYW1lXTtcblxuICAgIGlmICghb3B0aW9uVmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvblZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gb3B0aW9uVmFsdWUodGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSAnZmlsbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmZpbGw7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvblZhbHVlID09PSAnZml0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuZml0O1xuICAgIH1cblxuICAgIHJldHVybiBOdW1iZXIob3B0aW9uVmFsdWUpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldCB6b29tIGxldmVsIHRvIHdoaWNoIGltYWdlIHdpbGwgYmUgem9vbWVkIGFmdGVyIGRvdWJsZS10YXAgZ2VzdHVyZSxcclxuICAgKiBvciB3aGVuIHVzZXIgY2xpY2tzIG9uIHpvb20gaWNvbixcclxuICAgKiBvciBtb3VzZS1jbGljayBvbiBpbWFnZSBpdHNlbGYuXHJcbiAgICogSWYgeW91IHJldHVybiAxIGltYWdlIHdpbGwgYmUgem9vbWVkIHRvIGl0cyBvcmlnaW5hbCBzaXplLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XHJcbiAgICovXG5cblxuICBfZ2V0U2Vjb25kYXJ5KCkge1xuICAgIGxldCBjdXJyWm9vbUxldmVsID0gdGhpcy5fcGFyc2Vab29tTGV2ZWxPcHRpb24oJ3NlY29uZGFyeScpO1xuXG4gICAgaWYgKGN1cnJab29tTGV2ZWwpIHtcbiAgICAgIHJldHVybiBjdXJyWm9vbUxldmVsO1xuICAgIH0gLy8gM3ggb2YgXCJmaXRcIiBzdGF0ZSwgYnV0IG5vdCBsYXJnZXIgdGhhbiBvcmlnaW5hbFxuXG5cbiAgICBjdXJyWm9vbUxldmVsID0gTWF0aC5taW4oMSwgdGhpcy5maXQgKiAzKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRTaXplICYmIGN1cnJab29tTGV2ZWwgKiB0aGlzLmVsZW1lbnRTaXplLnggPiBNQVhfSU1BR0VfV0lEVEgpIHtcbiAgICAgIGN1cnJab29tTGV2ZWwgPSBNQVhfSU1BR0VfV0lEVEggLyB0aGlzLmVsZW1lbnRTaXplLng7XG4gICAgfVxuXG4gICAgcmV0dXJuIGN1cnJab29tTGV2ZWw7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGluaXRpYWwgaW1hZ2Ugem9vbSBsZXZlbC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgX2dldEluaXRpYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcnNlWm9vbUxldmVsT3B0aW9uKCdpbml0aWFsJykgfHwgdGhpcy5maXQ7XG4gIH1cbiAgLyoqXHJcbiAgICogTWF4aW11bSB6b29tIGxldmVsIHdoZW4gdXNlciB6b29tc1xyXG4gICAqIHZpYSB6b29tL3BpbmNoIGdlc3R1cmUsXHJcbiAgICogdmlhIGNtZC9jdHJsLXdoZWVsIG9yIHZpYSB0cmFja3BhZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHJldHVybiB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgX2dldE1heCgpIHtcbiAgICAvLyBtYXggem9vbSBsZXZlbCBpcyB4NCBmcm9tIFwiZml0IHN0YXRlXCIsXG4gICAgLy8gdXNlZCBmb3Igem9vbSBnZXN0dXJlIGFuZCBjdHJsL3RyYWNrcGFkIHpvb21cbiAgICByZXR1cm4gdGhpcy5fcGFyc2Vab29tTGV2ZWxPcHRpb24oJ21heCcpIHx8IE1hdGgubWF4KDEsIHRoaXMuZml0ICogNCk7XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cbi8qKlxyXG4gKiBSZW5kZXJzIGFuZCBhbGxvd3MgdG8gY29udHJvbCBhIHNpbmdsZSBzbGlkZVxyXG4gKi9cblxuY2xhc3MgU2xpZGUge1xuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlRGF0YX0gZGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihkYXRhLCBpbmRleCwgcHN3cCkge1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIHRoaXMucHN3cCA9IHBzd3A7XG4gICAgdGhpcy5pc0FjdGl2ZSA9IGluZGV4ID09PSBwc3dwLmN1cnJJbmRleDtcbiAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gMDtcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xuXG4gICAgdGhpcy5wYW5BcmVhU2l6ZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xuXG4gICAgdGhpcy5wYW4gPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgdGhpcy5pc0ZpcnN0U2xpZGUgPSB0aGlzLmlzQWN0aXZlICYmICFwc3dwLm9wZW5lci5pc09wZW47XG4gICAgdGhpcy56b29tTGV2ZWxzID0gbmV3IFpvb21MZXZlbChwc3dwLm9wdGlvbnMsIGRhdGEsIGluZGV4LCBwc3dwKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ2dldHRpbmdEYXRhJywge1xuICAgICAgc2xpZGU6IHRoaXMsXG4gICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICBpbmRleFxuICAgIH0pO1xuICAgIHRoaXMuY29udGVudCA9IHRoaXMucHN3cC5jb250ZW50TG9hZGVyLmdldENvbnRlbnRCeVNsaWRlKHRoaXMpO1xuICAgIHRoaXMuY29udGFpbmVyID0gY3JlYXRlRWxlbWVudCgncHN3cF9fem9vbS13cmFwJywgJ2RpdicpO1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCBudWxsfSAqL1xuXG4gICAgdGhpcy5ob2xkZXJFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmN1cnJab29tTGV2ZWwgPSAxO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuXG4gICAgdGhpcy53aWR0aCA9IHRoaXMuY29udGVudC53aWR0aDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250ZW50LmhlaWdodDtcbiAgICB0aGlzLmhlYXZ5QXBwZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJvdW5kcyA9IG5ldyBQYW5Cb3VuZHModGhpcyk7XG4gICAgdGhpcy5wcmV2RGlzcGxheWVkV2lkdGggPSAtMTtcbiAgICB0aGlzLnByZXZEaXNwbGF5ZWRIZWlnaHQgPSAtMTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ3NsaWRlSW5pdCcsIHtcbiAgICAgIHNsaWRlOiB0aGlzXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogSWYgdGhpcyBzbGlkZSBpcyBhY3RpdmUvY3VycmVudC92aXNpYmxlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzQWN0aXZlXHJcbiAgICovXG5cblxuICBzZXRJc0FjdGl2ZShpc0FjdGl2ZSkge1xuICAgIGlmIChpc0FjdGl2ZSAmJiAhdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgLy8gc2xpZGUganVzdCBiZWNhbWUgYWN0aXZlXG4gICAgICB0aGlzLmFjdGl2YXRlKCk7XG4gICAgfSBlbHNlIGlmICghaXNBY3RpdmUgJiYgdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgLy8gc2xpZGUganVzdCBiZWNhbWUgbm9uLWFjdGl2ZVxuICAgICAgdGhpcy5kZWFjdGl2YXRlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFwcGVuZHMgc2xpZGUgY29udGVudCB0byBET01cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhvbGRlckVsZW1lbnRcclxuICAgKi9cblxuXG4gIGFwcGVuZChob2xkZXJFbGVtZW50KSB7XG4gICAgdGhpcy5ob2xkZXJFbGVtZW50ID0gaG9sZGVyRWxlbWVudDtcbiAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSAnMCAwJzsgLy8gU2xpZGUgYXBwZW5kZWQgdG8gRE9NXG5cbiAgICBpZiAoIXRoaXMuZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuICAgIHRoaXMubG9hZCgpO1xuICAgIHRoaXMudXBkYXRlQ29udGVudFNpemUoKTtcbiAgICB0aGlzLmFwcGVuZEhlYXZ5KCk7XG4gICAgdGhpcy5ob2xkZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuY29udGFpbmVyKTtcbiAgICB0aGlzLnpvb21BbmRQYW5Ub0luaXRpYWwoKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ2ZpcnN0Wm9vbVBhbicsIHtcbiAgICAgIHNsaWRlOiB0aGlzXG4gICAgfSk7XG4gICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdhZnRlclNldENvbnRlbnQnLCB7XG4gICAgICBzbGlkZTogdGhpc1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcbiAgICAgIHRoaXMuYWN0aXZhdGUoKTtcbiAgICB9XG4gIH1cblxuICBsb2FkKCkge1xuICAgIHRoaXMuY29udGVudC5sb2FkKGZhbHNlKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ3NsaWRlTG9hZCcsIHtcbiAgICAgIHNsaWRlOiB0aGlzXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQXBwZW5kIFwiaGVhdnlcIiBET00gZWxlbWVudHNcclxuICAgKlxyXG4gICAqIFRoaXMgbWF5IGRlcGVuZCBvbiBhIHR5cGUgb2Ygc2xpZGUsXHJcbiAgICogYnV0IGdlbmVyYWxseSB0aGVzZSBhcmUgbGFyZ2UgaW1hZ2VzLlxyXG4gICAqL1xuXG5cbiAgYXBwZW5kSGVhdnkoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGFwcGVuZEhlYXZ5TmVhcmJ5ID0gdHJ1ZTsgLy8gdG9kb1xuICAgIC8vIEF2b2lkIGFwcGVuZGluZyBoZWF2eSBlbGVtZW50cyBkdXJpbmcgYW5pbWF0aW9uc1xuXG4gICAgaWYgKHRoaXMuaGVhdnlBcHBlbmRlZCB8fCAhcHN3cC5vcGVuZXIuaXNPcGVuIHx8IHBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSB8fCAhdGhpcy5pc0FjdGl2ZSAmJiAhYXBwZW5kSGVhdnlOZWFyYnkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wc3dwLmRpc3BhdGNoKCdhcHBlbmRIZWF2eScsIHtcbiAgICAgIHNsaWRlOiB0aGlzXG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaGVhdnlBcHBlbmRlZCA9IHRydWU7XG4gICAgdGhpcy5jb250ZW50LmFwcGVuZCgpO1xuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnYXBwZW5kSGVhdnlDb250ZW50Jywge1xuICAgICAgc2xpZGU6IHRoaXNcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBUcmlnZ2VyZWQgd2hlbiB0aGlzIHNsaWRlIGlzIGFjdGl2ZSAoc2VsZWN0ZWQpLlxyXG4gICAqXHJcbiAgICogSWYgaXQncyBwYXJ0IG9mIG9wZW5pbmcvY2xvc2luZyB0cmFuc2l0aW9uIC1cclxuICAgKiBhY3RpdmF0ZSgpIHdpbGwgdHJpZ2dlciBhZnRlciB0aGUgdHJhbnNpdGlvbiBpcyBlbmRlZC5cclxuICAgKi9cblxuXG4gIGFjdGl2YXRlKCkge1xuICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuYXBwZW5kSGVhdnkoKTtcbiAgICB0aGlzLmNvbnRlbnQuYWN0aXZhdGUoKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ3NsaWRlQWN0aXZhdGUnLCB7XG4gICAgICBzbGlkZTogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFRyaWdnZXJlZCB3aGVuIHRoaXMgc2xpZGUgYmVjb21lcyBpbmFjdGl2ZS5cclxuICAgKlxyXG4gICAqIFNsaWRlIGNhbiBiZWNvbWUgaW5hY3RpdmUgb25seSBhZnRlciBpdCB3YXMgYWN0aXZlLlxyXG4gICAqL1xuXG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5jb250ZW50LmRlYWN0aXZhdGUoKTtcblxuICAgIGlmICh0aGlzLmN1cnJab29tTGV2ZWwgIT09IHRoaXMuem9vbUxldmVscy5pbml0aWFsKSB7XG4gICAgICAvLyBhbGxvdyBmaWx0ZXJpbmdcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuICAgIH0gLy8gcmVzZXQgem9vbSBsZXZlbFxuXG5cbiAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gMDtcbiAgICB0aGlzLnpvb21BbmRQYW5Ub0luaXRpYWwoKTtcbiAgICB0aGlzLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdzbGlkZURlYWN0aXZhdGUnLCB7XG4gICAgICBzbGlkZTogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFRoZSBzbGlkZSBzaG91bGQgZGVzdHJveSBpdHNlbGYsIGl0IHdpbGwgbmV2ZXIgYmUgdXNlZCBhZ2Fpbi5cclxuICAgKiAodW5iaW5kIGFsbCBldmVudHMgYW5kIGRlc3Ryb3kgaW50ZXJuYWwgY29tcG9uZW50cylcclxuICAgKi9cblxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5jb250ZW50Lmhhc1NsaWRlID0gZmFsc2U7XG4gICAgdGhpcy5jb250ZW50LnJlbW92ZSgpO1xuICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnc2xpZGVEZXN0cm95Jywge1xuICAgICAgc2xpZGU6IHRoaXNcbiAgICB9KTtcbiAgfVxuXG4gIHJlc2l6ZSgpIHtcbiAgICBpZiAodGhpcy5jdXJyWm9vbUxldmVsID09PSB0aGlzLnpvb21MZXZlbHMuaW5pdGlhbCB8fCAhdGhpcy5pc0FjdGl2ZSkge1xuICAgICAgLy8gS2VlcCBpbml0aWFsIHpvb20gbGV2ZWwgaWYgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLFxuICAgICAgLy8gYXMgd2VsbCBhcyB3aGVuIHRoaXMgc2xpZGUgaXMgbm90IGFjdGl2ZVxuICAgICAgLy8gUmVzZXQgcG9zaXRpb24gYW5kIHNjYWxlIHRvIG9yaWdpbmFsIHN0YXRlXG4gICAgICB0aGlzLmNhbGN1bGF0ZVNpemUoKTtcbiAgICAgIHRoaXMuY3VycmVudFJlc29sdXRpb24gPSAwO1xuICAgICAgdGhpcy56b29tQW5kUGFuVG9Jbml0aWFsKCk7XG4gICAgICB0aGlzLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgIHRoaXMudXBkYXRlQ29udGVudFNpemUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcmVhZGp1c3QgcGFuIHBvc2l0aW9uIGlmIGl0J3MgYmV5b25kIHRoZSBib3VuZHNcbiAgICAgIHRoaXMuY2FsY3VsYXRlU2l6ZSgpO1xuICAgICAgdGhpcy5ib3VuZHMudXBkYXRlKHRoaXMuY3Vyclpvb21MZXZlbCk7XG4gICAgICB0aGlzLnBhblRvKHRoaXMucGFuLngsIHRoaXMucGFuLnkpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBcHBseSBzaXplIHRvIGN1cnJlbnQgc2xpZGUgY29udGVudCxcclxuICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCByZXNvbHV0aW9uIGFuZCBzY2FsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlXSBpZiBzaXplIHNob3VsZCBiZSB1cGRhdGVkIGV2ZW4gaWYgZGltZW5zaW9ucyB3ZXJlbid0IGNoYW5nZWRcclxuICAgKi9cblxuXG4gIHVwZGF0ZUNvbnRlbnRTaXplKGZvcmNlKSB7XG4gICAgLy8gVXNlIGluaXRpYWwgem9vbSBsZXZlbFxuICAgIC8vIGlmIHJlc29sdXRpb24gaXMgbm90IGRlZmluZWQgKHVzZXIgZGlkbid0IHpvb20geWV0KVxuICAgIGNvbnN0IHNjYWxlTXVsdGlwbGllciA9IHRoaXMuY3VycmVudFJlc29sdXRpb24gfHwgdGhpcy56b29tTGV2ZWxzLmluaXRpYWw7XG5cbiAgICBpZiAoIXNjYWxlTXVsdGlwbGllcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5yb3VuZCh0aGlzLndpZHRoICogc2NhbGVNdWx0aXBsaWVyKSB8fCB0aGlzLnBzd3Audmlld3BvcnRTaXplLng7XG4gICAgY29uc3QgaGVpZ2h0ID0gTWF0aC5yb3VuZCh0aGlzLmhlaWdodCAqIHNjYWxlTXVsdGlwbGllcikgfHwgdGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS55O1xuXG4gICAgaWYgKCF0aGlzLnNpemVDaGFuZ2VkKHdpZHRoLCBoZWlnaHQpICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY29udGVudC5zZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICAgKi9cblxuXG4gIHNpemVDaGFuZ2VkKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMucHJldkRpc3BsYXllZFdpZHRoIHx8IGhlaWdodCAhPT0gdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0KSB7XG4gICAgICB0aGlzLnByZXZEaXNwbGF5ZWRXaWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5wcmV2RGlzcGxheWVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKiBAcmV0dXJucyB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxEaXZFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZH0gKi9cblxuXG4gIGdldFBsYWNlaG9sZGVyRWxlbWVudCgpIHtcbiAgICB2YXIgX3RoaXMkY29udGVudCRwbGFjZWhvO1xuXG4gICAgcmV0dXJuIChfdGhpcyRjb250ZW50JHBsYWNlaG8gPSB0aGlzLmNvbnRlbnQucGxhY2Vob2xkZXIpID09PSBudWxsIHx8IF90aGlzJGNvbnRlbnQkcGxhY2VobyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkY29udGVudCRwbGFjZWhvLmVsZW1lbnQ7XG4gIH1cbiAgLyoqXHJcbiAgICogWm9vbSBjdXJyZW50IHNsaWRlIGltYWdlIHRvLi4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVzdFpvb21MZXZlbCBEZXN0aW5hdGlvbiB6b29tIGxldmVsLlxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IFtjZW50ZXJQb2ludF1cclxuICAgKiBUcmFuc2Zvcm0gb3JpZ2luIGNlbnRlciBwb2ludCwgb3IgZmFsc2UgaWYgdmlld3BvcnQgY2VudGVyIHNob3VsZCBiZSB1c2VkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgZmFsc2V9IFt0cmFuc2l0aW9uRHVyYXRpb25dIFRyYW5zaXRpb24gZHVyYXRpb24sIG1heSBiZSBzZXQgdG8gMC5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpZ25vcmVCb3VuZHNdIE1pbmltdW0gYW5kIG1heGltdW0gem9vbSBsZXZlbHMgd2lsbCBiZSBpZ25vcmVkLlxyXG4gICAqL1xuXG5cbiAgem9vbVRvKGRlc3Rab29tTGV2ZWwsIGNlbnRlclBvaW50LCB0cmFuc2l0aW9uRHVyYXRpb24sIGlnbm9yZUJvdW5kcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcztcblxuICAgIGlmICghdGhpcy5pc1pvb21hYmxlKCkgfHwgcHN3cC5tYWluU2Nyb2xsLmlzU2hpZnRlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHN3cC5kaXNwYXRjaCgnYmVmb3JlWm9vbVRvJywge1xuICAgICAgZGVzdFpvb21MZXZlbCxcbiAgICAgIGNlbnRlclBvaW50LFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uXG4gICAgfSk7IC8vIHN0b3AgYWxsIHBhbiBhbmQgem9vbSB0cmFuc2l0aW9uc1xuXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTsgLy8gaWYgKCFjZW50ZXJQb2ludCkge1xuICAgIC8vICAgY2VudGVyUG9pbnQgPSBwc3dwLmdldFZpZXdwb3J0Q2VudGVyUG9pbnQoKTtcbiAgICAvLyB9XG5cbiAgICBjb25zdCBwcmV2Wm9vbUxldmVsID0gdGhpcy5jdXJyWm9vbUxldmVsO1xuXG4gICAgaWYgKCFpZ25vcmVCb3VuZHMpIHtcbiAgICAgIGRlc3Rab29tTGV2ZWwgPSBjbGFtcChkZXN0Wm9vbUxldmVsLCB0aGlzLnpvb21MZXZlbHMubWluLCB0aGlzLnpvb21MZXZlbHMubWF4KTtcbiAgICB9IC8vIGlmICh0cmFuc2l0aW9uRHVyYXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vICAgdHJhbnNpdGlvbkR1cmF0aW9uID0gdGhpcy5wc3dwLm9wdGlvbnMuem9vbUFuaW1hdGlvbkR1cmF0aW9uO1xuICAgIC8vIH1cblxuXG4gICAgdGhpcy5zZXRab29tTGV2ZWwoZGVzdFpvb21MZXZlbCk7XG4gICAgdGhpcy5wYW4ueCA9IHRoaXMuY2FsY3VsYXRlWm9vbVRvUGFuT2Zmc2V0KCd4JywgY2VudGVyUG9pbnQsIHByZXZab29tTGV2ZWwpO1xuICAgIHRoaXMucGFuLnkgPSB0aGlzLmNhbGN1bGF0ZVpvb21Ub1Bhbk9mZnNldCgneScsIGNlbnRlclBvaW50LCBwcmV2Wm9vbUxldmVsKTtcbiAgICByb3VuZFBvaW50KHRoaXMucGFuKTtcblxuICAgIGNvbnN0IGZpbmlzaFRyYW5zaXRpb24gPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zZXRSZXNvbHV0aW9uKGRlc3Rab29tTGV2ZWwpO1xuXG4gICAgICB0aGlzLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICB9O1xuXG4gICAgaWYgKCF0cmFuc2l0aW9uRHVyYXRpb24pIHtcbiAgICAgIGZpbmlzaFRyYW5zaXRpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHN3cC5hbmltYXRpb25zLnN0YXJ0VHJhbnNpdGlvbih7XG4gICAgICAgIGlzUGFuOiB0cnVlLFxuICAgICAgICBuYW1lOiAnem9vbVRvJyxcbiAgICAgICAgdGFyZ2V0OiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmdldEN1cnJlbnRUcmFuc2Zvcm0oKSxcbiAgICAgICAgb25Db21wbGV0ZTogZmluaXNoVHJhbnNpdGlvbixcbiAgICAgICAgZHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbixcbiAgICAgICAgZWFzaW5nOiBwc3dwLm9wdGlvbnMuZWFzaW5nXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb2ludH0gW2NlbnRlclBvaW50XVxyXG4gICAqL1xuXG5cbiAgdG9nZ2xlWm9vbShjZW50ZXJQb2ludCkge1xuICAgIHRoaXMuem9vbVRvKHRoaXMuY3Vyclpvb21MZXZlbCA9PT0gdGhpcy56b29tTGV2ZWxzLmluaXRpYWwgPyB0aGlzLnpvb21MZXZlbHMuc2Vjb25kYXJ5IDogdGhpcy56b29tTGV2ZWxzLmluaXRpYWwsIGNlbnRlclBvaW50LCB0aGlzLnBzd3Aub3B0aW9ucy56b29tQW5pbWF0aW9uRHVyYXRpb24pO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgem9vbSBsZXZlbCBwcm9wZXJ0eSBhbmQgcmVjYWxjdWxhdGVzIG5ldyBwYW4gYm91bmRzLFxyXG4gICAqIHVubGlrZSB6b29tVG8gaXQgZG9lcyBub3QgYXBwbHkgdHJhbnNmb3JtICh1c2UgYXBwbHlDdXJyZW50Wm9vbVBhbilcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyWm9vbUxldmVsXHJcbiAgICovXG5cblxuICBzZXRab29tTGV2ZWwoY3Vyclpvb21MZXZlbCkge1xuICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9IGN1cnJab29tTGV2ZWw7XG4gICAgdGhpcy5ib3VuZHMudXBkYXRlKHRoaXMuY3Vyclpvb21MZXZlbCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHBhbiBwb3NpdGlvbiBhZnRlciB6b29tIGF0IGEgZ2l2ZW4gYHBvaW50YC5cclxuICAgKlxyXG4gICAqIEFsd2F5cyBjYWxsIHNldFpvb21MZXZlbChuZXdab29tTGV2ZWwpIGJlZm9yZWhhbmQgdG8gcmVjYWxjdWxhdGVcclxuICAgKiBwYW4gYm91bmRzIGFjY29yZGluZyB0byB0aGUgbmV3IHpvb20gbGV2ZWwuXHJcbiAgICpcclxuICAgKiBAcGFyYW0geyd4JyB8ICd5J30gYXhpc1xyXG4gICAqIEBwYXJhbSB7UG9pbnR9IFtwb2ludF1cclxuICAgKiBwb2ludCBiYXNlZCBvbiB3aGljaCB6b29tIGlzIHBlcmZvcm1lZCwgdXN1YWxseSByZWZlcnMgdG8gdGhlIGN1cnJlbnQgbW91c2UgcG9zaXRpb24sXHJcbiAgICogaWYgZmFsc2UgLSB2aWV3cG9ydCBjZW50ZXIgd2lsbCBiZSB1c2VkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcHJldlpvb21MZXZlbF0gWm9vbSBsZXZlbCBiZWZvcmUgbmV3IHpvb20gd2FzIGFwcGxpZWQuXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cblxuXG4gIGNhbGN1bGF0ZVpvb21Ub1Bhbk9mZnNldChheGlzLCBwb2ludCwgcHJldlpvb21MZXZlbCkge1xuICAgIGNvbnN0IHRvdGFsUGFuRGlzdGFuY2UgPSB0aGlzLmJvdW5kcy5tYXhbYXhpc10gLSB0aGlzLmJvdW5kcy5taW5bYXhpc107XG5cbiAgICBpZiAodG90YWxQYW5EaXN0YW5jZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYm91bmRzLmNlbnRlcltheGlzXTtcbiAgICB9XG5cbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICBwb2ludCA9IHRoaXMucHN3cC5nZXRWaWV3cG9ydENlbnRlclBvaW50KCk7XG4gICAgfVxuXG4gICAgaWYgKCFwcmV2Wm9vbUxldmVsKSB7XG4gICAgICBwcmV2Wm9vbUxldmVsID0gdGhpcy56b29tTGV2ZWxzLmluaXRpYWw7XG4gICAgfVxuXG4gICAgY29uc3Qgem9vbUZhY3RvciA9IHRoaXMuY3Vyclpvb21MZXZlbCAvIHByZXZab29tTGV2ZWw7XG4gICAgcmV0dXJuIHRoaXMuYm91bmRzLmNvcnJlY3RQYW4oYXhpcywgKHRoaXMucGFuW2F4aXNdIC0gcG9pbnRbYXhpc10pICogem9vbUZhY3RvciArIHBvaW50W2F4aXNdKTtcbiAgfVxuICAvKipcclxuICAgKiBBcHBseSBwYW4gYW5kIGtlZXAgaXQgd2l0aGluIGJvdW5kcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwYW5YXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhbllcclxuICAgKi9cblxuXG4gIHBhblRvKHBhblgsIHBhblkpIHtcbiAgICB0aGlzLnBhbi54ID0gdGhpcy5ib3VuZHMuY29ycmVjdFBhbigneCcsIHBhblgpO1xuICAgIHRoaXMucGFuLnkgPSB0aGlzLmJvdW5kcy5jb3JyZWN0UGFuKCd5JywgcGFuWSk7XG4gICAgdGhpcy5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogSWYgdGhlIHNsaWRlIGluIHRoZSBjdXJyZW50IHN0YXRlIGNhbiBiZSBwYW5uZWQgYnkgdGhlIHVzZXJcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cblxuXG4gIGlzUGFubmFibGUoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy53aWR0aCkgJiYgdGhpcy5jdXJyWm9vbUxldmVsID4gdGhpcy56b29tTGV2ZWxzLmZpdDtcbiAgfVxuICAvKipcclxuICAgKiBJZiB0aGUgc2xpZGUgY2FuIGJlIHpvb21lZFxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuXG5cbiAgaXNab29tYWJsZSgpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLndpZHRoKSAmJiB0aGlzLmNvbnRlbnQuaXNab29tYWJsZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEFwcGx5IHRyYW5zZm9ybSBhbmQgc2NhbGUgYmFzZWQgb25cclxuICAgKiB0aGUgY3VycmVudCBwYW4gcG9zaXRpb24gKHRoaXMucGFuKSBhbmQgem9vbSBsZXZlbCAodGhpcy5jdXJyWm9vbUxldmVsKVxyXG4gICAqL1xuXG5cbiAgYXBwbHlDdXJyZW50Wm9vbVBhbigpIHtcbiAgICB0aGlzLl9hcHBseVpvb21UcmFuc2Zvcm0odGhpcy5wYW4ueCwgdGhpcy5wYW4ueSwgdGhpcy5jdXJyWm9vbUxldmVsKTtcblxuICAgIGlmICh0aGlzID09PSB0aGlzLnBzd3AuY3VyclNsaWRlKSB7XG4gICAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ3pvb21QYW5VcGRhdGUnLCB7XG4gICAgICAgIHNsaWRlOiB0aGlzXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICB6b29tQW5kUGFuVG9Jbml0aWFsKCkge1xuICAgIHRoaXMuY3Vyclpvb21MZXZlbCA9IHRoaXMuem9vbUxldmVscy5pbml0aWFsOyAvLyBwYW4gYWNjb3JkaW5nIHRvIHRoZSB6b29tIGxldmVsXG5cbiAgICB0aGlzLmJvdW5kcy51cGRhdGUodGhpcy5jdXJyWm9vbUxldmVsKTtcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnBhbiwgdGhpcy5ib3VuZHMuY2VudGVyKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goJ2luaXRpYWxab29tUGFuJywge1xuICAgICAgc2xpZGU6IHRoaXNcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBTZXQgdHJhbnNsYXRlIGFuZCBzY2FsZSBiYXNlZCBvbiBjdXJyZW50IHJlc29sdXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcclxuICAgKiBAcGFyYW0ge251bWJlcn0gem9vbVxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG5cblxuICBfYXBwbHlab29tVHJhbnNmb3JtKHgsIHksIHpvb20pIHtcbiAgICB6b29tIC89IHRoaXMuY3VycmVudFJlc29sdXRpb24gfHwgdGhpcy56b29tTGV2ZWxzLmluaXRpYWw7XG4gICAgc2V0VHJhbnNmb3JtKHRoaXMuY29udGFpbmVyLCB4LCB5LCB6b29tKTtcbiAgfVxuXG4gIGNhbGN1bGF0ZVNpemUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzO1xuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucGFuQXJlYVNpemUsIGdldFBhbkFyZWFTaXplKHBzd3Aub3B0aW9ucywgcHN3cC52aWV3cG9ydFNpemUsIHRoaXMuZGF0YSwgdGhpcy5pbmRleCkpO1xuICAgIHRoaXMuem9vbUxldmVscy51cGRhdGUodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMucGFuQXJlYVNpemUpO1xuICAgIHBzd3AuZGlzcGF0Y2goJ2NhbGNTbGlkZVNpemUnLCB7XG4gICAgICBzbGlkZTogdGhpc1xuICAgIH0pO1xuICB9XG4gIC8qKiBAcmV0dXJucyB7c3RyaW5nfSAqL1xuXG5cbiAgZ2V0Q3VycmVudFRyYW5zZm9ybSgpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMuY3Vyclpvb21MZXZlbCAvICh0aGlzLmN1cnJlbnRSZXNvbHV0aW9uIHx8IHRoaXMuem9vbUxldmVscy5pbml0aWFsKTtcbiAgICByZXR1cm4gdG9UcmFuc2Zvcm1TdHJpbmcodGhpcy5wYW4ueCwgdGhpcy5wYW4ueSwgc2NhbGUpO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCByZXNvbHV0aW9uIGFuZCByZS1yZW5kZXIgdGhlIGltYWdlLlxyXG4gICAqXHJcbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSByZWFsIGltYWdlIHNpemUgaXMgMjAwMHgxNTAwLFxyXG4gICAqIGFuZCByZXNvbHV0aW9uIGlzIDAuNSAtIGl0IHdpbGwgYmUgcmVuZGVyZWQgYXMgMTAwMHg3NTAuXHJcbiAgICpcclxuICAgKiBJbWFnZSB3aXRoIHpvb20gbGV2ZWwgMiBhbmQgcmVzb2x1dGlvbiAwLjUgaXNcclxuICAgKiB0aGUgc2FtZSBhcyBpbWFnZSB3aXRoIHpvb20gbGV2ZWwgMSBhbmQgcmVzb2x1dGlvbiAxLlxyXG4gICAqXHJcbiAgICogVXNlZCB0byBvcHRpbWl6ZSBhbmltYXRpb25zIGFuZCBtYWtlXHJcbiAgICogc3VyZSB0aGF0IGJyb3dzZXIgcmVuZGVycyBpbWFnZSBpbiB0aGUgaGlnaGVzdCBxdWFsaXR5LlxyXG4gICAqIEFsc28gdXNlZCBieSByZXNwb25zaXZlIGltYWdlcyB0byBsb2FkIHRoZSBjb3JyZWN0IG9uZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdSZXNvbHV0aW9uXHJcbiAgICovXG5cblxuICBfc2V0UmVzb2x1dGlvbihuZXdSZXNvbHV0aW9uKSB7XG4gICAgaWYgKG5ld1Jlc29sdXRpb24gPT09IHRoaXMuY3VycmVudFJlc29sdXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmN1cnJlbnRSZXNvbHV0aW9uID0gbmV3UmVzb2x1dGlvbjtcbiAgICB0aGlzLnVwZGF0ZUNvbnRlbnRTaXplKCk7XG4gICAgdGhpcy5wc3dwLmRpc3BhdGNoKCdyZXNvbHV0aW9uQ2hhbmdlZCcpO1xuICB9XG5cbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2VzdHVyZXMuanMnKS5kZWZhdWx0fSBHZXN0dXJlcyAqL1xuXG5jb25zdCBQQU5fRU5EX0ZSSUNUSU9OID0gMC4zNTtcbmNvbnN0IFZFUlRJQ0FMX0RSQUdfRlJJQ1RJT04gPSAwLjY7IC8vIDEgY29ycmVzcG9uZHMgdG8gdGhlIHRoaXJkIG9mIHZpZXdwb3J0IGhlaWdodFxuXG5jb25zdCBNSU5fUkFUSU9fVE9fQ0xPU0UgPSAwLjQ7IC8vIE1pbmltdW0gc3BlZWQgcmVxdWlyZWQgdG8gbmF2aWdhdGVcbi8vIHRvIG5leHQgb3IgcHJldmlvdXMgc2xpZGVcblxuY29uc3QgTUlOX05FWFRfU0xJREVfU1BFRUQgPSAwLjU7XG4vKipcclxuICogQHBhcmFtIHtudW1iZXJ9IGluaXRpYWxWZWxvY2l0eVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZGVjZWxlcmF0aW9uUmF0ZVxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cblxuZnVuY3Rpb24gcHJvamVjdChpbml0aWFsVmVsb2NpdHksIGRlY2VsZXJhdGlvblJhdGUpIHtcbiAgcmV0dXJuIGluaXRpYWxWZWxvY2l0eSAqIGRlY2VsZXJhdGlvblJhdGUgLyAoMSAtIGRlY2VsZXJhdGlvblJhdGUpO1xufVxuLyoqXHJcbiAqIEhhbmRsZXMgc2luZ2xlIHBvaW50ZXIgZHJhZ2dpbmdcclxuICovXG5cblxuY2xhc3MgRHJhZ0hhbmRsZXIge1xuICAvKipcclxuICAgKiBAcGFyYW0ge0dlc3R1cmVzfSBnZXN0dXJlc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xuICAgIHRoaXMuZ2VzdHVyZXMgPSBnZXN0dXJlcztcbiAgICB0aGlzLnBzd3AgPSBnZXN0dXJlcy5wc3dwO1xuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG5cbiAgICB0aGlzLnN0YXJ0UGFuID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMucHN3cC5jdXJyU2xpZGUpIHtcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQYW4sIHRoaXMucHN3cC5jdXJyU2xpZGUucGFuKTtcbiAgICB9XG5cbiAgICB0aGlzLnBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7XG4gIH1cblxuICBjaGFuZ2UoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcDEsXG4gICAgICBwcmV2UDEsXG4gICAgICBkcmFnQXhpc1xuICAgIH0gPSB0aGlzLmdlc3R1cmVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJTbGlkZVxuICAgIH0gPSB0aGlzLnBzd3A7XG5cbiAgICBpZiAoZHJhZ0F4aXMgPT09ICd5JyAmJiB0aGlzLnBzd3Aub3B0aW9ucy5jbG9zZU9uVmVydGljYWxEcmFnICYmIGN1cnJTbGlkZSAmJiBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA8PSBjdXJyU2xpZGUuem9vbUxldmVscy5maXQgJiYgIXRoaXMuZ2VzdHVyZXMuaXNNdWx0aXRvdWNoKSB7XG4gICAgICAvLyBIYW5kbGUgdmVydGljYWwgZHJhZyB0byBjbG9zZVxuICAgICAgY29uc3QgcGFuWSA9IGN1cnJTbGlkZS5wYW4ueSArIChwMS55IC0gcHJldlAxLnkpO1xuXG4gICAgICBpZiAoIXRoaXMucHN3cC5kaXNwYXRjaCgndmVydGljYWxEcmFnJywge1xuICAgICAgICBwYW5ZXG4gICAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbigneScsIHBhblksIFZFUlRJQ0FMX0RSQUdfRlJJQ1RJT04pO1xuXG4gICAgICAgIGNvbnN0IGJnT3BhY2l0eSA9IDEgLSBNYXRoLmFicyh0aGlzLl9nZXRWZXJ0aWNhbERyYWdSYXRpbyhjdXJyU2xpZGUucGFuLnkpKTtcbiAgICAgICAgdGhpcy5wc3dwLmFwcGx5QmdPcGFjaXR5KGJnT3BhY2l0eSk7XG4gICAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1haW5TY3JvbGxDaGFuZ2VkID0gdGhpcy5fcGFuT3JNb3ZlTWFpblNjcm9sbCgneCcpO1xuXG4gICAgICBpZiAoIW1haW5TY3JvbGxDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMuX3Bhbk9yTW92ZU1haW5TY3JvbGwoJ3knKTtcblxuICAgICAgICBpZiAoY3VyclNsaWRlKSB7XG4gICAgICAgICAgcm91bmRQb2ludChjdXJyU2xpZGUucGFuKTtcbiAgICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlbG9jaXR5XG4gICAgfSA9IHRoaXMuZ2VzdHVyZXM7XG4gICAgY29uc3Qge1xuICAgICAgbWFpblNjcm9sbCxcbiAgICAgIGN1cnJTbGlkZVxuICAgIH0gPSB0aGlzLnBzd3A7XG4gICAgbGV0IGluZGV4RGlmZiA9IDA7XG4gICAgdGhpcy5wc3dwLmFuaW1hdGlvbnMuc3RvcEFsbCgpOyAvLyBIYW5kbGUgbWFpbiBzY3JvbGwgaWYgaXQncyBzaGlmdGVkXG5cbiAgICBpZiAobWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xuICAgICAgLy8gUG9zaXRpb24gb2YgdGhlIG1haW4gc2Nyb2xsIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydFxuICAgICAgY29uc3QgbWFpblNjcm9sbFNoaWZ0RGlmZiA9IG1haW5TY3JvbGwueCAtIG1haW5TY3JvbGwuZ2V0Q3VyclNsaWRlWCgpOyAvLyBSYXRpbyBiZXR3ZWVuIDAgYW5kIDE6XG4gICAgICAvLyAwIC0gc2xpZGUgaXMgbm90IHZpc2libGUgYXQgYWxsLFxuICAgICAgLy8gMC41IC0gaGFsZiBvZiB0aGUgc2xpZGUgaXMgdmlzaWJsZVxuICAgICAgLy8gMSAtIHNsaWRlIGlzIGZ1bGx5IHZpc2libGVcblxuICAgICAgY29uc3QgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvID0gbWFpblNjcm9sbFNoaWZ0RGlmZiAvIHRoaXMucHN3cC52aWV3cG9ydFNpemUueDsgLy8gR28gbmV4dCBzbGlkZS5cbiAgICAgIC8vXG4gICAgICAvLyAtIGlmIHZlbG9jaXR5IGFuZCBpdHMgZGlyZWN0aW9uIGlzIG1hdGNoZWQsXG4gICAgICAvLyAgIGFuZCB3ZSBzZWUgYXQgbGVhc3QgdGlueSBwYXJ0IG9mIHRoZSBuZXh0IHNsaWRlXG4gICAgICAvL1xuICAgICAgLy8gLSBvciBpZiB3ZSBzZWUgbGVzcyB0aGFuIDUwJSBvZiB0aGUgY3VycmVudCBzbGlkZVxuICAgICAgLy8gICBhbmQgdmVsb2NpdHkgaXMgY2xvc2UgdG8gMFxuICAgICAgLy9cblxuICAgICAgaWYgKHZlbG9jaXR5LnggPCAtTUlOX05FWFRfU0xJREVfU1BFRUQgJiYgY3VycmVudFNsaWRlVmlzaWJpbGl0eVJhdGlvIDwgMCB8fCB2ZWxvY2l0eS54IDwgMC4xICYmIGN1cnJlbnRTbGlkZVZpc2liaWxpdHlSYXRpbyA8IC0wLjUpIHtcbiAgICAgICAgLy8gR28gdG8gbmV4dCBzbGlkZVxuICAgICAgICBpbmRleERpZmYgPSAxO1xuICAgICAgICB2ZWxvY2l0eS54ID0gTWF0aC5taW4odmVsb2NpdHkueCwgMCk7XG4gICAgICB9IGVsc2UgaWYgKHZlbG9jaXR5LnggPiBNSU5fTkVYVF9TTElERV9TUEVFRCAmJiBjdXJyZW50U2xpZGVWaXNpYmlsaXR5UmF0aW8gPiAwIHx8IHZlbG9jaXR5LnggPiAtMC4xICYmIGN1cnJlbnRTbGlkZVZpc2liaWxpdHlSYXRpbyA+IDAuNSkge1xuICAgICAgICAvLyBHbyB0byBwcmV2IHNsaWRlXG4gICAgICAgIGluZGV4RGlmZiA9IC0xO1xuICAgICAgICB2ZWxvY2l0eS54ID0gTWF0aC5tYXgodmVsb2NpdHkueCwgMCk7XG4gICAgICB9XG5cbiAgICAgIG1haW5TY3JvbGwubW92ZUluZGV4QnkoaW5kZXhEaWZmLCB0cnVlLCB2ZWxvY2l0eS54KTtcbiAgICB9IC8vIFJlc3RvcmUgem9vbSBsZXZlbFxuXG5cbiAgICBpZiAoY3VyclNsaWRlICYmIGN1cnJTbGlkZS5jdXJyWm9vbUxldmVsID4gY3VyclNsaWRlLnpvb21MZXZlbHMubWF4IHx8IHRoaXMuZ2VzdHVyZXMuaXNNdWx0aXRvdWNoKSB7XG4gICAgICB0aGlzLmdlc3R1cmVzLnpvb21MZXZlbHMuY29ycmVjdFpvb21QYW4odHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIHJ1biB0d28gYW5pbWF0aW9ucyBpbnN0ZWFkIG9mIG9uZSxcbiAgICAgIC8vIGFzIGVhY2ggYXhpcyBoYXMgb3duIHBhbiBib3VuZGFyaWVzIGFuZCB0aHVzIGRpZmZlcmVudCBzcHJpbmcgZnVuY3Rpb25cbiAgICAgIC8vIChjb3JyZWN0Wm9vbVBhbiBkb2VzIG5vdCBoYXZlIHRoaXMgZnVuY3Rpb25hbGl0eSxcbiAgICAgIC8vICBpdCBhbmltYXRlcyBhbGwgcHJvcGVydGllcyB3aXRoIHNpbmdsZSB0aW1pbmcgZnVuY3Rpb24pXG4gICAgICB0aGlzLl9maW5pc2hQYW5HZXN0dXJlRm9yQXhpcygneCcpO1xuXG4gICAgICB0aGlzLl9maW5pc2hQYW5HZXN0dXJlRm9yQXhpcygneScpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICovXG5cblxuICBfZmluaXNoUGFuR2VzdHVyZUZvckF4aXMoYXhpcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZlbG9jaXR5XG4gICAgfSA9IHRoaXMuZ2VzdHVyZXM7XG4gICAgY29uc3Qge1xuICAgICAgY3VyclNsaWRlXG4gICAgfSA9IHRoaXMucHN3cDtcblxuICAgIGlmICghY3VyclNsaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgcGFuLFxuICAgICAgYm91bmRzXG4gICAgfSA9IGN1cnJTbGlkZTtcbiAgICBjb25zdCBwYW5Qb3MgPSBwYW5bYXhpc107XG4gICAgY29uc3QgcmVzdG9yZUJnT3BhY2l0eSA9IHRoaXMucHN3cC5iZ09wYWNpdHkgPCAxICYmIGF4aXMgPT09ICd5JzsgLy8gMC45OTUgbWVhbnMgLSBzY3JvbGwgdmlldyBsb3NlcyAwLjUlIG9mIGl0cyB2ZWxvY2l0eSBwZXIgbWlsbGlzZWNvbmRcbiAgICAvLyBJbmNyZWFzaW5nIHRoaXMgbnVtYmVyIHdpbGwgcmVkdWNlIHRyYXZlbCBkaXN0YW5jZVxuXG4gICAgY29uc3QgZGVjZWxlcmF0aW9uUmF0ZSA9IDAuOTk1OyAvLyAwLjk5XG4gICAgLy8gUGFuIHBvc2l0aW9uIGlmIHRoZXJlIGlzIG5vIGJvdW5kc1xuXG4gICAgY29uc3QgcHJvamVjdGVkUG9zaXRpb24gPSBwYW5Qb3MgKyBwcm9qZWN0KHZlbG9jaXR5W2F4aXNdLCBkZWNlbGVyYXRpb25SYXRlKTtcblxuICAgIGlmIChyZXN0b3JlQmdPcGFjaXR5KSB7XG4gICAgICBjb25zdCB2RHJhZ1JhdGlvID0gdGhpcy5fZ2V0VmVydGljYWxEcmFnUmF0aW8ocGFuUG9zKTtcblxuICAgICAgY29uc3QgcHJvamVjdGVkVkRyYWdSYXRpbyA9IHRoaXMuX2dldFZlcnRpY2FsRHJhZ1JhdGlvKHByb2plY3RlZFBvc2l0aW9uKTsgLy8gSWYgd2UgYXJlIGFib3ZlIGFuZCBtb3ZpbmcgdXB3YXJkcyxcbiAgICAgIC8vIG9yIGlmIHdlIGFyZSBiZWxvdyBhbmQgbW92aW5nIGRvd253YXJkc1xuXG5cbiAgICAgIGlmICh2RHJhZ1JhdGlvIDwgMCAmJiBwcm9qZWN0ZWRWRHJhZ1JhdGlvIDwgLU1JTl9SQVRJT19UT19DTE9TRSB8fCB2RHJhZ1JhdGlvID4gMCAmJiBwcm9qZWN0ZWRWRHJhZ1JhdGlvID4gTUlOX1JBVElPX1RPX0NMT1NFKSB7XG4gICAgICAgIHRoaXMucHN3cC5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSAvLyBQYW4gcG9zaXRpb24gd2l0aCBjb3JyZWN0ZWQgYm91bmRzXG5cblxuICAgIGNvbnN0IGNvcnJlY3RlZFBhblBvc2l0aW9uID0gYm91bmRzLmNvcnJlY3RQYW4oYXhpcywgcHJvamVjdGVkUG9zaXRpb24pOyAvLyBFeGl0IGlmIHBhbiBwb3NpdGlvbiBzaG91bGQgbm90IGJlIGNoYW5nZWRcbiAgICAvLyBvciBpZiBzcGVlZCBpdCB0b28gbG93XG5cbiAgICBpZiAocGFuUG9zID09PSBjb3JyZWN0ZWRQYW5Qb3NpdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gT3ZlcnNob290IGlmIHRoZSBmaW5hbCBwb3NpdGlvbiBpcyBvdXQgb2YgcGFuIGJvdW5kc1xuXG5cbiAgICBjb25zdCBkYW1waW5nUmF0aW8gPSBjb3JyZWN0ZWRQYW5Qb3NpdGlvbiA9PT0gcHJvamVjdGVkUG9zaXRpb24gPyAxIDogMC44MjtcbiAgICBjb25zdCBpbml0aWFsQmdPcGFjaXR5ID0gdGhpcy5wc3dwLmJnT3BhY2l0eTtcbiAgICBjb25zdCB0b3RhbFBhbkRpc3QgPSBjb3JyZWN0ZWRQYW5Qb3NpdGlvbiAtIHBhblBvcztcbiAgICB0aGlzLnBzd3AuYW5pbWF0aW9ucy5zdGFydFNwcmluZyh7XG4gICAgICBuYW1lOiAncGFuR2VzdHVyZScgKyBheGlzLFxuICAgICAgaXNQYW46IHRydWUsXG4gICAgICBzdGFydDogcGFuUG9zLFxuICAgICAgZW5kOiBjb3JyZWN0ZWRQYW5Qb3NpdGlvbixcbiAgICAgIHZlbG9jaXR5OiB2ZWxvY2l0eVtheGlzXSxcbiAgICAgIGRhbXBpbmdSYXRpbyxcbiAgICAgIG9uVXBkYXRlOiBwb3MgPT4ge1xuICAgICAgICAvLyBBbmltYXRlIG9wYWNpdHkgb2YgYmFja2dyb3VuZCByZWxhdGl2ZSB0byBZIHBhbiBwb3NpdGlvbiBvZiBhbiBpbWFnZVxuICAgICAgICBpZiAocmVzdG9yZUJnT3BhY2l0eSAmJiB0aGlzLnBzd3AuYmdPcGFjaXR5IDwgMSkge1xuICAgICAgICAgIC8vIDAgLSBzdGFydCBvZiBhbmltYXRpb24sIDEgLSBlbmQgb2YgYW5pbWF0aW9uXG4gICAgICAgICAgY29uc3QgYW5pbWF0aW9uUHJvZ3Jlc3NSYXRpbyA9IDEgLSAoY29ycmVjdGVkUGFuUG9zaXRpb24gLSBwb3MpIC8gdG90YWxQYW5EaXN0OyAvLyBXZSBjbGFtcCBvcGFjaXR5IHRvIGtlZXAgaXQgYmV0d2VlbiAwIGFuZCAxLlxuICAgICAgICAgIC8vIEFzIHByb2dyZXNzIHJhdGlvIGNhbiBiZSBsYXJnZXIgdGhhbiAxIGR1ZSB0byBvdmVyc2hvb3QsXG4gICAgICAgICAgLy8gYW5kIHdlIGRvIG5vdCB3YW50IHRvIGJvdW5jZSBvcGFjaXR5LlxuXG4gICAgICAgICAgdGhpcy5wc3dwLmFwcGx5QmdPcGFjaXR5KGNsYW1wKGluaXRpYWxCZ09wYWNpdHkgKyAoMSAtIGluaXRpYWxCZ09wYWNpdHkpICogYW5pbWF0aW9uUHJvZ3Jlc3NSYXRpbywgMCwgMSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFuW2F4aXNdID0gTWF0aC5mbG9vcihwb3MpO1xuICAgICAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBwb3NpdGlvbiBvZiB0aGUgbWFpbiBzY3JvbGwsXHJcbiAgICogb3IvYW5kIHVwZGF0ZSBwYW4gcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgc2xpZGUuXHJcbiAgICpcclxuICAgKiBTaG91bGQgcmV0dXJuIHRydWUgaWYgaXQgY2hhbmdlcyAob3IgY2FuIGNoYW5nZSkgbWFpbiBzY3JvbGwuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXG5cblxuICBfcGFuT3JNb3ZlTWFpblNjcm9sbChheGlzKSB7XG4gICAgY29uc3Qge1xuICAgICAgcDEsXG4gICAgICBkcmFnQXhpcyxcbiAgICAgIHByZXZQMSxcbiAgICAgIGlzTXVsdGl0b3VjaFxuICAgIH0gPSB0aGlzLmdlc3R1cmVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJTbGlkZSxcbiAgICAgIG1haW5TY3JvbGxcbiAgICB9ID0gdGhpcy5wc3dwO1xuICAgIGNvbnN0IGRlbHRhID0gcDFbYXhpc10gLSBwcmV2UDFbYXhpc107XG4gICAgY29uc3QgbmV3TWFpblNjcm9sbFggPSBtYWluU2Nyb2xsLnggKyBkZWx0YTtcblxuICAgIGlmICghZGVsdGEgfHwgIWN1cnJTbGlkZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQWx3YXlzIG1vdmUgbWFpbiBzY3JvbGwgaWYgaW1hZ2UgY2FuIG5vdCBiZSBwYW5uZWRcblxuXG4gICAgaWYgKGF4aXMgPT09ICd4JyAmJiAhY3VyclNsaWRlLmlzUGFubmFibGUoKSAmJiAhaXNNdWx0aXRvdWNoKSB7XG4gICAgICBtYWluU2Nyb2xsLm1vdmVUbyhuZXdNYWluU2Nyb2xsWCwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gY2hhbmdlZCBtYWluIHNjcm9sbFxuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIGJvdW5kc1xuICAgIH0gPSBjdXJyU2xpZGU7XG4gICAgY29uc3QgbmV3UGFuID0gY3VyclNsaWRlLnBhbltheGlzXSArIGRlbHRhO1xuXG4gICAgaWYgKHRoaXMucHN3cC5vcHRpb25zLmFsbG93UGFuVG9OZXh0ICYmIGRyYWdBeGlzID09PSAneCcgJiYgYXhpcyA9PT0gJ3gnICYmICFpc011bHRpdG91Y2gpIHtcbiAgICAgIGNvbnN0IGN1cnJTbGlkZU1haW5TY3JvbGxYID0gbWFpblNjcm9sbC5nZXRDdXJyU2xpZGVYKCk7IC8vIFBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnRcblxuICAgICAgY29uc3QgbWFpblNjcm9sbFNoaWZ0RGlmZiA9IG1haW5TY3JvbGwueCAtIGN1cnJTbGlkZU1haW5TY3JvbGxYO1xuICAgICAgY29uc3QgaXNMZWZ0VG9SaWdodCA9IGRlbHRhID4gMDtcbiAgICAgIGNvbnN0IGlzUmlnaHRUb0xlZnQgPSAhaXNMZWZ0VG9SaWdodDtcblxuICAgICAgaWYgKG5ld1BhbiA+IGJvdW5kcy5taW5bYXhpc10gJiYgaXNMZWZ0VG9SaWdodCkge1xuICAgICAgICAvLyBQYW5uaW5nIGZyb20gbGVmdCB0byByaWdodCwgYmV5b25kIHRoZSBsZWZ0IGVkZ2VcbiAgICAgICAgLy8gV2V0aGVyIHRoZSBpbWFnZSB3YXMgYXQgbWluaW11bSBwYW4gcG9zaXRpb24gKG9yIGxlc3MpXG4gICAgICAgIC8vIHdoZW4gdGhpcyBkcmFnIGdlc3R1cmUgc3RhcnRlZC5cbiAgICAgICAgLy8gTWluaW11bSBwYW4gcG9zaXRpb24gcmVmZXJzIHRvIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIGltYWdlLlxuICAgICAgICBjb25zdCB3YXNBdE1pblBhblBvc2l0aW9uID0gYm91bmRzLm1pbltheGlzXSA8PSB0aGlzLnN0YXJ0UGFuW2F4aXNdO1xuXG4gICAgICAgIGlmICh3YXNBdE1pblBhblBvc2l0aW9uKSB7XG4gICAgICAgICAgbWFpblNjcm9sbC5tb3ZlVG8obmV3TWFpblNjcm9sbFgsIHRydWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pOyAvL2N1cnJTbGlkZS5wYW5bYXhpc10gPSBuZXdQYW47XG5cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdQYW4gPCBib3VuZHMubWF4W2F4aXNdICYmIGlzUmlnaHRUb0xlZnQpIHtcbiAgICAgICAgLy8gUGFuaW5nIGZyb20gcmlnaHQgdG8gbGVmdCwgYmV5b25kIHRoZSByaWdodCBlZGdlXG4gICAgICAgIC8vIE1heGltdW0gcGFuIHBvc2l0aW9uIHJlZmVycyB0byB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgaW1hZ2UuXG4gICAgICAgIGNvbnN0IHdhc0F0TWF4UGFuUG9zaXRpb24gPSB0aGlzLnN0YXJ0UGFuW2F4aXNdIDw9IGJvdW5kcy5tYXhbYXhpc107XG5cbiAgICAgICAgaWYgKHdhc0F0TWF4UGFuUG9zaXRpb24pIHtcbiAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhuZXdNYWluU2Nyb2xsWCwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGFuV2l0aEZyaWN0aW9uKGF4aXMsIG5ld1Bhbik7IC8vY3VyclNsaWRlLnBhbltheGlzXSA9IG5ld1BhbjtcblxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkXG4gICAgICAgIGlmIChtYWluU2Nyb2xsU2hpZnREaWZmICE9PSAwKSB7XG4gICAgICAgICAgLy8gSWYgbWFpbiBzY3JvbGwgaXMgc2hpZnRlZCByaWdodFxuICAgICAgICAgIGlmIChtYWluU2Nyb2xsU2hpZnREaWZmID4gMFxuICAgICAgICAgIC8qJiYgaXNSaWdodFRvTGVmdCovXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1heChuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAobWFpblNjcm9sbFNoaWZ0RGlmZiA8IDBcbiAgICAgICAgICAvKiYmIGlzTGVmdFRvUmlnaHQqL1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgLy8gTWFpbiBzY3JvbGwgaXMgc2hpZnRlZCBsZWZ0IChQb3NpdGlvbiBpcyBsZXNzIHRoYW4gMCBjb21wYXJpbmcgdG8gdGhlIHZpZXdwb3J0IDApXG4gICAgICAgICAgICBtYWluU2Nyb2xsLm1vdmVUbyhNYXRoLm1pbihuZXdNYWluU2Nyb2xsWCwgY3VyclNsaWRlTWFpblNjcm9sbFgpLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBhcmUgd2l0aGluIHBhbiBib3VuZHMsIHNvIGp1c3QgcGFuXG4gICAgICAgICAgdGhpcy5fc2V0UGFuV2l0aEZyaWN0aW9uKGF4aXMsIG5ld1Bhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGF4aXMgPT09ICd5Jykge1xuICAgICAgICAvLyBEbyBub3QgcGFuIHZlcnRpY2FsbHkgaWYgbWFpbiBzY3JvbGwgaXMgc2hpZnRlZCBvXG4gICAgICAgIGlmICghbWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSAmJiBib3VuZHMubWluLnkgIT09IGJvdW5kcy5tYXgueSkge1xuICAgICAgICAgIHRoaXMuX3NldFBhbldpdGhGcmljdGlvbihheGlzLCBuZXdQYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgbmV3UGFuKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gSWYgd2UgbW92ZSBhYm92ZSAtIHRoZSByYXRpbyBpcyBuZWdhdGl2ZVxuICAvLyBJZiB3ZSBtb3ZlIGJlbG93IHRoZSByYXRpbyBpcyBwb3NpdGl2ZVxuXG4gIC8qKlxyXG4gICAqIFJlbGF0aW9uIGJldHdlZW4gcGFuIFkgcG9zaXRpb24gYW5kIHRoaXJkIG9mIHZpZXdwb3J0IGhlaWdodC5cclxuICAgKlxyXG4gICAqIFdoZW4gd2UgYXJlIGF0IGluaXRpYWwgcG9zaXRpb24gKGNlbnRlciBib3VuZHMpIC0gdGhlIHJhdGlvIGlzIDAsXHJcbiAgICogaWYgcG9zaXRpb24gaXMgc2hpZnRlZCB1cHdhcmRzIC0gdGhlIHJhdGlvIGlzIG5lZ2F0aXZlLFxyXG4gICAqIGlmIHBvc2l0aW9uIGlzIHNoaWZ0ZWQgZG93bndhcmRzIC0gdGhlIHJhdGlvIGlzIHBvc2l0aXZlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGFuWSBUaGUgY3VycmVudCBwYW4gWSBwb3NpdGlvbi5cclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgX2dldFZlcnRpY2FsRHJhZ1JhdGlvKHBhblkpIHtcbiAgICB2YXIgX3RoaXMkcHN3cCRjdXJyU2xpZGUkLCBfdGhpcyRwc3dwJGN1cnJTbGlkZTtcblxuICAgIHJldHVybiAocGFuWSAtICgoX3RoaXMkcHN3cCRjdXJyU2xpZGUkID0gKF90aGlzJHBzd3AkY3VyclNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZSkgPT09IG51bGwgfHwgX3RoaXMkcHN3cCRjdXJyU2xpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHBzd3AkY3VyclNsaWRlLmJvdW5kcy5jZW50ZXIueSkgIT09IG51bGwgJiYgX3RoaXMkcHN3cCRjdXJyU2xpZGUkICE9PSB2b2lkIDAgPyBfdGhpcyRwc3dwJGN1cnJTbGlkZSQgOiAwKSkgLyAodGhpcy5wc3dwLnZpZXdwb3J0U2l6ZS55IC8gMyk7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0IHBhbiBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBzbGlkZS5cclxuICAgKiBBcHBseSBmcmljdGlvbiBpZiB0aGUgcG9zaXRpb24gaXMgYmV5b25kIHRoZSBwYW4gYm91bmRzLFxyXG4gICAqIG9yIGlmIGN1c3RvbSBmcmljdGlvbiBpcyBkZWZpbmVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0geyd4JyB8ICd5J30gYXhpc1xyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3RlbnRpYWxQYW5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2N1c3RvbUZyaWN0aW9uXSAoMC4xIC0gMSlcclxuICAgKi9cblxuXG4gIF9zZXRQYW5XaXRoRnJpY3Rpb24oYXhpcywgcG90ZW50aWFsUGFuLCBjdXN0b21GcmljdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJTbGlkZVxuICAgIH0gPSB0aGlzLnBzd3A7XG5cbiAgICBpZiAoIWN1cnJTbGlkZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHBhbixcbiAgICAgIGJvdW5kc1xuICAgIH0gPSBjdXJyU2xpZGU7XG4gICAgY29uc3QgY29ycmVjdGVkUGFuID0gYm91bmRzLmNvcnJlY3RQYW4oYXhpcywgcG90ZW50aWFsUGFuKTsgLy8gSWYgd2UgYXJlIG91dCBvZiBwYW4gYm91bmRzXG5cbiAgICBpZiAoY29ycmVjdGVkUGFuICE9PSBwb3RlbnRpYWxQYW4gfHwgY3VzdG9tRnJpY3Rpb24pIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5yb3VuZChwb3RlbnRpYWxQYW4gLSBwYW5bYXhpc10pO1xuICAgICAgcGFuW2F4aXNdICs9IGRlbHRhICogKGN1c3RvbUZyaWN0aW9uIHx8IFBBTl9FTkRfRlJJQ1RJT04pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYW5bYXhpc10gPSBwb3RlbnRpYWxQYW47XG4gICAgfVxuICB9XG5cbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vZ2VzdHVyZXMuanMnKS5kZWZhdWx0fSBHZXN0dXJlcyAqL1xuXG5jb25zdCBVUFBFUl9aT09NX0ZSSUNUSU9OID0gMC4wNTtcbmNvbnN0IExPV0VSX1pPT01fRlJJQ1RJT04gPSAwLjE1O1xuLyoqXHJcbiAqIEdldCBjZW50ZXIgcG9pbnQgYmV0d2VlbiB0d28gcG9pbnRzXHJcbiAqXHJcbiAqIEBwYXJhbSB7UG9pbnR9IHBcclxuICogQHBhcmFtIHtQb2ludH0gcDFcclxuICogQHBhcmFtIHtQb2ludH0gcDJcclxuICogQHJldHVybnMge1BvaW50fVxyXG4gKi9cblxuZnVuY3Rpb24gZ2V0Wm9vbVBvaW50c0NlbnRlcihwLCBwMSwgcDIpIHtcbiAgcC54ID0gKHAxLnggKyBwMi54KSAvIDI7XG4gIHAueSA9IChwMS55ICsgcDIueSkgLyAyO1xuICByZXR1cm4gcDtcbn1cblxuY2xhc3MgWm9vbUhhbmRsZXIge1xuICAvKipcclxuICAgKiBAcGFyYW0ge0dlc3R1cmVzfSBnZXN0dXJlc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihnZXN0dXJlcykge1xuICAgIHRoaXMuZ2VzdHVyZXMgPSBnZXN0dXJlcztcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuX3N0YXJ0UGFuID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtQb2ludH1cclxuICAgICAqL1xuXG4gICAgdGhpcy5fc3RhcnRab29tUG9pbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXG5cbiAgICB0aGlzLl96b29tUG9pbnQgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9zdGFydFpvb21MZXZlbCA9IDE7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyU2xpZGVcbiAgICB9ID0gdGhpcy5nZXN0dXJlcy5wc3dwO1xuXG4gICAgaWYgKGN1cnJTbGlkZSkge1xuICAgICAgdGhpcy5fc3RhcnRab29tTGV2ZWwgPSBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbDtcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX3N0YXJ0UGFuLCBjdXJyU2xpZGUucGFuKTtcbiAgICB9XG5cbiAgICB0aGlzLmdlc3R1cmVzLnBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsUGFuKCk7XG4gICAgdGhpcy5fd2FzT3ZlckZpdFpvb21MZXZlbCA9IGZhbHNlO1xuICB9XG5cbiAgY2hhbmdlKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHAxLFxuICAgICAgc3RhcnRQMSxcbiAgICAgIHAyLFxuICAgICAgc3RhcnRQMixcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcy5nZXN0dXJlcztcbiAgICBjb25zdCB7XG4gICAgICBjdXJyU2xpZGVcbiAgICB9ID0gcHN3cDtcblxuICAgIGlmICghY3VyclNsaWRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWluWm9vbUxldmVsID0gY3VyclNsaWRlLnpvb21MZXZlbHMubWluO1xuICAgIGNvbnN0IG1heFpvb21MZXZlbCA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heDtcblxuICAgIGlmICghY3VyclNsaWRlLmlzWm9vbWFibGUoKSB8fCBwc3dwLm1haW5TY3JvbGwuaXNTaGlmdGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBnZXRab29tUG9pbnRzQ2VudGVyKHRoaXMuX3N0YXJ0Wm9vbVBvaW50LCBzdGFydFAxLCBzdGFydFAyKTtcbiAgICBnZXRab29tUG9pbnRzQ2VudGVyKHRoaXMuX3pvb21Qb2ludCwgcDEsIHAyKTtcblxuICAgIGxldCBjdXJyWm9vbUxldmVsID0gMSAvIGdldERpc3RhbmNlQmV0d2VlbihzdGFydFAxLCBzdGFydFAyKSAqIGdldERpc3RhbmNlQmV0d2VlbihwMSwgcDIpICogdGhpcy5fc3RhcnRab29tTGV2ZWw7IC8vIHNsaWdodGx5IG92ZXIgdGhlIHpvb20uZml0XG5cblxuICAgIGlmIChjdXJyWm9vbUxldmVsID4gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCArIGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwgLyAxNSkge1xuICAgICAgdGhpcy5fd2FzT3ZlckZpdFpvb21MZXZlbCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJab29tTGV2ZWwgPCBtaW5ab29tTGV2ZWwpIHtcbiAgICAgIGlmIChwc3dwLm9wdGlvbnMucGluY2hUb0Nsb3NlICYmICF0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsICYmIHRoaXMuX3N0YXJ0Wm9vbUxldmVsIDw9IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwpIHtcbiAgICAgICAgLy8gZmFkZSBvdXQgYmFja2dyb3VuZCBpZiB6b29taW5nIG91dFxuICAgICAgICBjb25zdCBiZ09wYWNpdHkgPSAxIC0gKG1pblpvb21MZXZlbCAtIGN1cnJab29tTGV2ZWwpIC8gKG1pblpvb21MZXZlbCAvIDEuMik7XG5cbiAgICAgICAgaWYgKCFwc3dwLmRpc3BhdGNoKCdwaW5jaENsb3NlJywge1xuICAgICAgICAgIGJnT3BhY2l0eVxuICAgICAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgcHN3cC5hcHBseUJnT3BhY2l0eShiZ09wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBcHBseSB0aGUgZnJpY3Rpb24gaWYgem9vbSBsZXZlbCBpcyBiZWxvdyB0aGUgbWluXG4gICAgICAgIGN1cnJab29tTGV2ZWwgPSBtaW5ab29tTGV2ZWwgLSAobWluWm9vbUxldmVsIC0gY3Vyclpvb21MZXZlbCkgKiBMT1dFUl9aT09NX0ZSSUNUSU9OO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3Vyclpvb21MZXZlbCA+IG1heFpvb21MZXZlbCkge1xuICAgICAgLy8gQXBwbHkgdGhlIGZyaWN0aW9uIGlmIHpvb20gbGV2ZWwgaXMgYWJvdmUgdGhlIG1heFxuICAgICAgY3Vyclpvb21MZXZlbCA9IG1heFpvb21MZXZlbCArIChjdXJyWm9vbUxldmVsIC0gbWF4Wm9vbUxldmVsKSAqIFVQUEVSX1pPT01fRlJJQ1RJT047XG4gICAgfVxuXG4gICAgY3VyclNsaWRlLnBhbi54ID0gdGhpcy5fY2FsY3VsYXRlUGFuRm9yWm9vbUxldmVsKCd4JywgY3Vyclpvb21MZXZlbCk7XG4gICAgY3VyclNsaWRlLnBhbi55ID0gdGhpcy5fY2FsY3VsYXRlUGFuRm9yWm9vbUxldmVsKCd5JywgY3Vyclpvb21MZXZlbCk7XG4gICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChjdXJyWm9vbUxldmVsKTtcbiAgICBjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICB9XG5cbiAgZW5kKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcy5nZXN0dXJlcztcbiAgICBjb25zdCB7XG4gICAgICBjdXJyU2xpZGVcbiAgICB9ID0gcHN3cDtcblxuICAgIGlmICgoIWN1cnJTbGlkZSB8fCBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA8IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwpICYmICF0aGlzLl93YXNPdmVyRml0Wm9vbUxldmVsICYmIHBzd3Aub3B0aW9ucy5waW5jaFRvQ2xvc2UpIHtcbiAgICAgIHBzd3AuY2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb3JyZWN0Wm9vbVBhbigpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJab29tTGV2ZWxcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgX2NhbGN1bGF0ZVBhbkZvclpvb21MZXZlbChheGlzLCBjdXJyWm9vbUxldmVsKSB7XG4gICAgY29uc3Qgem9vbUZhY3RvciA9IGN1cnJab29tTGV2ZWwgLyB0aGlzLl9zdGFydFpvb21MZXZlbDtcbiAgICByZXR1cm4gdGhpcy5fem9vbVBvaW50W2F4aXNdIC0gKHRoaXMuX3N0YXJ0Wm9vbVBvaW50W2F4aXNdIC0gdGhpcy5fc3RhcnRQYW5bYXhpc10pICogem9vbUZhY3RvcjtcbiAgfVxuICAvKipcclxuICAgKiBDb3JyZWN0IGN1cnJab29tTGV2ZWwgYW5kIHBhbiBpZiB0aGV5IGFyZVxyXG4gICAqIGJleW9uZCBtaW5pbXVtIG9yIG1heGltdW0gdmFsdWVzLlxyXG4gICAqIFdpdGggYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbaWdub3JlR2VzdHVyZV1cclxuICAgKiBXZXRoZXIgZ2VzdHVyZSBjb29yZGluYXRlcyBzaG91bGQgYmUgaWdub3JlZCB3aGVuIGNhbGN1bGF0aW5nIGRlc3RpbmF0aW9uIHBhbiBwb3NpdGlvbi5cclxuICAgKi9cblxuXG4gIGNvcnJlY3Rab29tUGFuKGlnbm9yZUdlc3R1cmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXMuZ2VzdHVyZXM7XG4gICAgY29uc3Qge1xuICAgICAgY3VyclNsaWRlXG4gICAgfSA9IHBzd3A7XG5cbiAgICBpZiAoIShjdXJyU2xpZGUgIT09IG51bGwgJiYgY3VyclNsaWRlICE9PSB2b2lkIDAgJiYgY3VyclNsaWRlLmlzWm9vbWFibGUoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fem9vbVBvaW50LnggPT09IDApIHtcbiAgICAgIGlnbm9yZUdlc3R1cmUgPSB0cnVlO1xuICAgIH1cblxuICAgIGNvbnN0IHByZXZab29tTGV2ZWwgPSBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbDtcbiAgICAvKiogQHR5cGUge251bWJlcn0gKi9cblxuICAgIGxldCBkZXN0aW5hdGlvblpvb21MZXZlbDtcbiAgICBsZXQgY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlID0gdHJ1ZTtcblxuICAgIGlmIChwcmV2Wm9vbUxldmVsIDwgY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCkge1xuICAgICAgZGVzdGluYXRpb25ab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsOyAvLyB6b29tIHRvIG1pblxuICAgIH0gZWxzZSBpZiAocHJldlpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLm1heCkge1xuICAgICAgZGVzdGluYXRpb25ab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5tYXg7IC8vIHpvb20gdG8gbWF4XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJab29tTGV2ZWxOZWVkc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgZGVzdGluYXRpb25ab29tTGV2ZWwgPSBwcmV2Wm9vbUxldmVsO1xuICAgIH1cblxuICAgIGNvbnN0IGluaXRpYWxCZ09wYWNpdHkgPSBwc3dwLmJnT3BhY2l0eTtcbiAgICBjb25zdCByZXN0b3JlQmdPcGFjaXR5ID0gcHN3cC5iZ09wYWNpdHkgPCAxO1xuICAgIGNvbnN0IGluaXRpYWxQYW4gPSBlcXVhbGl6ZVBvaW50cyh7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH0sIGN1cnJTbGlkZS5wYW4pO1xuICAgIGxldCBkZXN0aW5hdGlvblBhbiA9IGVxdWFsaXplUG9pbnRzKHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSwgaW5pdGlhbFBhbik7XG5cbiAgICBpZiAoaWdub3JlR2VzdHVyZSkge1xuICAgICAgdGhpcy5fem9vbVBvaW50LnggPSAwO1xuICAgICAgdGhpcy5fem9vbVBvaW50LnkgPSAwO1xuICAgICAgdGhpcy5fc3RhcnRab29tUG9pbnQueCA9IDA7XG4gICAgICB0aGlzLl9zdGFydFpvb21Qb2ludC55ID0gMDtcbiAgICAgIHRoaXMuX3N0YXJ0Wm9vbUxldmVsID0gcHJldlpvb21MZXZlbDtcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX3N0YXJ0UGFuLCBpbml0aWFsUGFuKTtcbiAgICB9XG5cbiAgICBpZiAoY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlKSB7XG4gICAgICBkZXN0aW5hdGlvblBhbiA9IHtcbiAgICAgICAgeDogdGhpcy5fY2FsY3VsYXRlUGFuRm9yWm9vbUxldmVsKCd4JywgZGVzdGluYXRpb25ab29tTGV2ZWwpLFxuICAgICAgICB5OiB0aGlzLl9jYWxjdWxhdGVQYW5Gb3Jab29tTGV2ZWwoJ3knLCBkZXN0aW5hdGlvblpvb21MZXZlbClcbiAgICAgIH07XG4gICAgfSAvLyBzZXQgem9vbSBsZXZlbCwgc28gcGFuIGJvdW5kcyBhcmUgdXBkYXRlZCBhY2NvcmRpbmcgdG8gaXRcblxuXG4gICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChkZXN0aW5hdGlvblpvb21MZXZlbCk7XG4gICAgZGVzdGluYXRpb25QYW4gPSB7XG4gICAgICB4OiBjdXJyU2xpZGUuYm91bmRzLmNvcnJlY3RQYW4oJ3gnLCBkZXN0aW5hdGlvblBhbi54KSxcbiAgICAgIHk6IGN1cnJTbGlkZS5ib3VuZHMuY29ycmVjdFBhbigneScsIGRlc3RpbmF0aW9uUGFuLnkpXG4gICAgfTsgLy8gcmV0dXJuIHpvb20gbGV2ZWwgYW5kIGl0cyBib3VuZHMgdG8gaW5pdGlhbFxuXG4gICAgY3VyclNsaWRlLnNldFpvb21MZXZlbChwcmV2Wm9vbUxldmVsKTtcbiAgICBjb25zdCBwYW5OZWVkc0NoYW5nZSA9ICFwb2ludHNFcXVhbChkZXN0aW5hdGlvblBhbiwgaW5pdGlhbFBhbik7XG5cbiAgICBpZiAoIXBhbk5lZWRzQ2hhbmdlICYmICFjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UgJiYgIXJlc3RvcmVCZ09wYWNpdHkpIHtcbiAgICAgIC8vIHVwZGF0ZSByZXNvbHV0aW9uIGFmdGVyIGdlc3R1cmVcbiAgICAgIGN1cnJTbGlkZS5fc2V0UmVzb2x1dGlvbihkZXN0aW5hdGlvblpvb21MZXZlbCk7XG5cbiAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7IC8vIG5vdGhpbmcgdG8gYW5pbWF0ZVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RhcnRTcHJpbmcoe1xuICAgICAgaXNQYW46IHRydWUsXG4gICAgICBzdGFydDogMCxcbiAgICAgIGVuZDogMTAwMCxcbiAgICAgIHZlbG9jaXR5OiAwLFxuICAgICAgZGFtcGluZ1JhdGlvOiAxLFxuICAgICAgbmF0dXJhbEZyZXF1ZW5jeTogNDAsXG4gICAgICBvblVwZGF0ZTogbm93ID0+IHtcbiAgICAgICAgbm93IC89IDEwMDA7IC8vIDAgLSBzdGFydCwgMSAtIGVuZFxuXG4gICAgICAgIGlmIChwYW5OZWVkc0NoYW5nZSB8fCBjdXJyWm9vbUxldmVsTmVlZHNDaGFuZ2UpIHtcbiAgICAgICAgICBpZiAocGFuTmVlZHNDaGFuZ2UpIHtcbiAgICAgICAgICAgIGN1cnJTbGlkZS5wYW4ueCA9IGluaXRpYWxQYW4ueCArIChkZXN0aW5hdGlvblBhbi54IC0gaW5pdGlhbFBhbi54KSAqIG5vdztcbiAgICAgICAgICAgIGN1cnJTbGlkZS5wYW4ueSA9IGluaXRpYWxQYW4ueSArIChkZXN0aW5hdGlvblBhbi55IC0gaW5pdGlhbFBhbi55KSAqIG5vdztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3Vyclpvb21MZXZlbE5lZWRzQ2hhbmdlKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdab29tTGV2ZWwgPSBwcmV2Wm9vbUxldmVsICsgKGRlc3RpbmF0aW9uWm9vbUxldmVsIC0gcHJldlpvb21MZXZlbCkgKiBub3c7XG4gICAgICAgICAgICBjdXJyU2xpZGUuc2V0Wm9vbUxldmVsKG5ld1pvb21MZXZlbCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY3VyclNsaWRlLmFwcGx5Q3VycmVudFpvb21QYW4oKTtcbiAgICAgICAgfSAvLyBSZXN0b3JlIGJhY2tncm91bmQgb3BhY2l0eVxuXG5cbiAgICAgICAgaWYgKHJlc3RvcmVCZ09wYWNpdHkgJiYgcHN3cC5iZ09wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgLy8gV2UgY2xhbXAgb3BhY2l0eSB0byBrZWVwIGl0IGJldHdlZW4gMCBhbmQgMS5cbiAgICAgICAgICAvLyBBcyBwcm9ncmVzcyByYXRpbyBjYW4gYmUgbGFyZ2VyIHRoYW4gMSBkdWUgdG8gb3ZlcnNob290LFxuICAgICAgICAgIC8vIGFuZCB3ZSBkbyBub3Qgd2FudCB0byBib3VuY2Ugb3BhY2l0eS5cbiAgICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KGNsYW1wKGluaXRpYWxCZ09wYWNpdHkgKyAoMSAtIGluaXRpYWxCZ09wYWNpdHkpICogbm93LCAwLCAxKSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgIC8vIHVwZGF0ZSByZXNvbHV0aW9uIGFmdGVyIHRyYW5zaXRpb24gZW5kc1xuICAgICAgICBjdXJyU2xpZGUuX3NldFJlc29sdXRpb24oZGVzdGluYXRpb25ab29tTGV2ZWwpO1xuXG4gICAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufVxuXG4vKipcclxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFRcclxuICogQHRlbXBsYXRlIHtzdHJpbmd9IFBcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5BZGRQb3N0Zml4PFQsIFA+fSBBZGRQb3N0Zml4PFQsIFA+XHJcbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9nZXN0dXJlcy5qcycpLmRlZmF1bHR9IEdlc3R1cmVzICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuUG9pbnR9IFBvaW50ICovXG5cbi8qKiBAdHlwZWRlZiB7J2ltYWdlQ2xpY2snIHwgJ2JnQ2xpY2snIHwgJ3RhcCcgfCAnZG91YmxlVGFwJ30gQWN0aW9ucyAqL1xuXG4vKipcclxuICogV2hldGhlciB0aGUgdGFwIHdhcyBwZXJmb3JtZWQgb24gdGhlIG1haW4gc2xpZGVcclxuICogKHJhdGhlciB0aGFuIGNvbnRyb2xzIG9yIGNhcHRpb24pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZXZlbnRcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xuZnVuY3Rpb24gZGlkVGFwT25NYWluQ29udGVudChldmVudCkge1xuICByZXR1cm4gISFcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgZXZlbnQudGFyZ2V0LmNsb3Nlc3QoJy5wc3dwX19jb250YWluZXInKTtcbn1cbi8qKlxyXG4gKiBUYXAsIGRvdWJsZS10YXAgaGFuZGxlci5cclxuICovXG5cblxuY2xhc3MgVGFwSGFuZGxlciB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7R2VzdHVyZXN9IGdlc3R1cmVzXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdlc3R1cmVzKSB7XG4gICAgdGhpcy5nZXN0dXJlcyA9IGdlc3R1cmVzO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnRcclxuICAgKi9cblxuXG4gIGNsaWNrKHBvaW50LCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0Q2xhc3NMaXN0ID1cbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqL1xuICAgIG9yaWdpbmFsRXZlbnQudGFyZ2V0LmNsYXNzTGlzdDtcbiAgICBjb25zdCBpc0ltYWdlQ2xpY2sgPSB0YXJnZXRDbGFzc0xpc3QuY29udGFpbnMoJ3Bzd3BfX2ltZycpO1xuICAgIGNvbnN0IGlzQmFja2dyb3VuZENsaWNrID0gdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX19pdGVtJykgfHwgdGFyZ2V0Q2xhc3NMaXN0LmNvbnRhaW5zKCdwc3dwX196b29tLXdyYXAnKTtcblxuICAgIGlmIChpc0ltYWdlQ2xpY2spIHtcbiAgICAgIHRoaXMuX2RvQ2xpY2tPclRhcEFjdGlvbignaW1hZ2VDbGljaycsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcbiAgICB9IGVsc2UgaWYgKGlzQmFja2dyb3VuZENsaWNrKSB7XG4gICAgICB0aGlzLl9kb0NsaWNrT3JUYXBBY3Rpb24oJ2JnQ2xpY2snLCBwb2ludCwgb3JpZ2luYWxFdmVudCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnRcclxuICAgKi9cblxuXG4gIHRhcChwb2ludCwgb3JpZ2luYWxFdmVudCkge1xuICAgIGlmIChkaWRUYXBPbk1haW5Db250ZW50KG9yaWdpbmFsRXZlbnQpKSB7XG4gICAgICB0aGlzLl9kb0NsaWNrT3JUYXBBY3Rpb24oJ3RhcCcsIHBvaW50LCBvcmlnaW5hbEV2ZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gb3JpZ2luYWxFdmVudFxyXG4gICAqL1xuXG5cbiAgZG91YmxlVGFwKHBvaW50LCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgaWYgKGRpZFRhcE9uTWFpbkNvbnRlbnQob3JpZ2luYWxFdmVudCkpIHtcbiAgICAgIHRoaXMuX2RvQ2xpY2tPclRhcEFjdGlvbignZG91YmxlVGFwJywgcG9pbnQsIG9yaWdpbmFsRXZlbnQpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7QWN0aW9uc30gYWN0aW9uTmFtZVxyXG4gICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IG9yaWdpbmFsRXZlbnRcclxuICAgKi9cblxuXG4gIF9kb0NsaWNrT3JUYXBBY3Rpb24oYWN0aW9uTmFtZSwgcG9pbnQsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICB2YXIgX3RoaXMkZ2VzdHVyZXMkcHN3cCRlO1xuXG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzLmdlc3R1cmVzO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJTbGlkZVxuICAgIH0gPSBwc3dwO1xuICAgIGNvbnN0IGFjdGlvbkZ1bGxOYW1lID1cbiAgICAvKiogQHR5cGUge0FkZFBvc3RmaXg8QWN0aW9ucywgJ0FjdGlvbic+fSAqL1xuICAgIGFjdGlvbk5hbWUgKyAnQWN0aW9uJztcbiAgICBjb25zdCBvcHRpb25WYWx1ZSA9IHBzd3Aub3B0aW9uc1thY3Rpb25GdWxsTmFtZV07XG5cbiAgICBpZiAocHN3cC5kaXNwYXRjaChhY3Rpb25GdWxsTmFtZSwge1xuICAgICAgcG9pbnQsXG4gICAgICBvcmlnaW5hbEV2ZW50XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9uVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvblZhbHVlLmNhbGwocHN3cCwgcG9pbnQsIG9yaWdpbmFsRXZlbnQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN3aXRjaCAob3B0aW9uVmFsdWUpIHtcbiAgICAgIGNhc2UgJ2Nsb3NlJzpcbiAgICAgIGNhc2UgJ25leHQnOlxuICAgICAgICBwc3dwW29wdGlvblZhbHVlXSgpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnem9vbSc6XG4gICAgICAgIGN1cnJTbGlkZSA9PT0gbnVsbCB8fCBjdXJyU2xpZGUgPT09IHZvaWQgMCB8fCBjdXJyU2xpZGUudG9nZ2xlWm9vbShwb2ludCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICd6b29tLW9yLWNsb3NlJzpcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBjbGljayB6b29tcyBjdXJyZW50IGltYWdlLFxuICAgICAgICAvLyBpZiBpdCBjYW4gbm90IGJlIHpvb21lZCAtIGdhbGxlcnkgd2lsbCBiZSBjbG9zZWRcbiAgICAgICAgaWYgKGN1cnJTbGlkZSAhPT0gbnVsbCAmJiBjdXJyU2xpZGUgIT09IHZvaWQgMCAmJiBjdXJyU2xpZGUuaXNab29tYWJsZSgpICYmIGN1cnJTbGlkZS56b29tTGV2ZWxzLnNlY29uZGFyeSAhPT0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCkge1xuICAgICAgICAgIGN1cnJTbGlkZS50b2dnbGVab29tKHBvaW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChwc3dwLm9wdGlvbnMuY2xpY2tUb0Nsb3NlTm9uWm9vbWFibGUpIHtcbiAgICAgICAgICBwc3dwLmNsb3NlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAndG9nZ2xlLWNvbnRyb2xzJzpcbiAgICAgICAgKF90aGlzJGdlc3R1cmVzJHBzd3AkZSA9IHRoaXMuZ2VzdHVyZXMucHN3cC5lbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRnZXN0dXJlcyRwc3dwJGUgPT09IHZvaWQgMCB8fCBfdGhpcyRnZXN0dXJlcyRwc3dwJGUuY2xhc3NMaXN0LnRvZ2dsZSgncHN3cC0tdWktdmlzaWJsZScpOyAvLyBpZiAoX2NvbnRyb2xzVmlzaWJsZSkge1xuICAgICAgICAvLyAgIF91aS5oaWRlQ29udHJvbHMoKTtcbiAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgLy8gICBfdWkuc2hvd0NvbnRyb2xzKCk7XG4gICAgICAgIC8vIH1cblxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5Qb2ludH0gUG9pbnQgKi9cbi8vIEhvdyBmYXIgc2hvdWxkIHVzZXIgc2hvdWxkIGRyYWdcbi8vIHVudGlsIHdlIGNhbiBkZXRlcm1pbmUgdGhhdCB0aGUgZ2VzdHVyZSBpcyBzd2lwZSBhbmQgaXRzIGRpcmVjdGlvblxuXG5jb25zdCBBWElTX1NXSVBFX0hZU1RFUklTSVMgPSAxMDsgLy9jb25zdCBQQU5fRU5EX0ZSSUNUSU9OID0gMC4zNTtcblxuY29uc3QgRE9VQkxFX1RBUF9ERUxBWSA9IDMwMDsgLy8gbXNcblxuY29uc3QgTUlOX1RBUF9ESVNUQU5DRSA9IDI1OyAvLyBweFxuXG4vKipcclxuICogR2VzdHVyZXMgY2xhc3MgYmluZCB0b3VjaCwgcG9pbnRlciBvciBtb3VzZSBldmVudHNcclxuICogYW5kIGVtaXRzIGRyYWcgdG8gZHJhZy1oYW5kbGVyIGFuZCB6b29tIGV2ZW50cyB6b29tLWhhbmRsZXIuXHJcbiAqXHJcbiAqIERyYWcgYW5kIHpvb20gZXZlbnRzIGFyZSBlbWl0ZWQgaW4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLFxyXG4gKiBhbmQgb25seSB3aGVuIG9uZSBvZiBwb2ludGVycyB3YXMgYWN0dWFsbHkgY2hhbmdlZC5cclxuICovXG5cbmNsYXNzIEdlc3R1cmVzIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xuICAgIC8qKiBAdHlwZSB7J3gnIHwgJ3knIHwgbnVsbH0gKi9cblxuICAgIHRoaXMuZHJhZ0F4aXMgPSBudWxsOyAvLyBwb2ludCBvYmplY3RzIGFyZSBkZWZpbmVkIG9uY2UgYW5kIHJldXNlZFxuICAgIC8vIFBob3RvU3dpcGUga2VlcHMgdHJhY2sgb25seSBvZiB0d28gcG9pbnRlcnMsIG90aGVycyBhcmUgaWdub3JlZFxuXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cblxuICAgIHRoaXMucDEgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07IC8vIHRoZSBmaXJzdCBwcmVzc2VkIHBvaW50ZXJcblxuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG5cbiAgICB0aGlzLnAyID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9OyAvLyB0aGUgc2Vjb25kIHByZXNzZWQgcG9pbnRlclxuXG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cblxuICAgIHRoaXMucHJldlAxID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG5cbiAgICB0aGlzLnByZXZQMiA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICAvKiogQHR5cGUge1BvaW50fSAqL1xuXG4gICAgdGhpcy5zdGFydFAxID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7UG9pbnR9ICovXG5cbiAgICB0aGlzLnN0YXJ0UDIgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtQb2ludH0gKi9cblxuICAgIHRoaXMudmVsb2NpdHkgPSB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMFxuICAgIH07XG4gICAgLyoqIEB0eXBlIHtQb2ludH1cclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cblxuICAgIHRoaXMuX2xhc3RTdGFydFAxID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKiBAdHlwZSB7UG9pbnR9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG5cbiAgICB0aGlzLl9pbnRlcnZhbFAxID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzID0gMDtcbiAgICAvKiogQHR5cGUge1BvaW50W119XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG5cbiAgICB0aGlzLl9vbmdvaW5nUG9pbnRlcnMgPSBbXTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX3RvdWNoRXZlbnRFbmFibGVkID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgdGhpcy5fcG9pbnRlckV2ZW50RW5hYmxlZCA9ICEhd2luZG93LlBvaW50ZXJFdmVudDtcbiAgICB0aGlzLnN1cHBvcnRzVG91Y2ggPSB0aGlzLl90b3VjaEV2ZW50RW5hYmxlZCB8fCB0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkICYmIG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDE7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9udW1BY3RpdmVQb2ludHMgPSAwO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgdGhpcy5faW50ZXJ2YWxUaW1lID0gMDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX3ZlbG9jaXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMuaXNNdWx0aXRvdWNoID0gZmFsc2U7XG4gICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc1pvb21pbmcgPSBmYWxzZTtcbiAgICAvKiogQHR5cGUge251bWJlciB8IG51bGx9ICovXG5cbiAgICB0aGlzLnJhZiA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtOb2RlSlMuVGltZW91dCB8IG51bGx9XHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICovXG5cbiAgICB0aGlzLl90YXBUaW1lciA9IG51bGw7XG5cbiAgICBpZiAoIXRoaXMuc3VwcG9ydHNUb3VjaCkge1xuICAgICAgLy8gZGlzYWJsZSBwYW4gdG8gbmV4dCBzbGlkZSBmb3Igbm9uLXRvdWNoIGRldmljZXNcbiAgICAgIHBzd3Aub3B0aW9ucy5hbGxvd1BhblRvTmV4dCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZHJhZyA9IG5ldyBEcmFnSGFuZGxlcih0aGlzKTtcbiAgICB0aGlzLnpvb21MZXZlbHMgPSBuZXcgWm9vbUhhbmRsZXIodGhpcyk7XG4gICAgdGhpcy50YXBIYW5kbGVyID0gbmV3IFRhcEhhbmRsZXIodGhpcyk7XG4gICAgcHN3cC5vbignYmluZEV2ZW50cycsICgpID0+IHtcbiAgICAgIHBzd3AuZXZlbnRzLmFkZChwc3dwLnNjcm9sbFdyYXAsICdjbGljaycsXG4gICAgICAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqL1xuICAgICAgdGhpcy5fb25DbGljay5iaW5kKHRoaXMpKTtcblxuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudEVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fYmluZEV2ZW50cygncG9pbnRlcicsICdkb3duJywgJ3VwJywgJ2NhbmNlbCcpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl90b3VjaEV2ZW50RW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9iaW5kRXZlbnRzKCd0b3VjaCcsICdzdGFydCcsICdlbmQnLCAnY2FuY2VsJyk7IC8vIEluIHByZXZpb3VzIHZlcnNpb25zIHdlIGFsc28gYm91bmQgbW91c2UgZXZlbnQgaGVyZSxcbiAgICAgICAgLy8gaW4gY2FzZSBkZXZpY2Ugc3VwcG9ydHMgYm90aCB0b3VjaCBhbmQgbW91c2UgZXZlbnRzLFxuICAgICAgICAvLyBidXQgbmV3ZXIgdmVyc2lvbnMgb2YgYnJvd3NlcnMgbm93IHN1cHBvcnQgUG9pbnRlckV2ZW50LlxuICAgICAgICAvLyBvbiBpT1MxMCBpZiB5b3UgYmluZCB0b3VjaG1vdmUvZW5kIGFmdGVyIHRvdWNoc3RhcnQsXG4gICAgICAgIC8vIGFuZCB5b3UgZG9uJ3QgcHJldmVudERlZmF1bHQgdG91Y2hzdGFydCAod2hpY2ggUGhvdG9Td2lwZSBkb2VzKSxcbiAgICAgICAgLy8gcHJldmVudERlZmF1bHQgd2lsbCBoYXZlIG5vIGVmZmVjdCBvbiB0b3VjaG1vdmUgYW5kIHRvdWNoZW5kLlxuICAgICAgICAvLyBVbmxlc3MgeW91IGJpbmQgaXQgcHJldmlvdXNseS5cblxuXG4gICAgICAgIGlmIChwc3dwLnNjcm9sbFdyYXApIHtcbiAgICAgICAgICBwc3dwLnNjcm9sbFdyYXAub250b3VjaG1vdmUgPSAoKSA9PiB7fTtcblxuICAgICAgICAgIHBzd3Auc2Nyb2xsV3JhcC5vbnRvdWNoZW5kID0gKCkgPT4ge307XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2JpbmRFdmVudHMoJ21vdXNlJywgJ2Rvd24nLCAndXAnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J21vdXNlJyB8ICd0b3VjaCcgfCAncG9pbnRlcid9IHByZWZcclxuICAgKiBAcGFyYW0geydkb3duJyB8ICdzdGFydCd9IGRvd25cclxuICAgKiBAcGFyYW0geyd1cCcgfCAnZW5kJ30gdXBcclxuICAgKiBAcGFyYW0geydjYW5jZWwnfSBbY2FuY2VsXVxyXG4gICAqL1xuXG5cbiAgX2JpbmRFdmVudHMocHJlZiwgZG93biwgdXAsIGNhbmNlbCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBldmVudHNcbiAgICB9ID0gcHN3cDtcbiAgICBjb25zdCBjYW5jZWxFdmVudCA9IGNhbmNlbCA/IHByZWYgKyBjYW5jZWwgOiAnJztcbiAgICBldmVudHMuYWRkKHBzd3Auc2Nyb2xsV3JhcCwgcHJlZiArIGRvd24sXG4gICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi9cbiAgICB0aGlzLm9uUG9pbnRlckRvd24uYmluZCh0aGlzKSk7XG4gICAgZXZlbnRzLmFkZCh3aW5kb3csIHByZWYgKyAnbW92ZScsXG4gICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi9cbiAgICB0aGlzLm9uUG9pbnRlck1vdmUuYmluZCh0aGlzKSk7XG4gICAgZXZlbnRzLmFkZCh3aW5kb3csIHByZWYgKyB1cCxcbiAgICAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqL1xuICAgIHRoaXMub25Qb2ludGVyVXAuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAoY2FuY2VsRXZlbnQpIHtcbiAgICAgIGV2ZW50cy5hZGQocHN3cC5zY3JvbGxXcmFwLCBjYW5jZWxFdmVudCxcbiAgICAgIC8qKiBAdHlwZSBFdmVudExpc3RlbmVyICovXG4gICAgICB0aGlzLm9uUG9pbnRlclVwLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZVxyXG4gICAqL1xuXG5cbiAgb25Qb2ludGVyRG93bihlKSB7XG4gICAgLy8gV2UgZG8gbm90IGNhbGwgcHJldmVudERlZmF1bHQgZm9yIHRvdWNoIGV2ZW50c1xuICAgIC8vIHRvIGFsbG93IGJyb3dzZXIgdG8gc2hvdyBuYXRpdmUgZGlhbG9nIG9uIGxvbmdwcmVzc1xuICAgIC8vICh0aGUgb25lIHRoYXQgYWxsb3dzIHRvIHNhdmUgaW1hZ2Ugb3Igb3BlbiBpdCBpbiBuZXcgdGFiKS5cbiAgICAvL1xuICAgIC8vIERlc2t0b3AgU2FmYXJpIGFsbG93cyB0byBkcmFnIGltYWdlcyB3aGVuIHByZXZlbnREZWZhdWx0IGlzbid0IGNhbGxlZCBvbiBtb3VzZWRvd24sXG4gICAgLy8gZXZlbiB0aG91Z2ggcHJldmVudERlZmF1bHQgSVMgY2FsbGVkIG9uIG1vdXNlbW92ZS4gVGhhdCdzIHdoeSB3ZSBwcmV2ZW50RGVmYXVsdCBtb3VzZWRvd24uXG4gICAgY29uc3QgaXNNb3VzZVBvaW50ZXIgPSBlLnR5cGUgPT09ICdtb3VzZWRvd24nIHx8IGUucG9pbnRlclR5cGUgPT09ICdtb3VzZSc7IC8vIEFsbG93IGRyYWdnaW5nIG9ubHkgdmlhIGxlZnQgbW91c2UgYnV0dG9uLlxuICAgIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ldmVudC5idXR0b25cblxuICAgIGlmIChpc01vdXNlUG9pbnRlciAmJiBlLmJ1dHRvbiA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7IC8vIGlmIFBob3RvU3dpcGUgaXMgb3BlbmluZyBvciBjbG9zaW5nXG5cbiAgICBpZiAoIXBzd3Aub3BlbmVyLmlzT3Blbikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChwc3dwLmRpc3BhdGNoKCdwb2ludGVyRG93bicsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzTW91c2VQb2ludGVyKSB7XG4gICAgICBwc3dwLm1vdXNlRGV0ZWN0ZWQoKTsgLy8gcHJldmVudERlZmF1bHQgbW91c2UgZXZlbnQgdG8gcHJldmVudFxuICAgICAgLy8gYnJvd3NlciBpbWFnZSBkcmFnIGZlYXR1cmVcblxuICAgICAgdGhpcy5fcHJldmVudFBvaW50ZXJFdmVudEJlaGF2aW91cihlLCAnZG93bicpO1xuICAgIH1cblxuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7XG5cbiAgICB0aGlzLl91cGRhdGVQb2ludHMoZSwgJ2Rvd24nKTtcblxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDEpIHtcbiAgICAgIHRoaXMuZHJhZ0F4aXMgPSBudWxsOyAvLyB3ZSBuZWVkIHRvIHN0b3JlIGluaXRpYWwgcG9pbnQgdG8gZGV0ZXJtaW5lIHRoZSBtYWluIGF4aXMsXG4gICAgICAvLyBkcmFnIGlzIGFjdGl2YXRlZCBvbmx5IGFmdGVyIHRoZSBheGlzIGlzIGRldGVybWluZWRcblxuICAgICAgZXF1YWxpemVQb2ludHModGhpcy5zdGFydFAxLCB0aGlzLnAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID4gMSkge1xuICAgICAgLy8gVGFwIG9yIGRvdWJsZSB0YXAgc2hvdWxkIG5vdCB0cmlnZ2VyIGlmIG1vcmUgdGhhbiBvbmUgcG9pbnRlclxuICAgICAgdGhpcy5fY2xlYXJUYXBUaW1lcigpO1xuXG4gICAgICB0aGlzLmlzTXVsdGl0b3VjaCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaXNNdWx0aXRvdWNoID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXG5cblxuICBvblBvaW50ZXJNb3ZlKGUpIHtcbiAgICB0aGlzLl9wcmV2ZW50UG9pbnRlckV2ZW50QmVoYXZpb3VyKGUsICdtb3ZlJyk7XG5cbiAgICBpZiAoIXRoaXMuX251bUFjdGl2ZVBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBvaW50cyhlLCAnbW92ZScpO1xuXG4gICAgaWYgKHRoaXMucHN3cC5kaXNwYXRjaCgncG9pbnRlck1vdmUnLCB7XG4gICAgICBvcmlnaW5hbEV2ZW50OiBlXG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPT09IDEgJiYgIXRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgaWYgKCF0aGlzLmRyYWdBeGlzKSB7XG4gICAgICAgIHRoaXMuX2NhbGN1bGF0ZURyYWdEaXJlY3Rpb24oKTtcbiAgICAgIH0gLy8gRHJhZyBheGlzIHdhcyBkZXRlY3RlZCwgZW1pdCBkcmFnLnN0YXJ0XG5cblxuICAgICAgaWYgKHRoaXMuZHJhZ0F4aXMgJiYgIXRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICBpZiAodGhpcy5pc1pvb21pbmcpIHtcbiAgICAgICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuem9vbUxldmVscy5lbmQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5fY2xlYXJUYXBUaW1lcigpOyAvLyBUYXAgY2FuIG5vdCB0cmlnZ2VyIGFmdGVyIGRyYWdcbiAgICAgICAgLy8gQWRqdXN0IHN0YXJ0aW5nIHBvaW50XG5cblxuICAgICAgICB0aGlzLl91cGRhdGVTdGFydFBvaW50cygpO1xuXG4gICAgICAgIHRoaXMuX2ludGVydmFsVGltZSA9IERhdGUubm93KCk7IC8vdGhpcy5fc3RhcnRUaW1lID0gdGhpcy5faW50ZXJ2YWxUaW1lO1xuXG4gICAgICAgIHRoaXMuX3ZlbG9jaXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLl9pbnRlcnZhbFAxLCB0aGlzLnAxKTtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS54ID0gMDtcbiAgICAgICAgdGhpcy52ZWxvY2l0eS55ID0gMDtcbiAgICAgICAgdGhpcy5kcmFnLnN0YXJ0KCk7XG5cbiAgICAgICAgdGhpcy5fcmFmU3RvcExvb3AoKTtcblxuICAgICAgICB0aGlzLl9yYWZSZW5kZXJMb29wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPiAxICYmICF0aGlzLmlzWm9vbWluZykge1xuICAgICAgdGhpcy5fZmluaXNoRHJhZygpO1xuXG4gICAgICB0aGlzLmlzWm9vbWluZyA9IHRydWU7IC8vIEFkanVzdCBzdGFydGluZyBwb2ludHNcblxuICAgICAgdGhpcy5fdXBkYXRlU3RhcnRQb2ludHMoKTtcblxuICAgICAgdGhpcy56b29tTGV2ZWxzLnN0YXJ0KCk7XG5cbiAgICAgIHRoaXMuX3JhZlN0b3BMb29wKCk7XG5cbiAgICAgIHRoaXMuX3JhZlJlbmRlckxvb3AoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cblxuXG4gIF9maW5pc2hEcmFnKCkge1xuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlOyAvLyBUcnkgdG8gY2FsY3VsYXRlIHZlbG9jaXR5LFxuICAgICAgLy8gaWYgaXQgd2Fzbid0IGNhbGN1bGF0ZWQgeWV0IGluIGRyYWcuY2hhbmdlXG5cbiAgICAgIGlmICghdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZlbG9jaXR5KHRydWUpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmRyYWcuZW5kKCk7XG4gICAgICB0aGlzLmRyYWdBeGlzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGVcclxuICAgKi9cblxuXG4gIG9uUG9pbnRlclVwKGUpIHtcbiAgICBpZiAoIXRoaXMuX251bUFjdGl2ZVBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3VwZGF0ZVBvaW50cyhlLCAndXAnKTtcblxuICAgIGlmICh0aGlzLnBzd3AuZGlzcGF0Y2goJ3BvaW50ZXJVcCcsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA9PT0gMCkge1xuICAgICAgdGhpcy5fcmFmU3RvcExvb3AoKTtcblxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICB0aGlzLl9maW5pc2hEcmFnKCk7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzWm9vbWluZyAmJiAhdGhpcy5pc011bHRpdG91Y2gpIHtcbiAgICAgICAgLy90aGlzLnpvb21MZXZlbHMuY29ycmVjdFpvb21QYW4oKTtcbiAgICAgICAgdGhpcy5fZmluaXNoVGFwKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9udW1BY3RpdmVQb2ludHMgPCAyICYmIHRoaXMuaXNab29taW5nKSB7XG4gICAgICB0aGlzLmlzWm9vbWluZyA9IGZhbHNlO1xuICAgICAgdGhpcy56b29tTGV2ZWxzLmVuZCgpO1xuXG4gICAgICBpZiAodGhpcy5fbnVtQWN0aXZlUG9pbnRzID09PSAxKSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGhhdmUgMSBwb2ludCBsZWZ0LCB3ZSBuZWVkIHRvIHJlaW5pdGlhdGUgZHJhZ1xuICAgICAgICB0aGlzLmRyYWdBeGlzID0gbnVsbDtcblxuICAgICAgICB0aGlzLl91cGRhdGVTdGFydFBvaW50cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG5cbiAgX3JhZlJlbmRlckxvb3AoKSB7XG4gICAgaWYgKHRoaXMuaXNEcmFnZ2luZyB8fCB0aGlzLmlzWm9vbWluZykge1xuICAgICAgdGhpcy5fdXBkYXRlVmVsb2NpdHkoKTtcblxuICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCBwb2ludGVyIG1vdmVkIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZVxuICAgICAgICBpZiAoIXBvaW50c0VxdWFsKHRoaXMucDEsIHRoaXMucHJldlAxKSkge1xuICAgICAgICAgIHRoaXMuZHJhZy5jaGFuZ2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIC8qIGlmICh0aGlzLmlzWm9vbWluZykgKi9cbiAgICAgICAge1xuICAgICAgICAgIGlmICghcG9pbnRzRXF1YWwodGhpcy5wMSwgdGhpcy5wcmV2UDEpIHx8ICFwb2ludHNFcXVhbCh0aGlzLnAyLCB0aGlzLnByZXZQMikpIHtcbiAgICAgICAgICAgIHRoaXMuem9vbUxldmVscy5jaGFuZ2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgdGhpcy5fdXBkYXRlUHJldlBvaW50cygpO1xuXG4gICAgICB0aGlzLnJhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9yYWZSZW5kZXJMb29wLmJpbmQodGhpcykpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgdmVsb2NpdHkgYXQgNTBtcyBpbnRlcnZhbFxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV1cclxuICAgKi9cblxuXG4gIF91cGRhdGVWZWxvY2l0eShmb3JjZSkge1xuICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGR1cmF0aW9uID0gdGltZSAtIHRoaXMuX2ludGVydmFsVGltZTtcblxuICAgIGlmIChkdXJhdGlvbiA8IDUwICYmICFmb3JjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMudmVsb2NpdHkueCA9IHRoaXMuX2dldFZlbG9jaXR5KCd4JywgZHVyYXRpb24pO1xuICAgIHRoaXMudmVsb2NpdHkueSA9IHRoaXMuX2dldFZlbG9jaXR5KCd5JywgZHVyYXRpb24pO1xuICAgIHRoaXMuX2ludGVydmFsVGltZSA9IHRpbWU7XG4gICAgZXF1YWxpemVQb2ludHModGhpcy5faW50ZXJ2YWxQMSwgdGhpcy5wMSk7XG4gICAgdGhpcy5fdmVsb2NpdHlDYWxjdWxhdGVkID0gdHJ1ZTtcbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7UG9pbnRlckV2ZW50fSBlXHJcbiAgICovXG5cblxuICBfZmluaXNoVGFwKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBtYWluU2Nyb2xsXG4gICAgfSA9IHRoaXMucHN3cDsgLy8gRG8gbm90IHRyaWdnZXIgdGFwIGV2ZW50cyBpZiBtYWluIHNjcm9sbCBpcyBzaGlmdGVkXG5cbiAgICBpZiAobWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xuICAgICAgLy8gcmVzdG9yZSBtYWluIHNjcm9sbCBwb3NpdGlvblxuICAgICAgLy8gKHVzdWFsbHkgaGFwcGVucyBpZiBzdG9wcGVkIGluIHRoZSBtaWRkbGUgb2YgYW5pbWF0aW9uKVxuICAgICAgbWFpblNjcm9sbC5tb3ZlSW5kZXhCeSgwLCB0cnVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERvIG5vdCB0cmlnZ2VyIHRhcCBmb3IgdG91Y2hjYW5jZWwgb3IgcG9pbnRlcmNhbmNlbFxuXG5cbiAgICBpZiAoZS50eXBlLmluZGV4T2YoJ2NhbmNlbCcpID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gVHJpZ2dlciBjbGljayBpbnN0ZWFkIG9mIHRhcCBmb3IgbW91c2UgZXZlbnRzXG5cblxuICAgIGlmIChlLnR5cGUgPT09ICdtb3VzZXVwJyB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSB7XG4gICAgICB0aGlzLnRhcEhhbmRsZXIuY2xpY2sodGhpcy5zdGFydFAxLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERpc2FibGUgZGVsYXkgaWYgdGhlcmUgaXMgbm8gZG91YmxlVGFwQWN0aW9uXG5cblxuICAgIGNvbnN0IHRhcERlbGF5ID0gdGhpcy5wc3dwLm9wdGlvbnMuZG91YmxlVGFwQWN0aW9uID8gRE9VQkxFX1RBUF9ERUxBWSA6IDA7IC8vIElmIHRhcFRpbWVyIGlzIGRlZmluZWQgLSB3ZSB0YXBwZWQgcmVjZW50bHksXG4gICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgdGFwIGlzIGNsb3NlIHRvIHRoZSBwcmV2aW91cyBvbmUsXG4gICAgLy8gaWYgeWVzIC0gdHJpZ2dlciBkb3VibGUgdGFwXG5cbiAgICBpZiAodGhpcy5fdGFwVGltZXIpIHtcbiAgICAgIHRoaXMuX2NsZWFyVGFwVGltZXIoKTsgLy8gQ2hlY2sgaWYgdHdvIHRhcHMgd2VyZSBtb3JlIG9yIGxlc3Mgb24gdGhlIHNhbWUgcGxhY2VcblxuXG4gICAgICBpZiAoZ2V0RGlzdGFuY2VCZXR3ZWVuKHRoaXMuX2xhc3RTdGFydFAxLCB0aGlzLnN0YXJ0UDEpIDwgTUlOX1RBUF9ESVNUQU5DRSkge1xuICAgICAgICB0aGlzLnRhcEhhbmRsZXIuZG91YmxlVGFwKHRoaXMuc3RhcnRQMSwgZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX2xhc3RTdGFydFAxLCB0aGlzLnN0YXJ0UDEpO1xuICAgICAgdGhpcy5fdGFwVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy50YXBIYW5kbGVyLnRhcCh0aGlzLnN0YXJ0UDEsIGUpO1xuXG4gICAgICAgIHRoaXMuX2NsZWFyVGFwVGltZXIoKTtcbiAgICAgIH0sIHRhcERlbGF5KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cblxuXG4gIF9jbGVhclRhcFRpbWVyKCkge1xuICAgIGlmICh0aGlzLl90YXBUaW1lcikge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RhcFRpbWVyKTtcbiAgICAgIHRoaXMuX3RhcFRpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IHZlbG9jaXR5IGZvciBheGlzXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqIEBwYXJhbSB7J3gnIHwgJ3knfSBheGlzXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGR1cmF0aW9uXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cblxuXG4gIF9nZXRWZWxvY2l0eShheGlzLCBkdXJhdGlvbikge1xuICAgIC8vIGRpc3BsYWNlbWVudCBpcyBsaWtlIGRpc3RhbmNlLCBidXQgY2FuIGJlIG5lZ2F0aXZlLlxuICAgIGNvbnN0IGRpc3BsYWNlbWVudCA9IHRoaXMucDFbYXhpc10gLSB0aGlzLl9pbnRlcnZhbFAxW2F4aXNdO1xuXG4gICAgaWYgKE1hdGguYWJzKGRpc3BsYWNlbWVudCkgPiAxICYmIGR1cmF0aW9uID4gNSkge1xuICAgICAgcmV0dXJuIGRpc3BsYWNlbWVudCAvIGR1cmF0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG5cblxuICBfcmFmU3RvcExvb3AoKSB7XG4gICAgaWYgKHRoaXMucmFmKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJhZik7XG4gICAgICB0aGlzLnJhZiA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnR9IGVcclxuICAgKiBAcGFyYW0geyd1cCcgfCAnZG93bicgfCAnbW92ZSd9IHBvaW50ZXJUeXBlIE5vcm1hbGl6ZWQgcG9pbnRlciB0eXBlXHJcbiAgICovXG5cblxuICBfcHJldmVudFBvaW50ZXJFdmVudEJlaGF2aW91cihlLCBwb2ludGVyVHlwZSkge1xuICAgIGNvbnN0IHByZXZlbnRQb2ludGVyRXZlbnQgPSB0aGlzLnBzd3AuYXBwbHlGaWx0ZXJzKCdwcmV2ZW50UG9pbnRlckV2ZW50JywgdHJ1ZSwgZSwgcG9pbnRlclR5cGUpO1xuXG4gICAgaWYgKHByZXZlbnRQb2ludGVyRXZlbnQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUGFyc2VzIGFuZCBub3JtYWxpemVzIHBvaW50cyBmcm9tIHRoZSB0b3VjaCwgbW91c2Ugb3IgcG9pbnRlciBldmVudC5cclxuICAgKiBVcGRhdGVzIHAxIGFuZCBwMi5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQb2ludGVyRXZlbnQgfCBUb3VjaEV2ZW50fSBlXHJcbiAgICogQHBhcmFtIHsndXAnIHwgJ2Rvd24nIHwgJ21vdmUnfSBwb2ludGVyVHlwZSBOb3JtYWxpemVkIHBvaW50ZXIgdHlwZVxyXG4gICAqL1xuXG5cbiAgX3VwZGF0ZVBvaW50cyhlLCBwb2ludGVyVHlwZSkge1xuICAgIGlmICh0aGlzLl9wb2ludGVyRXZlbnRFbmFibGVkKSB7XG4gICAgICBjb25zdCBwb2ludGVyRXZlbnQgPVxuICAgICAgLyoqIEB0eXBlIHtQb2ludGVyRXZlbnR9ICovXG4gICAgICBlOyAvLyBUcnkgdG8gZmluZCB0aGUgY3VycmVudCBwb2ludGVyIGluIG9uZ29pbmcgcG9pbnRlcnMgYnkgaXRzIElEXG5cbiAgICAgIGNvbnN0IHBvaW50ZXJJbmRleCA9IHRoaXMuX29uZ29pbmdQb2ludGVycy5maW5kSW5kZXgob25nb2luZ1BvaW50ZXIgPT4ge1xuICAgICAgICByZXR1cm4gb25nb2luZ1BvaW50ZXIuaWQgPT09IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBvaW50ZXJUeXBlID09PSAndXAnICYmIHBvaW50ZXJJbmRleCA+IC0xKSB7XG4gICAgICAgIC8vIHJlbGVhc2UgdGhlIHBvaW50ZXIgLSByZW1vdmUgaXQgZnJvbSBvbmdvaW5nXG4gICAgICAgIHRoaXMuX29uZ29pbmdQb2ludGVycy5zcGxpY2UocG9pbnRlckluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSBpZiAocG9pbnRlclR5cGUgPT09ICdkb3duJyAmJiBwb2ludGVySW5kZXggPT09IC0xKSB7XG4gICAgICAgIC8vIGFkZCBuZXcgcG9pbnRlclxuICAgICAgICB0aGlzLl9vbmdvaW5nUG9pbnRlcnMucHVzaCh0aGlzLl9jb252ZXJ0RXZlbnRQb3NUb1BvaW50KHBvaW50ZXJFdmVudCwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2UgaWYgKHBvaW50ZXJJbmRleCA+IC0xKSB7XG4gICAgICAgIC8vIHVwZGF0ZSBleGlzdGluZyBwb2ludGVyXG4gICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQocG9pbnRlckV2ZW50LCB0aGlzLl9vbmdvaW5nUG9pbnRlcnNbcG9pbnRlckluZGV4XSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IHRoaXMuX29uZ29pbmdQb2ludGVycy5sZW5ndGg7IC8vIHVwZGF0ZSBwb2ludHMgdGhhdCBQaG90b1N3aXBlIHVzZXNcbiAgICAgIC8vIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBhbmQgc2NhbGVcblxuICAgICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA+IDApIHtcbiAgICAgICAgZXF1YWxpemVQb2ludHModGhpcy5wMSwgdGhpcy5fb25nb2luZ1BvaW50ZXJzWzBdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX251bUFjdGl2ZVBvaW50cyA+IDEpIHtcbiAgICAgICAgZXF1YWxpemVQb2ludHModGhpcy5wMiwgdGhpcy5fb25nb2luZ1BvaW50ZXJzWzFdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG91Y2hFdmVudCA9XG4gICAgICAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovXG4gICAgICBlO1xuICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzID0gMDtcblxuICAgICAgaWYgKHRvdWNoRXZlbnQudHlwZS5pbmRleE9mKCd0b3VjaCcpID4gLTEpIHtcbiAgICAgICAgLy8gVG91Y2ggRXZlbnRcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RvdWNoRXZlbnRcbiAgICAgICAgaWYgKHRvdWNoRXZlbnQudG91Y2hlcyAmJiB0b3VjaEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuX2NvbnZlcnRFdmVudFBvc1RvUG9pbnQodG91Y2hFdmVudC50b3VjaGVzWzBdLCB0aGlzLnAxKTtcblxuICAgICAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cysrO1xuXG4gICAgICAgICAgaWYgKHRvdWNoRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9jb252ZXJ0RXZlbnRQb3NUb1BvaW50KHRvdWNoRXZlbnQudG91Y2hlc1sxXSwgdGhpcy5wMik7XG5cbiAgICAgICAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cysrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTW91c2UgRXZlbnRcbiAgICAgICAgdGhpcy5fY29udmVydEV2ZW50UG9zVG9Qb2ludChcbiAgICAgICAgLyoqIEB0eXBlIHtQb2ludGVyRXZlbnR9ICovXG4gICAgICAgIGUsIHRoaXMucDEpO1xuXG4gICAgICAgIGlmIChwb2ludGVyVHlwZSA9PT0gJ3VwJykge1xuICAgICAgICAgIC8vIGNsZWFyIGFsbCBwb2ludHMgb24gbW91c2V1cFxuICAgICAgICAgIHRoaXMuX251bUFjdGl2ZVBvaW50cyA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fbnVtQWN0aXZlUG9pbnRzKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIHVwZGF0ZSBwb2ludHMgdGhhdCB3ZXJlIHVzZWQgZHVyaW5nIHByZXZpb3VzIHJBRiB0aWNrXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cblxuXG4gIF91cGRhdGVQcmV2UG9pbnRzKCkge1xuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMucHJldlAxLCB0aGlzLnAxKTtcbiAgICBlcXVhbGl6ZVBvaW50cyh0aGlzLnByZXZQMiwgdGhpcy5wMik7XG4gIH1cbiAgLyoqIHVwZGF0ZSBwb2ludHMgYXQgdGhlIHN0YXJ0IG9mIGdlc3R1cmVcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG5cbiAgX3VwZGF0ZVN0YXJ0UG9pbnRzKCkge1xuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuc3RhcnRQMSwgdGhpcy5wMSk7XG4gICAgZXF1YWxpemVQb2ludHModGhpcy5zdGFydFAyLCB0aGlzLnAyKTtcblxuICAgIHRoaXMuX3VwZGF0ZVByZXZQb2ludHMoKTtcbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIF9jYWxjdWxhdGVEcmFnRGlyZWN0aW9uKCkge1xuICAgIGlmICh0aGlzLnBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xuICAgICAgLy8gaWYgbWFpbiBzY3JvbGwgcG9zaXRpb24gaXMgc2hpZnRlZCDigJMgZGlyZWN0aW9uIGlzIGFsd2F5cyBob3Jpem9udGFsXG4gICAgICB0aGlzLmRyYWdBeGlzID0gJ3gnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjYWxjdWxhdGUgZGVsdGEgb2YgdGhlIGxhc3QgdG91Y2htb3ZlIHRpY2tcbiAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyh0aGlzLnAxLnggLSB0aGlzLnN0YXJ0UDEueCkgLSBNYXRoLmFicyh0aGlzLnAxLnkgLSB0aGlzLnN0YXJ0UDEueSk7XG5cbiAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIHBvaW50ZXIgd2FzIHNoaWZ0ZWQgaG9yaXpvbnRhbGx5IG9yIHZlcnRpY2FsbHlcbiAgICAgICAgY29uc3QgYXhpc1RvQ2hlY2sgPSBkaWZmID4gMCA/ICd4JyA6ICd5JztcblxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5wMVtheGlzVG9DaGVja10gLSB0aGlzLnN0YXJ0UDFbYXhpc1RvQ2hlY2tdKSA+PSBBWElTX1NXSVBFX0hZU1RFUklTSVMpIHtcbiAgICAgICAgICB0aGlzLmRyYWdBeGlzID0gYXhpc1RvQ2hlY2s7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQ29udmVydHMgdG91Y2gsIHBvaW50ZXIgb3IgbW91c2UgZXZlbnRcclxuICAgKiB0byBQaG90b1N3aXBlIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1RvdWNoIHwgUG9pbnRlckV2ZW50fSBlXHJcbiAgICogQHBhcmFtIHtQb2ludH0gcFxyXG4gICAqIEByZXR1cm5zIHtQb2ludH1cclxuICAgKi9cblxuXG4gIF9jb252ZXJ0RXZlbnRQb3NUb1BvaW50KGUsIHApIHtcbiAgICBwLnggPSBlLnBhZ2VYIC0gdGhpcy5wc3dwLm9mZnNldC54O1xuICAgIHAueSA9IGUucGFnZVkgLSB0aGlzLnBzd3Aub2Zmc2V0Lnk7XG5cbiAgICBpZiAoJ3BvaW50ZXJJZCcgaW4gZSkge1xuICAgICAgcC5pZCA9IGUucG9pbnRlcklkO1xuICAgIH0gZWxzZSBpZiAoZS5pZGVudGlmaWVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHAuaWQgPSBlLmlkZW50aWZpZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge1BvaW50ZXJFdmVudH0gZVxyXG4gICAqL1xuXG5cbiAgX29uQ2xpY2soZSkge1xuICAgIC8vIERvIG5vdCBhbGxvdyBjbGljayBldmVudCB0byBwYXNzIHRocm91Z2ggYWZ0ZXIgZHJhZ1xuICAgIGlmICh0aGlzLnBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSkge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9zbGlkZS5qcycpLmRlZmF1bHR9IFNsaWRlICovXG5cbi8qKiBAdHlwZWRlZiB7eyBlbDogSFRNTERpdkVsZW1lbnQ7IHNsaWRlPzogU2xpZGUgfX0gSXRlbUhvbGRlciAqL1xuXG5jb25zdCBNQUlOX1NDUk9MTF9FTkRfRlJJQ1RJT04gPSAwLjM1OyAvLyBjb25zdCBNSU5fU1dJUEVfVFJBTlNJVElPTl9EVVJBVElPTiA9IDI1MDtcbi8vIGNvbnN0IE1BWF9TV0lQRV9UUkFCU0lUSU9OX0RVUkFUSU9OID0gNTAwO1xuLy8gY29uc3QgREVGQVVMVF9TV0lQRV9UUkFOU0lUSU9OX0RVUkFUSU9OID0gMzMzO1xuXG4vKipcclxuICogSGFuZGxlcyBtb3ZlbWVudCBvZiB0aGUgbWFpbiBzY3JvbGxpbmcgY29udGFpbmVyXHJcbiAqIChmb3IgZXhhbXBsZSwgaXQgcmVwb3NpdGlvbnMgd2hlbiB1c2VyIHN3aXBlcyBsZWZ0IG9yIHJpZ2h0KS5cclxuICpcclxuICogQWxzbyBzdG9yZXMgaXRzIHN0YXRlLlxyXG4gKi9cblxuY2xhc3MgTWFpblNjcm9sbCB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZX0gcHN3cFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihwc3dwKSB7XG4gICAgdGhpcy5wc3dwID0gcHN3cDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMuc2xpZGVXaWR0aCA9IDA7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9jdXJyUG9zaXRpb25JbmRleCA9IDA7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9wcmV2UG9zaXRpb25JbmRleCA9IDA7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4ID0gLTE7XG4gICAgLyoqIEB0eXBlIHtJdGVtSG9sZGVyW119ICovXG5cbiAgICB0aGlzLml0ZW1Ib2xkZXJzID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogUG9zaXRpb24gdGhlIHNjcm9sbGVyIGFuZCBzbGlkZSBjb250YWluZXJzXHJcbiAgICogYWNjb3JkaW5nIHRvIHZpZXdwb3J0IHNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZXNpemVTbGlkZXNdIFdoZXRoZXIgc2xpZGVzIGNvbnRlbnQgc2hvdWxkIHJlc2l6ZWRcclxuICAgKi9cblxuXG4gIHJlc2l6ZShyZXNpemVTbGlkZXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgbmV3U2xpZGVXaWR0aCA9IE1hdGgucm91bmQocHN3cC52aWV3cG9ydFNpemUueCArIHBzd3Audmlld3BvcnRTaXplLnggKiBwc3dwLm9wdGlvbnMuc3BhY2luZyk7IC8vIE1vYmlsZSBicm93c2VycyBtaWdodCB0cmlnZ2VyIGEgcmVzaXplIGV2ZW50IGR1cmluZyBhIGdlc3R1cmUuXG4gICAgLy8gKGR1ZSB0byB0b29sYmFyIGFwcGVhcmluZyBvciBoaWRpbmcpLlxuICAgIC8vIEF2b2lkIHJlLWFkanVzdGluZyBtYWluIHNjcm9sbCBwb3NpdGlvbiBpZiB3aWR0aCB3YXNuJ3QgY2hhbmdlZFxuXG4gICAgY29uc3Qgc2xpZGVXaWR0aENoYW5nZWQgPSBuZXdTbGlkZVdpZHRoICE9PSB0aGlzLnNsaWRlV2lkdGg7XG5cbiAgICBpZiAoc2xpZGVXaWR0aENoYW5nZWQpIHtcbiAgICAgIHRoaXMuc2xpZGVXaWR0aCA9IG5ld1NsaWRlV2lkdGg7XG4gICAgICB0aGlzLm1vdmVUbyh0aGlzLmdldEN1cnJTbGlkZVgoKSk7XG4gICAgfVxuXG4gICAgdGhpcy5pdGVtSG9sZGVycy5mb3JFYWNoKChpdGVtSG9sZGVyLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHNsaWRlV2lkdGhDaGFuZ2VkKSB7XG4gICAgICAgIHNldFRyYW5zZm9ybShpdGVtSG9sZGVyLmVsLCAoaW5kZXggKyB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4KSAqIHRoaXMuc2xpZGVXaWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXNpemVTbGlkZXMgJiYgaXRlbUhvbGRlci5zbGlkZSkge1xuICAgICAgICBpdGVtSG9sZGVyLnNsaWRlLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJlc2V0IFggcG9zaXRpb24gb2YgdGhlIG1haW4gc2Nyb2xsZXIgdG8gemVyb1xyXG4gICAqL1xuXG5cbiAgcmVzZXRQb3NpdGlvbigpIHtcbiAgICAvLyBQb3NpdGlvbiBvbiB0aGUgbWFpbiBzY3JvbGxlciAob2Zmc2V0KVxuICAgIC8vIGl0IGlzIGluZGVwZW5kZW50IGZyb20gc2xpZGUgaW5kZXhcbiAgICB0aGlzLl9jdXJyUG9zaXRpb25JbmRleCA9IDA7XG4gICAgdGhpcy5fcHJldlBvc2l0aW9uSW5kZXggPSAwOyAvLyBUaGlzIHdpbGwgZm9yY2UgcmVjYWxjdWxhdGlvbiBvZiBzaXplIG9uIG5leHQgcmVzaXplKClcblxuICAgIHRoaXMuc2xpZGVXaWR0aCA9IDA7IC8vIF9jb250YWluZXJTaGlmdEluZGV4KnZpZXdwb3J0U2l6ZSB3aWxsIGdpdmUgeW91IGFtb3VudCBvZiB0cmFuc2Zvcm0gb2YgdGhlIGN1cnJlbnQgc2xpZGVcblxuICAgIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggPSAtMTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgYW5kIGFwcGVuZCBhcnJheSBvZiB0aHJlZSBpdGVtc1xyXG4gICAqIHRoYXQgaG9sZCBkYXRhIGFib3V0IHNsaWRlcyBpbiBET01cclxuICAgKi9cblxuXG4gIGFwcGVuZEhvbGRlcnMoKSB7XG4gICAgdGhpcy5pdGVtSG9sZGVycyA9IFtdOyAvLyBhcHBlbmQgb3VyIHRocmVlIHNsaWRlIGhvbGRlcnMgLVxuICAgIC8vIHByZXZpb3VzLCBjdXJyZW50LCBhbmQgbmV4dFxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzOyBpKyspIHtcbiAgICAgIGNvbnN0IGVsID0gY3JlYXRlRWxlbWVudCgncHN3cF9faXRlbScsICdkaXYnLCB0aGlzLnBzd3AuY29udGFpbmVyKTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdncm91cCcpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLXJvbGVkZXNjcmlwdGlvbicsICdzbGlkZScpO1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7IC8vIGhpZGUgbmVhcmJ5IGl0ZW0gaG9sZGVycyB1bnRpbCBpbml0aWFsIHpvb20gYW5pbWF0aW9uIGZpbmlzaGVzICh0byBhdm9pZCBleHRyYSBQYWludHMpXG5cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBpID09PSAxID8gJ2Jsb2NrJyA6ICdub25lJztcbiAgICAgIHRoaXMuaXRlbUhvbGRlcnMucHVzaCh7XG4gICAgICAgIGVsIC8vaW5kZXg6IC0xXG5cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBXaGV0aGVyIHRoZSBtYWluIHNjcm9sbCBjYW4gYmUgaG9yaXpvbnRhbGx5IHN3aXBlZCB0byB0aGUgbmV4dCBvciBwcmV2aW91cyBzbGlkZS5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cblxuXG4gIGNhbkJlU3dpcGVkKCkge1xuICAgIHJldHVybiB0aGlzLnBzd3AuZ2V0TnVtSXRlbXMoKSA+IDE7XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZSBtYWluIHNjcm9sbCBieSBYIGFtb3VudCBvZiBzbGlkZXMuXHJcbiAgICogRm9yIGV4YW1wbGU6XHJcbiAgICogICBgLTFgIHdpbGwgbW92ZSB0byB0aGUgcHJldmlvdXMgc2xpZGUsXHJcbiAgICogICAgYDBgIHdpbGwgcmVzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBzbGlkZSxcclxuICAgKiAgICBgM2Agd2lsbCBtb3ZlIHRocmVlIHNsaWRlcyBmb3J3YXJkXHJcbiAgICpcclxuICAgKiBJZiBsb29wIG9wdGlvbiBpcyBlbmFibGVkIC0gaW5kZXggd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGxvb3BlZCB0b28sXHJcbiAgICogKGZvciBleGFtcGxlIGAtMWAgd2lsbCBtb3ZlIHRvIHRoZSBsYXN0IHNsaWRlIG9mIHRoZSBnYWxsZXJ5KS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbYW5pbWF0ZV1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3ZlbG9jaXR5WF1cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciBpbmRleCB3YXMgY2hhbmdlZCBvciBub3RcclxuICAgKi9cblxuXG4gIG1vdmVJbmRleEJ5KGRpZmYsIGFuaW1hdGUsIHZlbG9jaXR5WCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgbmV3SW5kZXggPSBwc3dwLnBvdGVudGlhbEluZGV4ICsgZGlmZjtcbiAgICBjb25zdCBudW1TbGlkZXMgPSBwc3dwLmdldE51bUl0ZW1zKCk7XG5cbiAgICBpZiAocHN3cC5jYW5Mb29wKCkpIHtcbiAgICAgIG5ld0luZGV4ID0gcHN3cC5nZXRMb29wZWRJbmRleChuZXdJbmRleCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IChkaWZmICsgbnVtU2xpZGVzKSAlIG51bVNsaWRlcztcblxuICAgICAgaWYgKGRpc3RhbmNlIDw9IG51bVNsaWRlcyAvIDIpIHtcbiAgICAgICAgLy8gZ28gZm9yd2FyZFxuICAgICAgICBkaWZmID0gZGlzdGFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBnbyBiYWNrd2FyZHNcbiAgICAgICAgZGlmZiA9IGRpc3RhbmNlIC0gbnVtU2xpZGVzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV3SW5kZXggPCAwKSB7XG4gICAgICAgIG5ld0luZGV4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAobmV3SW5kZXggPj0gbnVtU2xpZGVzKSB7XG4gICAgICAgIG5ld0luZGV4ID0gbnVtU2xpZGVzIC0gMTtcbiAgICAgIH1cblxuICAgICAgZGlmZiA9IG5ld0luZGV4IC0gcHN3cC5wb3RlbnRpYWxJbmRleDtcbiAgICB9XG5cbiAgICBwc3dwLnBvdGVudGlhbEluZGV4ID0gbmV3SW5kZXg7XG4gICAgdGhpcy5fY3VyclBvc2l0aW9uSW5kZXggLT0gZGlmZjtcbiAgICBwc3dwLmFuaW1hdGlvbnMuc3RvcE1haW5TY3JvbGwoKTtcbiAgICBjb25zdCBkZXN0aW5hdGlvblggPSB0aGlzLmdldEN1cnJTbGlkZVgoKTtcblxuICAgIGlmICghYW5pbWF0ZSkge1xuICAgICAgdGhpcy5tb3ZlVG8oZGVzdGluYXRpb25YKTtcbiAgICAgIHRoaXMudXBkYXRlQ3Vyckl0ZW0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHN3cC5hbmltYXRpb25zLnN0YXJ0U3ByaW5nKHtcbiAgICAgICAgaXNNYWluU2Nyb2xsOiB0cnVlLFxuICAgICAgICBzdGFydDogdGhpcy54LFxuICAgICAgICBlbmQ6IGRlc3RpbmF0aW9uWCxcbiAgICAgICAgdmVsb2NpdHk6IHZlbG9jaXR5WCB8fCAwLFxuICAgICAgICBuYXR1cmFsRnJlcXVlbmN5OiAzMCxcbiAgICAgICAgZGFtcGluZ1JhdGlvOiAxLFxuICAgICAgICAvLzAuNyxcbiAgICAgICAgb25VcGRhdGU6IHggPT4ge1xuICAgICAgICAgIHRoaXMubW92ZVRvKHgpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNvbXBsZXRlOiAoKSA9PiB7XG4gICAgICAgICAgdGhpcy51cGRhdGVDdXJySXRlbSgpO1xuICAgICAgICAgIHBzd3AuYXBwZW5kSGVhdnkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBsZXQgY3VyckRpZmYgPSBwc3dwLnBvdGVudGlhbEluZGV4IC0gcHN3cC5jdXJySW5kZXg7XG5cbiAgICAgIGlmIChwc3dwLmNhbkxvb3AoKSkge1xuICAgICAgICBjb25zdCBjdXJyRGlzdGFuY2UgPSAoY3VyckRpZmYgKyBudW1TbGlkZXMpICUgbnVtU2xpZGVzO1xuXG4gICAgICAgIGlmIChjdXJyRGlzdGFuY2UgPD0gbnVtU2xpZGVzIC8gMikge1xuICAgICAgICAgIC8vIGdvIGZvcndhcmRcbiAgICAgICAgICBjdXJyRGlmZiA9IGN1cnJEaXN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBnbyBiYWNrd2FyZHNcbiAgICAgICAgICBjdXJyRGlmZiA9IGN1cnJEaXN0YW5jZSAtIG51bVNsaWRlcztcbiAgICAgICAgfVxuICAgICAgfSAvLyBGb3JjZS1hcHBlbmQgbmV3IHNsaWRlcyBkdXJpbmcgdHJhbnNpdGlvblxuICAgICAgLy8gaWYgZGlmZmVyZW5jZSBiZXR3ZWVuIHNsaWRlcyBpcyBtb3JlIHRoYW4gMVxuXG5cbiAgICAgIGlmIChNYXRoLmFicyhjdXJyRGlmZikgPiAxKSB7XG4gICAgICAgIHRoaXMudXBkYXRlQ3Vyckl0ZW0oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQm9vbGVhbihkaWZmKTtcbiAgfVxuICAvKipcclxuICAgKiBYIHBvc2l0aW9uIG9mIHRoZSBtYWluIHNjcm9sbCBmb3IgdGhlIGN1cnJlbnQgc2xpZGVcclxuICAgKiAoaWdub3JlcyBwb3NpdGlvbiBkdXJpbmcgZHJhZ2dpbmcpXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cblxuXG4gIGdldEN1cnJTbGlkZVgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2xpZGVXaWR0aCAqIHRoaXMuX2N1cnJQb3NpdGlvbkluZGV4O1xuICB9XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgc2Nyb2xsIHBvc2l0aW9uIGlzIHNoaWZ0ZWQuXHJcbiAgICogRm9yIGV4YW1wbGUsIGl0IHdpbGwgcmV0dXJuIHRydWUgaWYgdGhlIHNjcm9sbCBpcyBiZWluZyBkcmFnZ2VkIG9yIGFuaW1hdGVkLlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xuXG5cbiAgaXNTaGlmdGVkKCkge1xuICAgIHJldHVybiB0aGlzLnggIT09IHRoaXMuZ2V0Q3VyclNsaWRlWCgpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBzbGlkZXMgWCBwb3NpdGlvbnMgYW5kIHNldCB0aGVpciBjb250ZW50XHJcbiAgICovXG5cblxuICB1cGRhdGVDdXJySXRlbSgpIHtcbiAgICB2YXIgX3RoaXMkaXRlbUhvbGRlcnMkO1xuXG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IHBvc2l0aW9uRGlmZmVyZW5jZSA9IHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4IC0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XG5cbiAgICBpZiAoIXBvc2l0aW9uRGlmZmVyZW5jZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3ByZXZQb3NpdGlvbkluZGV4ID0gdGhpcy5fY3VyclBvc2l0aW9uSW5kZXg7XG4gICAgcHN3cC5jdXJySW5kZXggPSBwc3dwLnBvdGVudGlhbEluZGV4O1xuICAgIGxldCBkaWZmQWJzID0gTWF0aC5hYnMocG9zaXRpb25EaWZmZXJlbmNlKTtcbiAgICAvKiogQHR5cGUge0l0ZW1Ib2xkZXIgfCB1bmRlZmluZWR9ICovXG5cbiAgICBsZXQgdGVtcEhvbGRlcjtcblxuICAgIGlmIChkaWZmQWJzID49IDMpIHtcbiAgICAgIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggKz0gcG9zaXRpb25EaWZmZXJlbmNlICsgKHBvc2l0aW9uRGlmZmVyZW5jZSA+IDAgPyAtMyA6IDMpO1xuICAgICAgZGlmZkFicyA9IDM7IC8vIElmIHNsaWRlcyBhcmUgY2hhbmdlZCBieSAzIHNjcmVlbnMgb3IgbW9yZSAtIGNsZWFuIHVwIHByZXZpb3VzIHNsaWRlc1xuXG4gICAgICB0aGlzLml0ZW1Ib2xkZXJzLmZvckVhY2goaXRlbUhvbGRlciA9PiB7XG4gICAgICAgIHZhciBfaXRlbUhvbGRlciRzbGlkZTtcblxuICAgICAgICAoX2l0ZW1Ib2xkZXIkc2xpZGUgPSBpdGVtSG9sZGVyLnNsaWRlKSA9PT0gbnVsbCB8fCBfaXRlbUhvbGRlciRzbGlkZSA9PT0gdm9pZCAwIHx8IF9pdGVtSG9sZGVyJHNsaWRlLmRlc3Ryb3koKTtcbiAgICAgICAgaXRlbUhvbGRlci5zbGlkZSA9IHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZkFiczsgaSsrKSB7XG4gICAgICBpZiAocG9zaXRpb25EaWZmZXJlbmNlID4gMCkge1xuICAgICAgICB0ZW1wSG9sZGVyID0gdGhpcy5pdGVtSG9sZGVycy5zaGlmdCgpO1xuXG4gICAgICAgIGlmICh0ZW1wSG9sZGVyKSB7XG4gICAgICAgICAgdGhpcy5pdGVtSG9sZGVyc1syXSA9IHRlbXBIb2xkZXI7IC8vIG1vdmUgZmlyc3QgdG8gbGFzdFxuXG4gICAgICAgICAgdGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCsrO1xuICAgICAgICAgIHNldFRyYW5zZm9ybSh0ZW1wSG9sZGVyLmVsLCAodGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCArIDIpICogdGhpcy5zbGlkZVdpZHRoKTtcbiAgICAgICAgICBwc3dwLnNldENvbnRlbnQodGVtcEhvbGRlciwgcHN3cC5jdXJySW5kZXggLSBkaWZmQWJzICsgaSArIDIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wSG9sZGVyID0gdGhpcy5pdGVtSG9sZGVycy5wb3AoKTtcblxuICAgICAgICBpZiAodGVtcEhvbGRlcikge1xuICAgICAgICAgIHRoaXMuaXRlbUhvbGRlcnMudW5zaGlmdCh0ZW1wSG9sZGVyKTsgLy8gbW92ZSBsYXN0IHRvIGZpcnN0XG5cbiAgICAgICAgICB0aGlzLl9jb250YWluZXJTaGlmdEluZGV4LS07XG4gICAgICAgICAgc2V0VHJhbnNmb3JtKHRlbXBIb2xkZXIuZWwsIHRoaXMuX2NvbnRhaW5lclNoaWZ0SW5kZXggKiB0aGlzLnNsaWRlV2lkdGgpO1xuICAgICAgICAgIHBzd3Auc2V0Q29udGVudCh0ZW1wSG9sZGVyLCBwc3dwLmN1cnJJbmRleCArIGRpZmZBYnMgLSBpIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFJlc2V0IHRyYW5zZnJvbSBldmVyeSA1MGlzaCBuYXZpZ2F0aW9ucyBpbiBvbmUgZGlyZWN0aW9uLlxuICAgIC8vXG4gICAgLy8gT3RoZXJ3aXNlIHRyYW5zZm9ybSB3aWxsIGtlZXAgZ3Jvd2luZyBpbmRlZmluaXRlbHksXG4gICAgLy8gd2hpY2ggbWlnaHQgY2F1c2UgaXNzdWVzIGFzIGJyb3dzZXJzIGhhdmUgYSBtYXhpbXVtIHRyYW5zZm9ybSBsaW1pdC5cbiAgICAvLyBJIHdhc24ndCBhYmxlIHRvIHJlYWNoIGl0LCBidXQganVzdCB0byBiZSBzYWZlLlxuICAgIC8vIFRoaXMgc2hvdWxkIG5vdCBjYXVzZSBub3RpY2FibGUgbGFnLlxuXG5cbiAgICBpZiAoTWF0aC5hYnModGhpcy5fY29udGFpbmVyU2hpZnRJbmRleCkgPiA1MCAmJiAhdGhpcy5pc1NoaWZ0ZWQoKSkge1xuICAgICAgdGhpcy5yZXNldFBvc2l0aW9uKCk7XG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgIH0gLy8gUGFuIHRyYW5zaXRpb24gbWlnaHQgYmUgcnVubmluZyAoYW5kIGNvbnNudGFudGx5IHVwZGF0aW5nIHBhbiBwb3NpdGlvbilcblxuXG4gICAgcHN3cC5hbmltYXRpb25zLnN0b3BBbGxQYW4oKTtcbiAgICB0aGlzLml0ZW1Ib2xkZXJzLmZvckVhY2goKGl0ZW1Ib2xkZXIsIGkpID0+IHtcbiAgICAgIGlmIChpdGVtSG9sZGVyLnNsaWRlKSB7XG4gICAgICAgIC8vIFNsaWRlIGluIHRoZSAybmQgaG9sZGVyIGlzIGFsd2F5cyBhY3RpdmVcbiAgICAgICAgaXRlbUhvbGRlci5zbGlkZS5zZXRJc0FjdGl2ZShpID09PSAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwc3dwLmN1cnJTbGlkZSA9IChfdGhpcyRpdGVtSG9sZGVycyQgPSB0aGlzLml0ZW1Ib2xkZXJzWzFdKSA9PT0gbnVsbCB8fCBfdGhpcyRpdGVtSG9sZGVycyQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGl0ZW1Ib2xkZXJzJC5zbGlkZTtcbiAgICBwc3dwLmNvbnRlbnRMb2FkZXIudXBkYXRlTGF6eShwb3NpdGlvbkRpZmZlcmVuY2UpO1xuXG4gICAgaWYgKHBzd3AuY3VyclNsaWRlKSB7XG4gICAgICBwc3dwLmN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgfVxuXG4gICAgcHN3cC5kaXNwYXRjaCgnY2hhbmdlJyk7XG4gIH1cbiAgLyoqXHJcbiAgICogTW92ZSB0aGUgWCBwb3NpdGlvbiBvZiB0aGUgbWFpbiBzY3JvbGwgY29udGFpbmVyXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2RyYWdnaW5nXVxyXG4gICAqL1xuXG5cbiAgbW92ZVRvKHgsIGRyYWdnaW5nKSB7XG4gICAgaWYgKCF0aGlzLnBzd3AuY2FuTG9vcCgpICYmIGRyYWdnaW5nKSB7XG4gICAgICAvLyBBcHBseSBmcmljdGlvblxuICAgICAgbGV0IG5ld1NsaWRlSW5kZXhPZmZzZXQgPSAodGhpcy5zbGlkZVdpZHRoICogdGhpcy5fY3VyclBvc2l0aW9uSW5kZXggLSB4KSAvIHRoaXMuc2xpZGVXaWR0aDtcbiAgICAgIG5ld1NsaWRlSW5kZXhPZmZzZXQgKz0gdGhpcy5wc3dwLmN1cnJJbmRleDtcbiAgICAgIGNvbnN0IGRlbHRhID0gTWF0aC5yb3VuZCh4IC0gdGhpcy54KTtcblxuICAgICAgaWYgKG5ld1NsaWRlSW5kZXhPZmZzZXQgPCAwICYmIGRlbHRhID4gMCB8fCBuZXdTbGlkZUluZGV4T2Zmc2V0ID49IHRoaXMucHN3cC5nZXROdW1JdGVtcygpIC0gMSAmJiBkZWx0YSA8IDApIHtcbiAgICAgICAgeCA9IHRoaXMueCArIGRlbHRhICogTUFJTl9TQ1JPTExfRU5EX0ZSSUNUSU9OO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMueCA9IHg7XG5cbiAgICBpZiAodGhpcy5wc3dwLmNvbnRhaW5lcikge1xuICAgICAgc2V0VHJhbnNmb3JtKHRoaXMucHN3cC5jb250YWluZXIsIHgpO1xuICAgIH1cblxuICAgIHRoaXMucHN3cC5kaXNwYXRjaCgnbW92ZU1haW5TY3JvbGwnLCB7XG4gICAgICB4LFxuICAgICAgZHJhZ2dpbmc6IGRyYWdnaW5nICE9PSBudWxsICYmIGRyYWdnaW5nICE9PSB2b2lkIDAgPyBkcmFnZ2luZyA6IGZhbHNlXG4gICAgfSk7XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xuXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi90eXBlcy5qcycpLk1ldGhvZHM8VD59IE1ldGhvZHM8VD5cclxuICovXG5cbmNvbnN0IEtleWJvYXJkS2V5Q29kZXNNYXAgPSB7XG4gIEVzY2FwZTogMjcsXG4gIHo6IDkwLFxuICBBcnJvd0xlZnQ6IDM3LFxuICBBcnJvd1VwOiAzOCxcbiAgQXJyb3dSaWdodDogMzksXG4gIEFycm93RG93bjogNDAsXG4gIFRhYjogOVxufTtcbi8qKlxyXG4gKiBAdGVtcGxhdGUge2tleW9mIEtleWJvYXJkS2V5Q29kZXNNYXB9IFRcclxuICogQHBhcmFtIHtUfSBrZXlcclxuICogQHBhcmFtIHtib29sZWFufSBpc0tleVN1cHBvcnRlZFxyXG4gKiBAcmV0dXJucyB7VCB8IG51bWJlciB8IHVuZGVmaW5lZH1cclxuICovXG5cbmNvbnN0IGdldEtleWJvYXJkRXZlbnRLZXkgPSAoa2V5LCBpc0tleVN1cHBvcnRlZCkgPT4ge1xuICByZXR1cm4gaXNLZXlTdXBwb3J0ZWQgPyBrZXkgOiBLZXlib2FyZEtleUNvZGVzTWFwW2tleV07XG59O1xuLyoqXHJcbiAqIC0gTWFuYWdlcyBrZXlib2FyZCBzaG9ydGN1dHMuXHJcbiAqIC0gSGVscHMgdHJhcCBmb2N1cyB3aXRoaW4gcGhvdG9zd2lwZS5cclxuICovXG5cblxuY2xhc3MgS2V5Ym9hcmQge1xuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGV9IHBzd3BcclxuICAgKi9cbiAgY29uc3RydWN0b3IocHN3cCkge1xuICAgIHRoaXMucHN3cCA9IHBzd3A7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl93YXNGb2N1c2VkID0gZmFsc2U7XG4gICAgcHN3cC5vbignYmluZEV2ZW50cycsICgpID0+IHtcbiAgICAgIGlmIChwc3dwLm9wdGlvbnMudHJhcEZvY3VzKSB7XG4gICAgICAgIC8vIERpYWxvZyB3YXMgbGlrZWx5IG9wZW5lZCBieSBrZXlib2FyZCBpZiBpbml0aWFsIHBvaW50IGlzIG5vdCBkZWZpbmVkXG4gICAgICAgIGlmICghcHN3cC5vcHRpb25zLmluaXRpYWxQb2ludGVyUG9zKSB7XG4gICAgICAgICAgLy8gZm9jdXMgY2F1c2VzIGxheW91dCxcbiAgICAgICAgICAvLyB3aGljaCBjYXVzZXMgbGFnIGR1cmluZyB0aGUgYW5pbWF0aW9uLFxuICAgICAgICAgIC8vIHRoYXQncyB3aHkgd2UgZGVsYXkgaXQgdW50aWwgdGhlIG9wZW5lciB0cmFuc2l0aW9uIGVuZHNcbiAgICAgICAgICB0aGlzLl9mb2N1c1Jvb3QoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBzd3AuZXZlbnRzLmFkZChkb2N1bWVudCwgJ2ZvY3VzaW4nLFxuICAgICAgICAvKiogQHR5cGUgRXZlbnRMaXN0ZW5lciAqL1xuICAgICAgICB0aGlzLl9vbkZvY3VzSW4uYmluZCh0aGlzKSk7XG4gICAgICB9XG5cbiAgICAgIHBzd3AuZXZlbnRzLmFkZChkb2N1bWVudCwgJ2tleWRvd24nLFxuICAgICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi9cbiAgICAgIHRoaXMuX29uS2V5RG93bi5iaW5kKHRoaXMpKTtcbiAgICB9KTtcbiAgICBjb25zdCBsYXN0QWN0aXZlRWxlbWVudCA9XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cbiAgICBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIHBzd3Aub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICBpZiAocHN3cC5vcHRpb25zLnJldHVybkZvY3VzICYmIGxhc3RBY3RpdmVFbGVtZW50ICYmIHRoaXMuX3dhc0ZvY3VzZWQpIHtcbiAgICAgICAgbGFzdEFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIF9mb2N1c1Jvb3QoKSB7XG4gICAgaWYgKCF0aGlzLl93YXNGb2N1c2VkICYmIHRoaXMucHN3cC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnBzd3AuZWxlbWVudC5mb2N1cygpO1xuICAgICAgdGhpcy5fd2FzRm9jdXNlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBlXHJcbiAgICovXG5cblxuICBfb25LZXlEb3duKGUpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAocHN3cC5kaXNwYXRjaCgna2V5ZG93bicsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNwZWNpYWxLZXlVc2VkKGUpKSB7XG4gICAgICAvLyBkb24ndCBkbyBhbnl0aGluZyBpZiBzcGVjaWFsIGtleSBwcmVzc2VkXG4gICAgICAvLyB0byBwcmV2ZW50IGZyb20gb3ZlcnJpZGluZyBkZWZhdWx0IGJyb3dzZXIgYWN0aW9uc1xuICAgICAgLy8gZm9yIGV4YW1wbGUsIGluIENocm9tZSBvbiBNYWMgY21kK2Fycm93LWxlZnQgcmV0dXJucyB0byBwcmV2aW91cyBwYWdlXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7TWV0aG9kczxQaG90b1N3aXBlPiB8IHVuZGVmaW5lZH0gKi9cblxuXG4gICAgbGV0IGtleWRvd25BY3Rpb247XG4gICAgLyoqIEB0eXBlIHsneCcgfCAneScgfCB1bmRlZmluZWR9ICovXG5cbiAgICBsZXQgYXhpcztcbiAgICBsZXQgaXNGb3J3YXJkID0gZmFsc2U7XG4gICAgY29uc3QgaXNLZXlTdXBwb3J0ZWQgPSAoJ2tleScgaW4gZSk7XG5cbiAgICBzd2l0Y2ggKGlzS2V5U3VwcG9ydGVkID8gZS5rZXkgOiBlLmtleUNvZGUpIHtcbiAgICAgIGNhc2UgZ2V0S2V5Ym9hcmRFdmVudEtleSgnRXNjYXBlJywgaXNLZXlTdXBwb3J0ZWQpOlxuICAgICAgICBpZiAocHN3cC5vcHRpb25zLmVzY0tleSkge1xuICAgICAgICAgIGtleWRvd25BY3Rpb24gPSAnY2xvc2UnO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZ2V0S2V5Ym9hcmRFdmVudEtleSgneicsIGlzS2V5U3VwcG9ydGVkKTpcbiAgICAgICAga2V5ZG93bkFjdGlvbiA9ICd0b2dnbGVab29tJztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgZ2V0S2V5Ym9hcmRFdmVudEtleSgnQXJyb3dMZWZ0JywgaXNLZXlTdXBwb3J0ZWQpOlxuICAgICAgICBheGlzID0gJ3gnO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdBcnJvd1VwJywgaXNLZXlTdXBwb3J0ZWQpOlxuICAgICAgICBheGlzID0gJ3knO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdBcnJvd1JpZ2h0JywgaXNLZXlTdXBwb3J0ZWQpOlxuICAgICAgICBheGlzID0gJ3gnO1xuICAgICAgICBpc0ZvcndhcmQgPSB0cnVlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBnZXRLZXlib2FyZEV2ZW50S2V5KCdBcnJvd0Rvd24nLCBpc0tleVN1cHBvcnRlZCk6XG4gICAgICAgIGlzRm9yd2FyZCA9IHRydWU7XG4gICAgICAgIGF4aXMgPSAneSc7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIGdldEtleWJvYXJkRXZlbnRLZXkoJ1RhYicsIGlzS2V5U3VwcG9ydGVkKTpcbiAgICAgICAgdGhpcy5fZm9jdXNSb290KCk7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyBpZiBsZWZ0L3JpZ2h0L3RvcC9ib3R0b20ga2V5XG5cblxuICAgIGlmIChheGlzKSB7XG4gICAgICAvLyBwcmV2ZW50IHBhZ2Ugc2Nyb2xsXG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJTbGlkZVxuICAgICAgfSA9IHBzd3A7XG5cbiAgICAgIGlmIChwc3dwLm9wdGlvbnMuYXJyb3dLZXlzICYmIGF4aXMgPT09ICd4JyAmJiBwc3dwLmdldE51bUl0ZW1zKCkgPiAxKSB7XG4gICAgICAgIGtleWRvd25BY3Rpb24gPSBpc0ZvcndhcmQgPyAnbmV4dCcgOiAncHJldic7XG4gICAgICB9IGVsc2UgaWYgKGN1cnJTbGlkZSAmJiBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCA+IGN1cnJTbGlkZS56b29tTGV2ZWxzLmZpdCkge1xuICAgICAgICAvLyB1cC9kb3duIGFycm93IGtleXMgcGFuIHRoZSBpbWFnZSB2ZXJ0aWNhbGx5XG4gICAgICAgIC8vIGxlZnQvcmlnaHQgYXJyb3cga2V5cyBwYW4gaG9yaXpvbnRhbGx5LlxuICAgICAgICAvLyBVbmxlc3MgdGhlcmUgaXMgb25seSBvbmUgaW1hZ2UsXG4gICAgICAgIC8vIG9yIGFycm93S2V5cyBvcHRpb24gaXMgZGlzYWJsZWRcbiAgICAgICAgY3VyclNsaWRlLnBhbltheGlzXSArPSBpc0ZvcndhcmQgPyAtODAgOiA4MDtcbiAgICAgICAgY3VyclNsaWRlLnBhblRvKGN1cnJTbGlkZS5wYW4ueCwgY3VyclNsaWRlLnBhbi55KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoa2V5ZG93bkFjdGlvbikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBAdHMtaWdub3JlXG5cbiAgICAgIHBzd3Bba2V5ZG93bkFjdGlvbl0oKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogVHJhcCBmb2N1cyBpbnNpZGUgcGhvdG9zd2lwZVxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge0ZvY3VzRXZlbnR9IGVcclxuICAgKi9cblxuXG4gIF9vbkZvY3VzSW4oZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRlbXBsYXRlXG4gICAgfSA9IHRoaXMucHN3cDtcblxuICAgIGlmICh0ZW1wbGF0ZSAmJiBkb2N1bWVudCAhPT0gZS50YXJnZXQgJiYgdGVtcGxhdGUgIT09IGUudGFyZ2V0ICYmICF0ZW1wbGF0ZS5jb250YWlucyhcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgZS50YXJnZXQpKSB7XG4gICAgICAvLyBmb2N1cyByb290IGVsZW1lbnRcbiAgICAgIHRlbXBsYXRlLmZvY3VzKCk7XG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgREVGQVVMVF9FQVNJTkcgPSAnY3ViaWMtYmV6aWVyKC40LDAsLjIyLDEpJztcbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2FuaW1hdGlvbnMuanMnKS5TaGFyZWRBbmltYXRpb25Qcm9wc30gU2hhcmVkQW5pbWF0aW9uUHJvcHMgKi9cblxuLyoqIEB0eXBlZGVmIHtPYmplY3R9IERlZmF1bHRDc3NBbmltYXRpb25Qcm9wc1xyXG4gKlxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnR9IHRhcmdldFxyXG4gKiBAcHJvcCB7bnVtYmVyfSBbZHVyYXRpb25dXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtlYXNpbmddXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFt0cmFuc2Zvcm1dXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtvcGFjaXR5XVxyXG4gKiAqL1xuXG4vKiogQHR5cGVkZWYge1NoYXJlZEFuaW1hdGlvblByb3BzICYgRGVmYXVsdENzc0FuaW1hdGlvblByb3BzfSBDc3NBbmltYXRpb25Qcm9wcyAqL1xuXG4vKipcclxuICogUnVucyBDU1MgdHJhbnNpdGlvbi5cclxuICovXG5cbmNsYXNzIENTU0FuaW1hdGlvbiB7XG4gIC8qKlxyXG4gICAqIG9uQ29tcGxldGUgY2FuIGJlIHVucHJlZGljdGFibGUsIGJlIGNhcmVmdWwgYWJvdXQgY3VycmVudCBzdGF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDc3NBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB2YXIgX3Byb3BzJHByb3A7XG5cbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgY29uc3Qge1xuICAgICAgdGFyZ2V0LFxuICAgICAgb25Db21wbGV0ZSxcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIG9uRmluaXNoID0gKCkgPT4ge30sXG4gICAgICBkdXJhdGlvbiA9IDMzMyxcbiAgICAgIGVhc2luZyA9IERFRkFVTFRfRUFTSU5HXG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMub25GaW5pc2ggPSBvbkZpbmlzaDsgLy8gc3VwcG9ydCBvbmx5IHRyYW5zZm9ybSBhbmQgb3BhY2l0eVxuXG4gICAgY29uc3QgcHJvcCA9IHRyYW5zZm9ybSA/ICd0cmFuc2Zvcm0nIDogJ29wYWNpdHknO1xuICAgIGNvbnN0IHByb3BWYWx1ZSA9IChfcHJvcHMkcHJvcCA9IHByb3BzW3Byb3BdKSAhPT0gbnVsbCAmJiBfcHJvcHMkcHJvcCAhPT0gdm9pZCAwID8gX3Byb3BzJHByb3AgOiAnJztcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX29uQ29tcGxldGUgPSBvbkNvbXBsZXRlO1xuICAgIC8qKiBAcHJpdmF0ZSAqL1xuXG4gICAgdGhpcy5fZmluaXNoZWQgPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX29uVHJhbnNpdGlvbkVuZCA9IHRoaXMuX29uVHJhbnNpdGlvbkVuZC5iaW5kKHRoaXMpOyAvLyBVc2luZyB0aW1lb3V0IGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgYW5pbWF0aW9uXG4gICAgLy8gc3RhcnRzIGV2ZW4gaWYgdGhlIGFuaW1hdGVkIHByb3BlcnR5IHdhcyBjaGFuZ2VkIHJlY2VudGx5LFxuICAgIC8vIG90aGVyd2lzZSB0cmFuc2l0aW9uZW5kIG1pZ2h0IG5vdCBmaXJlIG9yIHRyYW5zaXRpb24gd29uJ3Qgc3RhcnQuXG4gICAgLy8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzcy10cmFuc2l0aW9ucy8jc3RhcnRpbmdcbiAgICAvL1xuICAgIC8vIMKvXFxfKOODhClfL8KvXG5cbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX2hlbHBlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHNldFRyYW5zaXRpb25TdHlsZSh0YXJnZXQsIHByb3AsIGR1cmF0aW9uLCBlYXNpbmcpO1xuICAgICAgdGhpcy5faGVscGVyVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xuICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmNhbmNlbCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpOyAvLyBTYWZhcmkgb2NjYXNpb25hbGx5IGRvZXMgbm90IGVtaXQgdHJhbnNpdGlvbmVuZCBldmVudFxuICAgICAgICAvLyBpZiBlbGVtZW50IHByb3BlcnR5IHdhcyBtb2RpZmllZCBkdXJpbmcgdGhlIHRyYW5zaXRpb24sXG4gICAgICAgIC8vIHdoaWNoIG1heSBiZSBjYXVzZWQgYnkgcmVzaXplIG9yIHRoaXJkIHBhcnR5IGNvbXBvbmVudCxcbiAgICAgICAgLy8gdXNpbmcgdGltZW91dCBhcyBhIHNhZmV0eSBmYWxsYmFja1xuXG4gICAgICAgIHRoaXMuX2hlbHBlclRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLl9maW5hbGl6ZUFuaW1hdGlvbigpO1xuICAgICAgICB9LCBkdXJhdGlvbiArIDUwMCk7XG4gICAgICAgIHRhcmdldC5zdHlsZVtwcm9wXSA9IHByb3BWYWx1ZTtcbiAgICAgIH0sIDMwKTsgLy8gRG8gbm90IHJlZHVjZSB0aGlzIG51bWJlclxuICAgIH0sIDApO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtUcmFuc2l0aW9uRXZlbnR9IGVcclxuICAgKi9cblxuXG4gIF9vblRyYW5zaXRpb25FbmQoZSkge1xuICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5fdGFyZ2V0KSB7XG4gICAgICB0aGlzLl9maW5hbGl6ZUFuaW1hdGlvbigpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG5cbiAgX2ZpbmFsaXplQW5pbWF0aW9uKCkge1xuICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMub25GaW5pc2goKTtcblxuICAgICAgaWYgKHRoaXMuX29uQ29tcGxldGUpIHtcbiAgICAgICAgdGhpcy5fb25Db21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBEZXN0cm95IGlzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IG9uRmluaXNoXG5cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLl9oZWxwZXJUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5faGVscGVyVGltZW91dCk7XG4gICAgfVxuXG4gICAgcmVtb3ZlVHJhbnNpdGlvblN0eWxlKHRoaXMuX3RhcmdldCk7XG5cbiAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgZmFsc2UpO1xuXG4gICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25jYW5jZWwnLCB0aGlzLl9vblRyYW5zaXRpb25FbmQsIGZhbHNlKTtcblxuICAgIGlmICghdGhpcy5fZmluaXNoZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmFsaXplQW5pbWF0aW9uKCk7XG4gICAgfVxuICB9XG5cbn1cblxuY29uc3QgREVGQVVMVF9OQVRVUkFMX0ZSRVFVRU5DWSA9IDEyO1xuY29uc3QgREVGQVVMVF9EQU1QSU5HX1JBVElPID0gMC43NTtcbi8qKlxyXG4gKiBTcHJpbmcgZWFzaW5nIGhlbHBlclxyXG4gKi9cblxuY2xhc3MgU3ByaW5nRWFzZXIge1xuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5pdGlhbFZlbG9jaXR5IEluaXRpYWwgdmVsb2NpdHksIHB4IHBlciBtcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGFtcGluZ1JhdGlvXVxyXG4gICAqIERldGVybWluZXMgaG93IGJvdW5jeSBhbmltYXRpb24gd2lsbCBiZS5cclxuICAgKiBGcm9tIDAgdG8gMSwgMCAtIGFsd2F5cyBvdmVyc2hvb3QsIDEgLSBkbyBub3Qgb3ZlcnNob290LlxyXG4gICAqIFwib3ZlcnNob290XCIgcmVmZXJzIHRvIHBhcnQgb2YgYW5pbWF0aW9uIHRoYXRcclxuICAgKiBnb2VzIGJleW9uZCB0aGUgZmluYWwgdmFsdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW25hdHVyYWxGcmVxdWVuY3ldXHJcbiAgICogRGV0ZXJtaW5lcyBob3cgZmFzdCBhbmltYXRpb24gd2lsbCBzbG93IGRvd24uXHJcbiAgICogVGhlIGhpZ2hlciB2YWx1ZSAtIHRoZSBzdGlmZmVyIHRoZSB0cmFuc2l0aW9uIHdpbGwgYmUsXHJcbiAgICogYW5kIHRoZSBmYXN0ZXIgaXQgd2lsbCBzbG93IGRvd24uXHJcbiAgICogUmVjb21tZW5kZWQgdmFsdWUgZnJvbSAxMCB0byA1MFxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihpbml0aWFsVmVsb2NpdHksIGRhbXBpbmdSYXRpbywgbmF0dXJhbEZyZXF1ZW5jeSkge1xuICAgIHRoaXMudmVsb2NpdHkgPSBpbml0aWFsVmVsb2NpdHkgKiAxMDAwOyAvLyBjb252ZXJ0IHRvIFwicGl4ZWxzIHBlciBzZWNvbmRcIlxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RhbXBpbmdfcmF0aW9cblxuICAgIHRoaXMuX2RhbXBpbmdSYXRpbyA9IGRhbXBpbmdSYXRpbyB8fCBERUZBVUxUX0RBTVBJTkdfUkFUSU87IC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL05hdHVyYWxfZnJlcXVlbmN5XG5cbiAgICB0aGlzLl9uYXR1cmFsRnJlcXVlbmN5ID0gbmF0dXJhbEZyZXF1ZW5jeSB8fCBERUZBVUxUX05BVFVSQUxfRlJFUVVFTkNZO1xuICAgIHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSA9IHRoaXMuX25hdHVyYWxGcmVxdWVuY3k7XG5cbiAgICBpZiAodGhpcy5fZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgdGhpcy5fZGFtcGVkRnJlcXVlbmN5ICo9IE1hdGguc3FydCgxIC0gdGhpcy5fZGFtcGluZ1JhdGlvICogdGhpcy5fZGFtcGluZ1JhdGlvKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhUG9zaXRpb24gRGlmZmVyZW5jZSBiZXR3ZWVuIGN1cnJlbnQgYW5kIGVuZCBwb3NpdGlvbiBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSBGcmFtZSBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IERpc3BsYWNlbWVudCwgcmVsYXRpdmUgdG8gdGhlIGVuZCBwb3NpdGlvbi5cclxuICAgKi9cblxuXG4gIGVhc2VGcmFtZShkZWx0YVBvc2l0aW9uLCBkZWx0YVRpbWUpIHtcbiAgICAvLyBJbnNwaXJlZCBieSBBcHBsZSBXZWJraXQgYW5kIEFuZHJvaWQgc3ByaW5nIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvT3NjaWxsYXRpb25cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EYW1waW5nX3JhdGlvXG4gICAgLy8gd2UgaWdub3JlIG1hc3MgKGFzc3VtZSB0aGF0IGl0J3MgMWtnKVxuICAgIGxldCBkaXNwbGFjZW1lbnQgPSAwO1xuICAgIGxldCBjb2VmZjtcbiAgICBkZWx0YVRpbWUgLz0gMTAwMDtcbiAgICBjb25zdCBuYXR1cmFsRHVtcGluZ1BvdyA9IE1hdGguRSAqKiAoLXRoaXMuX2RhbXBpbmdSYXRpbyAqIHRoaXMuX25hdHVyYWxGcmVxdWVuY3kgKiBkZWx0YVRpbWUpO1xuXG4gICAgaWYgKHRoaXMuX2RhbXBpbmdSYXRpbyA9PT0gMSkge1xuICAgICAgY29lZmYgPSB0aGlzLnZlbG9jaXR5ICsgdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeSAqIGRlbHRhUG9zaXRpb247XG4gICAgICBkaXNwbGFjZW1lbnQgPSAoZGVsdGFQb3NpdGlvbiArIGNvZWZmICogZGVsdGFUaW1lKSAqIG5hdHVyYWxEdW1waW5nUG93O1xuICAgICAgdGhpcy52ZWxvY2l0eSA9IGRpc3BsYWNlbWVudCAqIC10aGlzLl9uYXR1cmFsRnJlcXVlbmN5ICsgY29lZmYgKiBuYXR1cmFsRHVtcGluZ1BvdztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX2RhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgIGNvZWZmID0gMSAvIHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSAqICh0aGlzLl9kYW1waW5nUmF0aW8gKiB0aGlzLl9uYXR1cmFsRnJlcXVlbmN5ICogZGVsdGFQb3NpdGlvbiArIHRoaXMudmVsb2NpdHkpO1xuICAgICAgY29uc3QgZHVtcGVkRkNvcyA9IE1hdGguY29zKHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSAqIGRlbHRhVGltZSk7XG4gICAgICBjb25zdCBkdW1wZWRGU2luID0gTWF0aC5zaW4odGhpcy5fZGFtcGVkRnJlcXVlbmN5ICogZGVsdGFUaW1lKTtcbiAgICAgIGRpc3BsYWNlbWVudCA9IG5hdHVyYWxEdW1waW5nUG93ICogKGRlbHRhUG9zaXRpb24gKiBkdW1wZWRGQ29zICsgY29lZmYgKiBkdW1wZWRGU2luKTtcbiAgICAgIHRoaXMudmVsb2NpdHkgPSBkaXNwbGFjZW1lbnQgKiAtdGhpcy5fbmF0dXJhbEZyZXF1ZW5jeSAqIHRoaXMuX2RhbXBpbmdSYXRpbyArIG5hdHVyYWxEdW1waW5nUG93ICogKC10aGlzLl9kYW1wZWRGcmVxdWVuY3kgKiBkZWx0YVBvc2l0aW9uICogZHVtcGVkRlNpbiArIHRoaXMuX2RhbXBlZEZyZXF1ZW5jeSAqIGNvZWZmICogZHVtcGVkRkNvcyk7XG4gICAgfSAvLyBPdmVyZGFtcGVkICg+MSkgZGFtcGluZyByYXRpbyBpcyBub3Qgc3VwcG9ydGVkXG5cblxuICAgIHJldHVybiBkaXNwbGFjZW1lbnQ7XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9hbmltYXRpb25zLmpzJykuU2hhcmVkQW5pbWF0aW9uUHJvcHN9IFNoYXJlZEFuaW1hdGlvblByb3BzICovXG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEZWZhdWx0U3ByaW5nQW5pbWF0aW9uUHJvcHNcclxuICpcclxuICogQHByb3Age251bWJlcn0gc3RhcnRcclxuICogQHByb3Age251bWJlcn0gZW5kXHJcbiAqIEBwcm9wIHtudW1iZXJ9IHZlbG9jaXR5XHJcbiAqIEBwcm9wIHtudW1iZXJ9IFtkYW1waW5nUmF0aW9dXHJcbiAqIEBwcm9wIHtudW1iZXJ9IFtuYXR1cmFsRnJlcXVlbmN5XVxyXG4gKiBAcHJvcCB7KGVuZDogbnVtYmVyKSA9PiB2b2lkfSBvblVwZGF0ZVxyXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtTaGFyZWRBbmltYXRpb25Qcm9wcyAmIERlZmF1bHRTcHJpbmdBbmltYXRpb25Qcm9wc30gU3ByaW5nQW5pbWF0aW9uUHJvcHMgKi9cblxuY2xhc3MgU3ByaW5nQW5pbWF0aW9uIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTcHJpbmdBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKi9cbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgdGhpcy5fcmFmID0gMDtcbiAgICBjb25zdCB7XG4gICAgICBzdGFydCxcbiAgICAgIGVuZCxcbiAgICAgIHZlbG9jaXR5LFxuICAgICAgb25VcGRhdGUsXG4gICAgICBvbkNvbXBsZXRlLFxuICAgICAgb25GaW5pc2ggPSAoKSA9PiB7fSxcbiAgICAgIGRhbXBpbmdSYXRpbyxcbiAgICAgIG5hdHVyYWxGcmVxdWVuY3lcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xuICAgIGNvbnN0IGVhc2VyID0gbmV3IFNwcmluZ0Vhc2VyKHZlbG9jaXR5LCBkYW1waW5nUmF0aW8sIG5hdHVyYWxGcmVxdWVuY3kpO1xuICAgIGxldCBwcmV2VGltZSA9IERhdGUubm93KCk7XG4gICAgbGV0IGRlbHRhUG9zaXRpb24gPSBzdGFydCAtIGVuZDtcblxuICAgIGNvbnN0IGFuaW1hdGlvbkxvb3AgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fcmFmKSB7XG4gICAgICAgIGRlbHRhUG9zaXRpb24gPSBlYXNlci5lYXNlRnJhbWUoZGVsdGFQb3NpdGlvbiwgRGF0ZS5ub3coKSAtIHByZXZUaW1lKTsgLy8gU3RvcCB0aGUgYW5pbWF0aW9uIGlmIHZlbG9jaXR5IGlzIGxvdyBhbmQgcG9zaXRpb24gaXMgY2xvc2UgdG8gZW5kXG5cbiAgICAgICAgaWYgKE1hdGguYWJzKGRlbHRhUG9zaXRpb24pIDwgMSAmJiBNYXRoLmFicyhlYXNlci52ZWxvY2l0eSkgPCA1MCkge1xuICAgICAgICAgIC8vIEZpbmFsaXplIHRoZSBhbmltYXRpb25cbiAgICAgICAgICBvblVwZGF0ZShlbmQpO1xuXG4gICAgICAgICAgaWYgKG9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLm9uRmluaXNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldlRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgIG9uVXBkYXRlKGRlbHRhUG9zaXRpb24gKyBlbmQpO1xuICAgICAgICAgIHRoaXMuX3JhZiA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25Mb29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLl9yYWYgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0aW9uTG9vcCk7XG4gIH0gLy8gRGVzdHJveSBpcyBjYWxsZWQgYXV0b21hdGljYWxseSBvbkZpbmlzaFxuXG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fcmFmID49IDApIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX3JhZik7XG4gICAgfVxuXG4gICAgdGhpcy5fcmFmID0gMDtcbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2Nzcy1hbmltYXRpb24uanMnKS5Dc3NBbmltYXRpb25Qcm9wc30gQ3NzQW5pbWF0aW9uUHJvcHMgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc3ByaW5nLWFuaW1hdGlvbi5qcycpLlNwcmluZ0FuaW1hdGlvblByb3BzfSBTcHJpbmdBbmltYXRpb25Qcm9wcyAqL1xuXG4vKiogQHR5cGVkZWYge09iamVjdH0gU2hhcmVkQW5pbWF0aW9uUHJvcHNcclxuICogQHByb3Age3N0cmluZ30gW25hbWVdXHJcbiAqIEBwcm9wIHtib29sZWFufSBbaXNQYW5dXHJcbiAqIEBwcm9wIHtib29sZWFufSBbaXNNYWluU2Nyb2xsXVxyXG4gKiBAcHJvcCB7Vm9pZEZ1bmN0aW9ufSBbb25Db21wbGV0ZV1cclxuICogQHByb3Age1ZvaWRGdW5jdGlvbn0gW29uRmluaXNoXVxyXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtTcHJpbmdBbmltYXRpb24gfCBDU1NBbmltYXRpb259IEFuaW1hdGlvbiAqL1xuXG4vKiogQHR5cGVkZWYge1NwcmluZ0FuaW1hdGlvblByb3BzIHwgQ3NzQW5pbWF0aW9uUHJvcHN9IEFuaW1hdGlvblByb3BzICovXG5cbi8qKlxyXG4gKiBNYW5hZ2VzIGFuaW1hdGlvbnNcclxuICovXG5cbmNsYXNzIEFuaW1hdGlvbnMge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUge0FuaW1hdGlvbltdfSAqL1xuICAgIHRoaXMuYWN0aXZlQW5pbWF0aW9ucyA9IFtdO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U3ByaW5nQW5pbWF0aW9uUHJvcHN9IHByb3BzXHJcbiAgICovXG5cblxuICBzdGFydFNwcmluZyhwcm9wcykge1xuICAgIHRoaXMuX3N0YXJ0KHByb3BzLCB0cnVlKTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge0Nzc0FuaW1hdGlvblByb3BzfSBwcm9wc1xyXG4gICAqL1xuXG5cbiAgc3RhcnRUcmFuc2l0aW9uKHByb3BzKSB7XG4gICAgdGhpcy5fc3RhcnQocHJvcHMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtBbmltYXRpb25Qcm9wc30gcHJvcHNcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1NwcmluZ11cclxuICAgKiBAcmV0dXJucyB7QW5pbWF0aW9ufVxyXG4gICAqL1xuXG5cbiAgX3N0YXJ0KHByb3BzLCBpc1NwcmluZykge1xuICAgIGNvbnN0IGFuaW1hdGlvbiA9IGlzU3ByaW5nID8gbmV3IFNwcmluZ0FuaW1hdGlvbihcbiAgICAvKiogQHR5cGUgU3ByaW5nQW5pbWF0aW9uUHJvcHMgKi9cbiAgICBwcm9wcykgOiBuZXcgQ1NTQW5pbWF0aW9uKFxuICAgIC8qKiBAdHlwZSBDc3NBbmltYXRpb25Qcm9wcyAqL1xuICAgIHByb3BzKTtcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuXG4gICAgYW5pbWF0aW9uLm9uRmluaXNoID0gKCkgPT4gdGhpcy5zdG9wKGFuaW1hdGlvbik7XG5cbiAgICByZXR1cm4gYW5pbWF0aW9uO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7QW5pbWF0aW9ufSBhbmltYXRpb25cclxuICAgKi9cblxuXG4gIHN0b3AoYW5pbWF0aW9uKSB7XG4gICAgYW5pbWF0aW9uLmRlc3Ryb3koKTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuYWN0aXZlQW5pbWF0aW9ucy5pbmRleE9mKGFuaW1hdGlvbik7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5hY3RpdmVBbmltYXRpb25zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgc3RvcEFsbCgpIHtcbiAgICAvLyBfc3RvcEFsbEFuaW1hdGlvbnNcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuZm9yRWFjaChhbmltYXRpb24gPT4ge1xuICAgICAgYW5pbWF0aW9uLmRlc3Ryb3koKTtcbiAgICB9KTtcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSBbXTtcbiAgfVxuICAvKipcclxuICAgKiBTdG9wIGFsbCBwYW4gb3Igem9vbSB0cmFuc2l0aW9uc1xyXG4gICAqL1xuXG5cbiAgc3RvcEFsbFBhbigpIHtcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbiA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uLnByb3BzLmlzUGFuKSB7XG4gICAgICAgIGFuaW1hdGlvbi5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cblxuICBzdG9wTWFpblNjcm9sbCgpIHtcbiAgICB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMgPSB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuZmlsdGVyKGFuaW1hdGlvbiA9PiB7XG4gICAgICBpZiAoYW5pbWF0aW9uLnByb3BzLmlzTWFpblNjcm9sbCkge1xuICAgICAgICBhbmltYXRpb24uZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBtYWluIHNjcm9sbCB0cmFuc2l0aW9uIGlzIHJ1bm5pbmdcclxuICAgKi9cbiAgLy8gaXNNYWluU2Nyb2xsUnVubmluZygpIHtcbiAgLy8gICByZXR1cm4gdGhpcy5hY3RpdmVBbmltYXRpb25zLnNvbWUoKGFuaW1hdGlvbikgPT4ge1xuICAvLyAgICAgcmV0dXJuIGFuaW1hdGlvbi5wcm9wcy5pc01haW5TY3JvbGw7XG4gIC8vICAgfSk7XG4gIC8vIH1cblxuICAvKipcclxuICAgKiBSZXR1cm5zIHRydWUgaWYgYW55IHBhbiBvciB6b29tIHRyYW5zaXRpb24gaXMgcnVubmluZ1xyXG4gICAqL1xuXG5cbiAgaXNQYW5SdW5uaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmFjdGl2ZUFuaW1hdGlvbnMuc29tZShhbmltYXRpb24gPT4ge1xuICAgICAgcmV0dXJuIGFuaW1hdGlvbi5wcm9wcy5pc1BhbjtcbiAgICB9KTtcbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXG5cbi8qKlxyXG4gKiBIYW5kbGVzIHNjcm9sbCB3aGVlbC5cclxuICogQ2FuIHBhbiBhbmQgem9vbSBjdXJyZW50IHNsaWRlIGltYWdlLlxyXG4gKi9cbmNsYXNzIFNjcm9sbFdoZWVsIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xuICAgIHBzd3AuZXZlbnRzLmFkZChwc3dwLmVsZW1lbnQsICd3aGVlbCcsXG4gICAgLyoqIEB0eXBlIEV2ZW50TGlzdGVuZXIgKi9cbiAgICB0aGlzLl9vbldoZWVsLmJpbmQodGhpcykpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtXaGVlbEV2ZW50fSBlXHJcbiAgICovXG5cblxuICBfb25XaGVlbChlKSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJTbGlkZVxuICAgIH0gPSB0aGlzLnBzd3A7XG4gICAgbGV0IHtcbiAgICAgIGRlbHRhWCxcbiAgICAgIGRlbHRhWVxuICAgIH0gPSBlO1xuXG4gICAgaWYgKCFjdXJyU2xpZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wc3dwLmRpc3BhdGNoKCd3aGVlbCcsIHtcbiAgICAgIG9yaWdpbmFsRXZlbnQ6IGVcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGUuY3RybEtleSB8fCB0aGlzLnBzd3Aub3B0aW9ucy53aGVlbFRvWm9vbSkge1xuICAgICAgLy8gem9vbVxuICAgICAgaWYgKGN1cnJTbGlkZS5pc1pvb21hYmxlKCkpIHtcbiAgICAgICAgbGV0IHpvb21GYWN0b3IgPSAtZGVsdGFZO1xuXG4gICAgICAgIGlmIChlLmRlbHRhTW9kZSA9PT0gMVxuICAgICAgICAvKiBET01fREVMVEFfTElORSAqL1xuICAgICAgICApIHtcbiAgICAgICAgICB6b29tRmFjdG9yICo9IDAuMDU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgem9vbUZhY3RvciAqPSBlLmRlbHRhTW9kZSA/IDEgOiAwLjAwMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHpvb21GYWN0b3IgPSAyICoqIHpvb21GYWN0b3I7XG4gICAgICAgIGNvbnN0IGRlc3Rab29tTGV2ZWwgPSBjdXJyU2xpZGUuY3Vyclpvb21MZXZlbCAqIHpvb21GYWN0b3I7XG4gICAgICAgIGN1cnJTbGlkZS56b29tVG8oZGVzdFpvb21MZXZlbCwge1xuICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICB5OiBlLmNsaWVudFlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHBhblxuICAgICAgaWYgKGN1cnJTbGlkZS5pc1Bhbm5hYmxlKCkpIHtcbiAgICAgICAgaWYgKGUuZGVsdGFNb2RlID09PSAxXG4gICAgICAgIC8qIERPTV9ERUxUQV9MSU5FICovXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDE4IC0gYXZlcmFnZSBsaW5lIGhlaWdodFxuICAgICAgICAgIGRlbHRhWCAqPSAxODtcbiAgICAgICAgICBkZWx0YVkgKj0gMTg7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJyU2xpZGUucGFuVG8oY3VyclNsaWRlLnBhbi54IC0gZGVsdGFYLCBjdXJyU2xpZGUucGFuLnkgLSBkZWx0YVkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9waG90b3N3aXBlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xuXG4vKipcclxuICogQHRlbXBsYXRlIFRcclxuICogQHR5cGVkZWYge2ltcG9ydCgnLi4vdHlwZXMuanMnKS5NZXRob2RzPFQ+fSBNZXRob2RzPFQ+XHJcbiAqL1xuXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gVUlFbGVtZW50TWFya3VwUHJvcHNcclxuICogQHByb3Age2Jvb2xlYW59IFtpc0N1c3RvbVNWR11cclxuICogQHByb3Age3N0cmluZ30gaW5uZXJcclxuICogQHByb3Age3N0cmluZ30gW291dGxpbmVJRF1cclxuICogQHByb3Age251bWJlciB8IHN0cmluZ30gW3NpemVdXHJcbiAqL1xuXG4vKipcclxuICogQHR5cGVkZWYge09iamVjdH0gVUlFbGVtZW50RGF0YVxyXG4gKiBAcHJvcCB7RGVmYXVsdFVJRWxlbWVudHMgfCBzdHJpbmd9IFtuYW1lXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbY2xhc3NOYW1lXVxyXG4gKiBAcHJvcCB7VUlFbGVtZW50TWFya3VwfSBbaHRtbF1cclxuICogQHByb3Age2Jvb2xlYW59IFtpc0J1dHRvbl1cclxuICogQHByb3Age2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gW3RhZ05hbWVdXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFt0aXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW2FyaWFMYWJlbF1cclxuICogQHByb3AgeyhlbGVtZW50OiBIVE1MRWxlbWVudCwgcHN3cDogUGhvdG9Td2lwZSkgPT4gdm9pZH0gW29uSW5pdF1cclxuICogQHByb3Age01ldGhvZHM8UGhvdG9Td2lwZT4gfCAoKGU6IE1vdXNlRXZlbnQsIGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBwc3dwOiBQaG90b1N3aXBlKSA9PiB2b2lkKX0gW29uQ2xpY2tdXHJcbiAqIEBwcm9wIHsnYmFyJyB8ICd3cmFwcGVyJyB8ICdyb290J30gW2FwcGVuZFRvXVxyXG4gKiBAcHJvcCB7bnVtYmVyfSBbb3JkZXJdXHJcbiAqL1xuXG4vKiogQHR5cGVkZWYgeydhcnJvd1ByZXYnIHwgJ2Fycm93TmV4dCcgfCAnY2xvc2UnIHwgJ3pvb20nIHwgJ2NvdW50ZXInfSBEZWZhdWx0VUlFbGVtZW50cyAqL1xuXG4vKiogQHR5cGVkZWYge3N0cmluZyB8IFVJRWxlbWVudE1hcmt1cFByb3BzfSBVSUVsZW1lbnRNYXJrdXAgKi9cblxuLyoqXHJcbiAqIEBwYXJhbSB7VUlFbGVtZW50TWFya3VwfSBbaHRtbERhdGFdXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAqL1xuXG5mdW5jdGlvbiBhZGRFbGVtZW50SFRNTChodG1sRGF0YSkge1xuICBpZiAodHlwZW9mIGh0bWxEYXRhID09PSAnc3RyaW5nJykge1xuICAgIC8vIEFsbG93IGRldmVsb3BlcnMgdG8gcHJvdmlkZSBmdWxsIHN2ZyxcbiAgICAvLyBGb3IgZXhhbXBsZTpcbiAgICAvLyA8c3ZnIHZpZXdCb3g9XCIwIDAgMzIgMzJcIiB3aWR0aD1cIjMyXCIgaGVpZ2h0PVwiMzJcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBjbGFzcz1cInBzd3BfX2ljblwiPlxuICAgIC8vICAgPHBhdGggZD1cIi4uLlwiIC8+XG4gICAgLy8gICA8Y2lyY2xlIC4uLiAvPlxuICAgIC8vIDwvc3ZnPlxuICAgIC8vIENhbiBhbHNvIGJlIGFueSBIVE1MIHN0cmluZy5cbiAgICByZXR1cm4gaHRtbERhdGE7XG4gIH1cblxuICBpZiAoIWh0bWxEYXRhIHx8ICFodG1sRGF0YS5pc0N1c3RvbVNWRykge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGNvbnN0IHN2Z0RhdGEgPSBodG1sRGF0YTtcbiAgbGV0IG91dCA9ICc8c3ZnIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGNsYXNzPVwicHN3cF9faWNuXCIgdmlld0JveD1cIjAgMCAlZCAlZFwiIHdpZHRoPVwiJWRcIiBoZWlnaHQ9XCIlZFwiPic7IC8vIHJlcGxhY2UgYWxsICVkIHdpdGggc2l6ZVxuXG4gIG91dCA9IG91dC5zcGxpdCgnJWQnKS5qb2luKFxuICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgc3ZnRGF0YS5zaXplIHx8IDMyKTsgLy8gSWNvbnMgbWF5IGNvbnRhaW4gb3V0bGluZS9zaGFkb3csXG4gIC8vIHRvIG1ha2UgaXQgd2UgXCJjbG9uZVwiIGJhc2UgaWNvbiBzaGFwZSBhbmQgYWRkIGJvcmRlciB0byBpdC5cbiAgLy8gSWNvbiBpdHNlbGYgYW5kIGJvcmRlciBhcmUgc3R5bGVkIHZpYSBDU1MuXG4gIC8vXG4gIC8vIFByb3BlcnR5IHNoYWRvd0lEIGRlZmluZXMgSUQgb2YgZWxlbWVudCB0aGF0IHNob3VsZCBiZSBjbG9uZWQuXG5cbiAgaWYgKHN2Z0RhdGEub3V0bGluZUlEKSB7XG4gICAgb3V0ICs9ICc8dXNlIGNsYXNzPVwicHN3cF9faWNuLXNoYWRvd1wiIHhsaW5rOmhyZWY9XCIjJyArIHN2Z0RhdGEub3V0bGluZUlEICsgJ1wiLz4nO1xuICB9XG5cbiAgb3V0ICs9IHN2Z0RhdGEuaW5uZXI7XG4gIG91dCArPSAnPC9zdmc+JztcbiAgcmV0dXJuIG91dDtcbn1cblxuY2xhc3MgVUlFbGVtZW50IHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICogQHBhcmFtIHtVSUVsZW1lbnREYXRhfSBkYXRhXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3AsIGRhdGEpIHtcbiAgICB2YXIgX2NvbnRhaW5lcjtcblxuICAgIGNvbnN0IG5hbWUgPSBkYXRhLm5hbWUgfHwgZGF0YS5jbGFzc05hbWU7XG4gICAgbGV0IGVsZW1lbnRIVE1MID0gZGF0YS5odG1sOyAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2t1cCBvbmx5IGJ5IGBkYXRhLm5hbWVgIG1heWJlP1xuXG4gICAgaWYgKHBzd3Aub3B0aW9uc1tuYW1lXSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIGV4aXQgaWYgZWxlbWVudCBpcyBkaXNhYmxlZCBmcm9tIG9wdGlvbnNcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEFsbG93IHRvIG92ZXJyaWRlIFNWRyBpY29ucyBmcm9tIG9wdGlvbnNcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2t1cCBvbmx5IGJ5IGBkYXRhLm5hbWVgIG1heWJlP1xuXG5cbiAgICBpZiAodHlwZW9mIHBzd3Aub3B0aW9uc1tuYW1lICsgJ1NWRyddID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gYXJyb3dQcmV2U1ZHXG4gICAgICAvLyBhcnJvd05leHRTVkdcbiAgICAgIC8vIGNsb3NlU1ZHXG4gICAgICAvLyB6b29tU1ZHXG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIGxvb2t1cCBvbmx5IGJ5IGBkYXRhLm5hbWVgIG1heWJlP1xuICAgICAgZWxlbWVudEhUTUwgPSBwc3dwLm9wdGlvbnNbbmFtZSArICdTVkcnXTtcbiAgICB9XG5cbiAgICBwc3dwLmRpc3BhdGNoKCd1aUVsZW1lbnRDcmVhdGUnLCB7XG4gICAgICBkYXRhXG4gICAgfSk7XG4gICAgbGV0IGNsYXNzTmFtZSA9ICcnO1xuXG4gICAgaWYgKGRhdGEuaXNCdXR0b24pIHtcbiAgICAgIGNsYXNzTmFtZSArPSAncHN3cF9fYnV0dG9uICc7XG4gICAgICBjbGFzc05hbWUgKz0gZGF0YS5jbGFzc05hbWUgfHwgYHBzd3BfX2J1dHRvbi0tJHtkYXRhLm5hbWV9YDtcbiAgICB9IGVsc2Uge1xuICAgICAgY2xhc3NOYW1lICs9IGRhdGEuY2xhc3NOYW1lIHx8IGBwc3dwX18ke2RhdGEubmFtZX1gO1xuICAgIH1cblxuICAgIGxldCB0YWdOYW1lID0gZGF0YS5pc0J1dHRvbiA/IGRhdGEudGFnTmFtZSB8fCAnYnV0dG9uJyA6IGRhdGEudGFnTmFtZSB8fCAnZGl2JztcbiAgICB0YWdOYW1lID1cbiAgICAvKiogQHR5cGUge2tleW9mIEhUTUxFbGVtZW50VGFnTmFtZU1hcH0gKi9cbiAgICB0YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi9cblxuICAgIGNvbnN0IGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KGNsYXNzTmFtZSwgdGFnTmFtZSk7XG5cbiAgICBpZiAoZGF0YS5pc0J1dHRvbikge1xuICAgICAgaWYgKHRhZ05hbWUgPT09ICdidXR0b24nKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovXG4gICAgICAgIGVsZW1lbnQudHlwZSA9ICdidXR0b24nO1xuICAgICAgfVxuXG4gICAgICBsZXQge1xuICAgICAgICB0aXRsZVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFyaWFMYWJlbFxuICAgICAgfSA9IGRhdGE7IC8vIEB0cy1leHBlY3QtZXJyb3IgbG9va3VwIG9ubHkgYnkgYGRhdGEubmFtZWAgbWF5YmU/XG5cbiAgICAgIGlmICh0eXBlb2YgcHN3cC5vcHRpb25zW25hbWUgKyAnVGl0bGUnXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBsb29rdXAgb25seSBieSBgZGF0YS5uYW1lYCBtYXliZT9cbiAgICAgICAgdGl0bGUgPSBwc3dwLm9wdGlvbnNbbmFtZSArICdUaXRsZSddO1xuICAgICAgfVxuXG4gICAgICBpZiAodGl0bGUpIHtcbiAgICAgICAgZWxlbWVudC50aXRsZSA9IHRpdGxlO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBhcmlhVGV4dCA9IGFyaWFMYWJlbCB8fCB0aXRsZTtcblxuICAgICAgaWYgKGFyaWFUZXh0KSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJywgYXJpYVRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVsZW1lbnQuaW5uZXJIVE1MID0gYWRkRWxlbWVudEhUTUwoZWxlbWVudEhUTUwpO1xuXG4gICAgaWYgKGRhdGEub25Jbml0KSB7XG4gICAgICBkYXRhLm9uSW5pdChlbGVtZW50LCBwc3dwKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5vbkNsaWNrKSB7XG4gICAgICBlbGVtZW50Lm9uY2xpY2sgPSBlID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLm9uQ2xpY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHBzd3BbZGF0YS5vbkNsaWNrXSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkYXRhLm9uQ2xpY2soZSwgZWxlbWVudCwgcHN3cCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSAvLyBUb3AgYmFyIGlzIGRlZmF1bHQgcG9zaXRpb25cblxuXG4gICAgY29uc3QgYXBwZW5kVG8gPSBkYXRhLmFwcGVuZFRvIHx8ICdiYXInO1xuICAgIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnQgfCB1bmRlZmluZWR9IHJvb3QgZWxlbWVudCBieSBkZWZhdWx0ICovXG5cbiAgICBsZXQgY29udGFpbmVyID0gcHN3cC5lbGVtZW50O1xuXG4gICAgaWYgKGFwcGVuZFRvID09PSAnYmFyJykge1xuICAgICAgaWYgKCFwc3dwLnRvcEJhcikge1xuICAgICAgICBwc3dwLnRvcEJhciA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX3RvcC1iYXIgcHN3cF9faGlkZS1vbi1jbG9zZScsICdkaXYnLCBwc3dwLnNjcm9sbFdyYXApO1xuICAgICAgfVxuXG4gICAgICBjb250YWluZXIgPSBwc3dwLnRvcEJhcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxlbWVudCBvdXRzaWRlIG9mIHRvcCBiYXIgZ2V0cyBhIHNlY29uZGFyeSBjbGFzc1xuICAgICAgLy8gdGhhdCBtYWtlcyBlbGVtZW50IGZhZGUgb3V0IG9uIGNsb3NlXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoJ3Bzd3BfX2hpZGUtb24tY2xvc2UnKTtcblxuICAgICAgaWYgKGFwcGVuZFRvID09PSAnd3JhcHBlcicpIHtcbiAgICAgICAgY29udGFpbmVyID0gcHN3cC5zY3JvbGxXcmFwO1xuICAgICAgfVxuICAgIH1cblxuICAgIChfY29udGFpbmVyID0gY29udGFpbmVyKSA9PT0gbnVsbCB8fCBfY29udGFpbmVyID09PSB2b2lkIDAgfHwgX2NvbnRhaW5lci5hcHBlbmRDaGlsZChwc3dwLmFwcGx5RmlsdGVycygndWlFbGVtZW50JywgZWxlbWVudCwgZGF0YSkpO1xuICB9XG5cbn1cblxuLypcclxuICBCYWNrd2FyZCBhbmQgZm9yd2FyZCBhcnJvdyBidXR0b25zXHJcbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cblxuLyoqXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzTmV4dEJ1dHRvbl1cclxuICovXG5mdW5jdGlvbiBpbml0QXJyb3dCdXR0b24oZWxlbWVudCwgcHN3cCwgaXNOZXh0QnV0dG9uKSB7XG4gIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncHN3cF9fYnV0dG9uLS1hcnJvdycpOyAvLyBUT0RPOiB0aGlzIHNob3VsZCBwb2ludCB0byBhIHVuaXF1ZSBpZCBmb3IgdGhpcyBpbnN0YW5jZVxuXG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgJ3Bzd3BfX2l0ZW1zJyk7XG4gIHBzd3Aub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICBpZiAoIXBzd3Aub3B0aW9ucy5sb29wKSB7XG4gICAgICBpZiAoaXNOZXh0QnV0dG9uKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEJ1dHRvbkVsZW1lbnR9ICovXG4gICAgICAgIGVsZW1lbnQuZGlzYWJsZWQgPSAhKHBzd3AuY3VyckluZGV4IDwgcHN3cC5nZXROdW1JdGVtcygpIC0gMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvKiogQHR5cGUge0hUTUxCdXR0b25FbGVtZW50fSAqL1xuICAgICAgICBlbGVtZW50LmRpc2FibGVkID0gIShwc3dwLmN1cnJJbmRleCA+IDApO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG4vKiogQHR5cGUge1VJRWxlbWVudERhdGF9ICovXG5cblxuY29uc3QgYXJyb3dQcmV2ID0ge1xuICBuYW1lOiAnYXJyb3dQcmV2JyxcbiAgY2xhc3NOYW1lOiAncHN3cF9fYnV0dG9uLS1hcnJvdy0tcHJldicsXG4gIHRpdGxlOiAnUHJldmlvdXMnLFxuICBvcmRlcjogMTAsXG4gIGlzQnV0dG9uOiB0cnVlLFxuICBhcHBlbmRUbzogJ3dyYXBwZXInLFxuICBodG1sOiB7XG4gICAgaXNDdXN0b21TVkc6IHRydWUsXG4gICAgc2l6ZTogNjAsXG4gICAgaW5uZXI6ICc8cGF0aCBkPVwiTTI5IDQzbC0zIDMtMTYtMTYgMTYtMTYgMyAzLTEzIDEzIDEzIDEzelwiIGlkPVwicHN3cF9faWNuLWFycm93XCIvPicsXG4gICAgb3V0bGluZUlEOiAncHN3cF9faWNuLWFycm93J1xuICB9LFxuICBvbkNsaWNrOiAncHJldicsXG4gIG9uSW5pdDogaW5pdEFycm93QnV0dG9uXG59O1xuLyoqIEB0eXBlIHtVSUVsZW1lbnREYXRhfSAqL1xuXG5jb25zdCBhcnJvd05leHQgPSB7XG4gIG5hbWU6ICdhcnJvd05leHQnLFxuICBjbGFzc05hbWU6ICdwc3dwX19idXR0b24tLWFycm93LS1uZXh0JyxcbiAgdGl0bGU6ICdOZXh0JyxcbiAgb3JkZXI6IDExLFxuICBpc0J1dHRvbjogdHJ1ZSxcbiAgYXBwZW5kVG86ICd3cmFwcGVyJyxcbiAgaHRtbDoge1xuICAgIGlzQ3VzdG9tU1ZHOiB0cnVlLFxuICAgIHNpemU6IDYwLFxuICAgIGlubmVyOiAnPHVzZSB4bGluazpocmVmPVwiI3Bzd3BfX2ljbi1hcnJvd1wiLz4nLFxuICAgIG91dGxpbmVJRDogJ3Bzd3BfX2ljbi1hcnJvdydcbiAgfSxcbiAgb25DbGljazogJ25leHQnLFxuICBvbkluaXQ6IChlbCwgcHN3cCkgPT4ge1xuICAgIGluaXRBcnJvd0J1dHRvbihlbCwgcHN3cCwgdHJ1ZSk7XG4gIH1cbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXG5jb25zdCBjbG9zZUJ1dHRvbiA9IHtcbiAgbmFtZTogJ2Nsb3NlJyxcbiAgdGl0bGU6ICdDbG9zZScsXG4gIG9yZGVyOiAyMCxcbiAgaXNCdXR0b246IHRydWUsXG4gIGh0bWw6IHtcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcbiAgICBpbm5lcjogJzxwYXRoIGQ9XCJNMjQgMTBsLTItMi02IDYtNi02LTIgMiA2IDYtNiA2IDIgMiA2LTYgNiA2IDItMi02LTZ6XCIgaWQ9XCJwc3dwX19pY24tY2xvc2VcIi8+JyxcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tY2xvc2UnXG4gIH0sXG4gIG9uQ2xpY2s6ICdjbG9zZSdcbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXG5jb25zdCB6b29tQnV0dG9uID0ge1xuICBuYW1lOiAnem9vbScsXG4gIHRpdGxlOiAnWm9vbScsXG4gIG9yZGVyOiAxMCxcbiAgaXNCdXR0b246IHRydWUsXG4gIGh0bWw6IHtcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIGlubmVyOiAnPHBhdGggZD1cIk0xNy40MjYgMTkuOTI2YTYgNiAwIDEgMSAxLjUtMS41TDIzIDIyLjUgMjEuNSAyNGwtNC4wNzQtNC4wNzR6XCIgaWQ9XCJwc3dwX19pY24tem9vbVwiLz4nICsgJzxwYXRoIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cInBzd3BfX3pvb20taWNuLWJhci1oXCIgZD1cIk0xMSAxNnYtMmg2djJ6XCIvPicgKyAnPHBhdGggZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwicHN3cF9fem9vbS1pY24tYmFyLXZcIiBkPVwiTTEzIDEyaDJ2NmgtMnpcIi8+JyxcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tem9vbSdcbiAgfSxcbiAgb25DbGljazogJ3RvZ2dsZVpvb20nXG59O1xuXG4vKiogQHR5cGUge2ltcG9ydCgnLi91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xuY29uc3QgbG9hZGluZ0luZGljYXRvciA9IHtcbiAgbmFtZTogJ3ByZWxvYWRlcicsXG4gIGFwcGVuZFRvOiAnYmFyJyxcbiAgb3JkZXI6IDcsXG4gIGh0bWw6IHtcbiAgICBpc0N1c3RvbVNWRzogdHJ1ZSxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgIGlubmVyOiAnPHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTIxLjIgMTZhNS4yIDUuMiAwIDEgMS01LjItNS4yVjhhOCA4IDAgMSAwIDggOGgtMi44WlwiIGlkPVwicHN3cF9faWNuLWxvYWRpbmdcIi8+JyxcbiAgICBvdXRsaW5lSUQ6ICdwc3dwX19pY24tbG9hZGluZydcbiAgfSxcbiAgb25Jbml0OiAoaW5kaWNhdG9yRWxlbWVudCwgcHN3cCkgPT4ge1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbiB8IHVuZGVmaW5lZH0gKi9cbiAgICBsZXQgaXNWaXNpYmxlO1xuICAgIC8qKiBAdHlwZSB7Tm9kZUpTLlRpbWVvdXQgfCBudWxsfSAqL1xuXG4gICAgbGV0IGRlbGF5VGltZW91dCA9IG51bGw7XG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFkZFxyXG4gICAgICovXG5cbiAgICBjb25zdCB0b2dnbGVJbmRpY2F0b3JDbGFzcyA9IChjbGFzc05hbWUsIGFkZCkgPT4ge1xuICAgICAgaW5kaWNhdG9yRWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKCdwc3dwX19wcmVsb2FkZXItLScgKyBjbGFzc05hbWUsIGFkZCk7XG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gdmlzaWJsZVxyXG4gICAgICovXG5cblxuICAgIGNvbnN0IHNldEluZGljYXRvclZpc2liaWxpdHkgPSB2aXNpYmxlID0+IHtcbiAgICAgIGlmIChpc1Zpc2libGUgIT09IHZpc2libGUpIHtcbiAgICAgICAgaXNWaXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgdG9nZ2xlSW5kaWNhdG9yQ2xhc3MoJ2FjdGl2ZScsIHZpc2libGUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5ID0gKCkgPT4ge1xuICAgICAgdmFyIF9wc3dwJGN1cnJTbGlkZTtcblxuICAgICAgaWYgKCEoKF9wc3dwJGN1cnJTbGlkZSA9IHBzd3AuY3VyclNsaWRlKSAhPT0gbnVsbCAmJiBfcHN3cCRjdXJyU2xpZGUgIT09IHZvaWQgMCAmJiBfcHN3cCRjdXJyU2xpZGUuY29udGVudC5pc0xvYWRpbmcoKSkpIHtcbiAgICAgICAgc2V0SW5kaWNhdG9yVmlzaWJpbGl0eShmYWxzZSk7XG5cbiAgICAgICAgaWYgKGRlbGF5VGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dChkZWxheVRpbWVvdXQpO1xuICAgICAgICAgIGRlbGF5VGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghZGVsYXlUaW1lb3V0KSB7XG4gICAgICAgIC8vIGRpc3BsYXkgbG9hZGluZyBpbmRpY2F0b3Igd2l0aCBkZWxheVxuICAgICAgICBkZWxheVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB2YXIgX3Bzd3AkY3VyclNsaWRlMjtcblxuICAgICAgICAgIHNldEluZGljYXRvclZpc2liaWxpdHkoQm9vbGVhbigoX3Bzd3AkY3VyclNsaWRlMiA9IHBzd3AuY3VyclNsaWRlKSA9PT0gbnVsbCB8fCBfcHN3cCRjdXJyU2xpZGUyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcHN3cCRjdXJyU2xpZGUyLmNvbnRlbnQuaXNMb2FkaW5nKCkpKTtcbiAgICAgICAgICBkZWxheVRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9LCBwc3dwLm9wdGlvbnMucHJlbG9hZGVyRGVsYXkpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBwc3dwLm9uKCdjaGFuZ2UnLCB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KTtcbiAgICBwc3dwLm9uKCdsb2FkQ29tcGxldGUnLCBlID0+IHtcbiAgICAgIGlmIChwc3dwLmN1cnJTbGlkZSA9PT0gZS5zbGlkZSkge1xuICAgICAgICB1cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5KCk7XG4gICAgICB9XG4gICAgfSk7IC8vIGV4cG9zZSB0aGUgbWV0aG9kXG5cbiAgICBpZiAocHN3cC51aSkge1xuICAgICAgcHN3cC51aS51cGRhdGVQcmVsb2FkZXJWaXNpYmlsaXR5ID0gdXBkYXRlUHJlbG9hZGVyVmlzaWJpbGl0eTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAdHlwZSB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXG5jb25zdCBjb3VudGVySW5kaWNhdG9yID0ge1xuICBuYW1lOiAnY291bnRlcicsXG4gIG9yZGVyOiA1LFxuICBvbkluaXQ6IChjb3VudGVyRWxlbWVudCwgcHN3cCkgPT4ge1xuICAgIHBzd3Aub24oJ2NoYW5nZScsICgpID0+IHtcbiAgICAgIGNvdW50ZXJFbGVtZW50LmlubmVyVGV4dCA9IHBzd3AuY3VyckluZGV4ICsgMSArIHBzd3Aub3B0aW9ucy5pbmRleEluZGljYXRvclNlcCArIHBzd3AuZ2V0TnVtSXRlbXMoKTtcbiAgICB9KTtcbiAgfVxufTtcblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3VpLWVsZW1lbnQuanMnKS5VSUVsZW1lbnREYXRhfSBVSUVsZW1lbnREYXRhICovXG5cbi8qKlxyXG4gKiBTZXQgc3BlY2lhbCBjbGFzcyBvbiBlbGVtZW50IHdoZW4gaW1hZ2UgaXMgem9vbWVkLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCBpdCBpcyB1c2VkIHRvIGFkanVzdFxyXG4gKiB6b29tIGljb24gYW5kIHpvb20gY3Vyc29yIHZpYSBDU1MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNab29tZWRJblxyXG4gKi9cblxuZnVuY3Rpb24gc2V0Wm9vbWVkSW4oZWwsIGlzWm9vbWVkSW4pIHtcbiAgZWwuY2xhc3NMaXN0LnRvZ2dsZSgncHN3cC0tem9vbWVkLWluJywgaXNab29tZWRJbik7XG59XG5cbmNsYXNzIFVJIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xuICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtVSUVsZW1lbnREYXRhW119ICovXG5cbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhID0gW107XG4gICAgLyoqIEB0eXBlIHsoVUlFbGVtZW50IHwgVUlFbGVtZW50RGF0YSlbXX0gKi9cblxuICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAvKiogQHR5cGUgeygpID0+IHZvaWR9ICovXG5cbiAgICB0aGlzLnVwZGF0ZVByZWxvYWRlclZpc2liaWxpdHkgPSAoKSA9PiB7fTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7bnVtYmVyIHwgdW5kZWZpbmVkfVxyXG4gICAgICovXG5cblxuICAgIHRoaXMuX2xhc3RVcGRhdGVkWm9vbUxldmVsID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7XG4gICAgdGhpcy5pc1JlZ2lzdGVyZWQgPSBmYWxzZTtcbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhID0gW2Nsb3NlQnV0dG9uLCBhcnJvd1ByZXYsIGFycm93TmV4dCwgem9vbUJ1dHRvbiwgbG9hZGluZ0luZGljYXRvciwgY291bnRlckluZGljYXRvcl07XG4gICAgcHN3cC5kaXNwYXRjaCgndWlSZWdpc3RlcicpOyAvLyBzb3J0IGJ5IG9yZGVyXG5cbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIC8vIGRlZmF1bHQgb3JkZXIgaXMgMFxuICAgICAgcmV0dXJuIChhLm9yZGVyIHx8IDApIC0gKGIub3JkZXIgfHwgMCk7XG4gICAgfSk7XG4gICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIHRoaXMuaXNSZWdpc3RlcmVkID0gdHJ1ZTtcbiAgICB0aGlzLnVpRWxlbWVudHNEYXRhLmZvckVhY2godWlFbGVtZW50RGF0YSA9PiB7XG4gICAgICB0aGlzLnJlZ2lzdGVyRWxlbWVudCh1aUVsZW1lbnREYXRhKTtcbiAgICB9KTtcbiAgICBwc3dwLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICB2YXIgX3Bzd3AkZWxlbWVudDtcblxuICAgICAgKF9wc3dwJGVsZW1lbnQgPSBwc3dwLmVsZW1lbnQpID09PSBudWxsIHx8IF9wc3dwJGVsZW1lbnQgPT09IHZvaWQgMCB8fCBfcHN3cCRlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoJ3Bzd3AtLW9uZS1zbGlkZScsIHBzd3AuZ2V0TnVtSXRlbXMoKSA9PT0gMSk7XG4gICAgfSk7XG4gICAgcHN3cC5vbignem9vbVBhblVwZGF0ZScsICgpID0+IHRoaXMuX29uWm9vbVBhblVwZGF0ZSgpKTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1VJRWxlbWVudERhdGF9IGVsZW1lbnREYXRhXHJcbiAgICovXG5cblxuICByZWdpc3RlckVsZW1lbnQoZWxlbWVudERhdGEpIHtcbiAgICBpZiAodGhpcy5pc1JlZ2lzdGVyZWQpIHtcbiAgICAgIHRoaXMuaXRlbXMucHVzaChuZXcgVUlFbGVtZW50KHRoaXMucHN3cCwgZWxlbWVudERhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51aUVsZW1lbnRzRGF0YS5wdXNoKGVsZW1lbnREYXRhKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRmlyZWQgZWFjaCB0aW1lIHpvb20gb3IgcGFuIHBvc2l0aW9uIGlzIGNoYW5nZWQuXHJcbiAgICogVXBkYXRlIGNsYXNzZXMgdGhhdCBjb250cm9sIHZpc2liaWxpdHkgb2Ygem9vbSBidXR0b24gYW5kIGN1cnNvciBpY29uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cblxuXG4gIF9vblpvb21QYW5VcGRhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgdGVtcGxhdGUsXG4gICAgICBjdXJyU2xpZGUsXG4gICAgICBvcHRpb25zXG4gICAgfSA9IHRoaXMucHN3cDtcblxuICAgIGlmICh0aGlzLnBzd3Aub3BlbmVyLmlzQ2xvc2luZyB8fCAhdGVtcGxhdGUgfHwgIWN1cnJTbGlkZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCB7XG4gICAgICBjdXJyWm9vbUxldmVsXG4gICAgfSA9IGN1cnJTbGlkZTsgLy8gaWYgbm90IG9wZW4geWV0IC0gY2hlY2sgYWdhaW5zdCBpbml0aWFsIHpvb20gbGV2ZWxcblxuICAgIGlmICghdGhpcy5wc3dwLm9wZW5lci5pc09wZW4pIHtcbiAgICAgIGN1cnJab29tTGV2ZWwgPSBjdXJyU2xpZGUuem9vbUxldmVscy5pbml0aWFsO1xuICAgIH1cblxuICAgIGlmIChjdXJyWm9vbUxldmVsID09PSB0aGlzLl9sYXN0VXBkYXRlZFpvb21MZXZlbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2xhc3RVcGRhdGVkWm9vbUxldmVsID0gY3Vyclpvb21MZXZlbDtcbiAgICBjb25zdCBjdXJyWm9vbUxldmVsRGlmZiA9IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWwgLSBjdXJyU2xpZGUuem9vbUxldmVscy5zZWNvbmRhcnk7IC8vIEluaXRpYWwgYW5kIHNlY29uZGFyeSB6b29tIGxldmVscyBhcmUgYWxtb3N0IGVxdWFsXG5cbiAgICBpZiAoTWF0aC5hYnMoY3Vyclpvb21MZXZlbERpZmYpIDwgMC4wMSB8fCAhY3VyclNsaWRlLmlzWm9vbWFibGUoKSkge1xuICAgICAgLy8gZGlzYWJsZSB6b29tXG4gICAgICBzZXRab29tZWRJbih0ZW1wbGF0ZSwgZmFsc2UpO1xuICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LnJlbW92ZSgncHN3cC0tem9vbS1hbGxvd2VkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHN3cC0tem9vbS1hbGxvd2VkJyk7XG4gICAgY29uc3QgcG90ZW50aWFsWm9vbUxldmVsID0gY3Vyclpvb21MZXZlbCA9PT0gY3VyclNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCA/IGN1cnJTbGlkZS56b29tTGV2ZWxzLnNlY29uZGFyeSA6IGN1cnJTbGlkZS56b29tTGV2ZWxzLmluaXRpYWw7XG4gICAgc2V0Wm9vbWVkSW4odGVtcGxhdGUsIHBvdGVudGlhbFpvb21MZXZlbCA8PSBjdXJyWm9vbUxldmVsKTtcblxuICAgIGlmIChvcHRpb25zLmltYWdlQ2xpY2tBY3Rpb24gPT09ICd6b29tJyB8fCBvcHRpb25zLmltYWdlQ2xpY2tBY3Rpb24gPT09ICd6b29tLW9yLWNsb3NlJykge1xuICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCgncHN3cC0tY2xpY2stdG8tem9vbScpO1xuICAgIH1cbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlLmpzJykuU2xpZGVEYXRhfSBTbGlkZURhdGEgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXI7IHk6IG51bWJlcjsgdzogbnVtYmVyOyBpbm5lclJlY3Q/OiB7IHc6IG51bWJlcjsgaDogbnVtYmVyOyB4OiBudW1iZXI7IHk6IG51bWJlciB9IH19IEJvdW5kcyAqL1xuXG4vKipcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHJldHVybnMgQm91bmRzXHJcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRzQnlFbGVtZW50KGVsKSB7XG4gIGNvbnN0IHRodW1iQXJlYVJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiB0aHVtYkFyZWFSZWN0LmxlZnQsXG4gICAgeTogdGh1bWJBcmVhUmVjdC50b3AsXG4gICAgdzogdGh1bWJBcmVhUmVjdC53aWR0aFxuICB9O1xufVxuLyoqXHJcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbWFnZVdpZHRoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbWFnZUhlaWdodFxyXG4gKiBAcmV0dXJucyBCb3VuZHNcclxuICovXG5cblxuZnVuY3Rpb24gZ2V0Q3JvcHBlZEJvdW5kc0J5RWxlbWVudChlbCwgaW1hZ2VXaWR0aCwgaW1hZ2VIZWlnaHQpIHtcbiAgY29uc3QgdGh1bWJBcmVhUmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyBmaWxsIGltYWdlIGludG8gdGhlIGFyZWFcbiAgLy8gKGRvIHRoZXkgc2FtZSBhcyBvYmplY3QtZml0OmNvdmVyIGRvZXMgdG8gcmV0cmlldmUgY29vcmRpbmF0ZXMpXG5cbiAgY29uc3QgaFJhdGlvID0gdGh1bWJBcmVhUmVjdC53aWR0aCAvIGltYWdlV2lkdGg7XG4gIGNvbnN0IHZSYXRpbyA9IHRodW1iQXJlYVJlY3QuaGVpZ2h0IC8gaW1hZ2VIZWlnaHQ7XG4gIGNvbnN0IGZpbGxab29tTGV2ZWwgPSBoUmF0aW8gPiB2UmF0aW8gPyBoUmF0aW8gOiB2UmF0aW87XG4gIGNvbnN0IG9mZnNldFggPSAodGh1bWJBcmVhUmVjdC53aWR0aCAtIGltYWdlV2lkdGggKiBmaWxsWm9vbUxldmVsKSAvIDI7XG4gIGNvbnN0IG9mZnNldFkgPSAodGh1bWJBcmVhUmVjdC5oZWlnaHQgLSBpbWFnZUhlaWdodCAqIGZpbGxab29tTGV2ZWwpIC8gMjtcbiAgLyoqXHJcbiAgICogQ29vcmRpbmF0ZXMgb2YgdGhlIGltYWdlLFxyXG4gICAqIGFzIGlmIGl0IHdhcyBub3QgY3JvcHBlZCxcclxuICAgKiBoZWlnaHQgaXMgY2FsY3VsYXRlZCBhdXRvbWF0aWNhbGx5XHJcbiAgICpcclxuICAgKiBAdHlwZSB7Qm91bmRzfVxyXG4gICAqL1xuXG4gIGNvbnN0IGJvdW5kcyA9IHtcbiAgICB4OiB0aHVtYkFyZWFSZWN0LmxlZnQgKyBvZmZzZXRYLFxuICAgIHk6IHRodW1iQXJlYVJlY3QudG9wICsgb2Zmc2V0WSxcbiAgICB3OiBpbWFnZVdpZHRoICogZmlsbFpvb21MZXZlbFxuICB9OyAvLyBDb29yZGluYXRlcyBvZiBpbm5lciBjcm9wIGFyZWFcbiAgLy8gcmVsYXRpdmUgdG8gdGhlIGltYWdlXG5cbiAgYm91bmRzLmlubmVyUmVjdCA9IHtcbiAgICB3OiB0aHVtYkFyZWFSZWN0LndpZHRoLFxuICAgIGg6IHRodW1iQXJlYVJlY3QuaGVpZ2h0LFxuICAgIHg6IG9mZnNldFgsXG4gICAgeTogb2Zmc2V0WVxuICB9O1xuICByZXR1cm4gYm91bmRzO1xufVxuLyoqXHJcbiAqIEdldCBkaW1lbnNpb25zIG9mIHRodW1ibmFpbCBpbWFnZVxyXG4gKiAoY2xpY2sgb24gd2hpY2ggb3BlbnMgcGhvdG9zd2lwZSBvciBjbG9zZXMgcGhvdG9zd2lwZSB0bylcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YVxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGV9IGluc3RhbmNlIFBob3RvU3dpcGUgaW5zdGFuY2VcclxuICogQHJldHVybnMge0JvdW5kcyB8IHVuZGVmaW5lZH1cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0VGh1bWJCb3VuZHMoaW5kZXgsIGl0ZW1EYXRhLCBpbnN0YW5jZSkge1xuICAvLyBsZWdhY3kgZXZlbnQsIGJlZm9yZSBmaWx0ZXJzIHdlcmUgaW50cm9kdWNlZFxuICBjb25zdCBldmVudCA9IGluc3RhbmNlLmRpc3BhdGNoKCd0aHVtYkJvdW5kcycsIHtcbiAgICBpbmRleCxcbiAgICBpdGVtRGF0YSxcbiAgICBpbnN0YW5jZVxuICB9KTsgLy8gQHRzLWV4cGVjdC1lcnJvclxuXG4gIGlmIChldmVudC50aHVtYkJvdW5kcykge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gZXZlbnQudGh1bWJCb3VuZHM7XG4gIH1cblxuICBjb25zdCB7XG4gICAgZWxlbWVudFxuICB9ID0gaXRlbURhdGE7XG4gIC8qKiBAdHlwZSB7Qm91bmRzIHwgdW5kZWZpbmVkfSAqL1xuXG4gIGxldCB0aHVtYkJvdW5kcztcbiAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWR9ICovXG5cbiAgbGV0IHRodW1ibmFpbDtcblxuICBpZiAoZWxlbWVudCAmJiBpbnN0YW5jZS5vcHRpb25zLnRodW1iU2VsZWN0b3IgIT09IGZhbHNlKSB7XG4gICAgY29uc3QgdGh1bWJTZWxlY3RvciA9IGluc3RhbmNlLm9wdGlvbnMudGh1bWJTZWxlY3RvciB8fCAnaW1nJztcbiAgICB0aHVtYm5haWwgPSBlbGVtZW50Lm1hdGNoZXModGh1bWJTZWxlY3RvcikgPyBlbGVtZW50IDpcbiAgICAvKiogQHR5cGUge0hUTUxFbGVtZW50IHwgbnVsbH0gKi9cbiAgICBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IodGh1bWJTZWxlY3Rvcik7XG4gIH1cblxuICB0aHVtYm5haWwgPSBpbnN0YW5jZS5hcHBseUZpbHRlcnMoJ3RodW1iRWwnLCB0aHVtYm5haWwsIGl0ZW1EYXRhLCBpbmRleCk7XG5cbiAgaWYgKHRodW1ibmFpbCkge1xuICAgIGlmICghaXRlbURhdGEudGh1bWJDcm9wcGVkKSB7XG4gICAgICB0aHVtYkJvdW5kcyA9IGdldEJvdW5kc0J5RWxlbWVudCh0aHVtYm5haWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHVtYkJvdW5kcyA9IGdldENyb3BwZWRCb3VuZHNCeUVsZW1lbnQodGh1bWJuYWlsLCBpdGVtRGF0YS53aWR0aCB8fCBpdGVtRGF0YS53IHx8IDAsIGl0ZW1EYXRhLmhlaWdodCB8fCBpdGVtRGF0YS5oIHx8IDApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZS5hcHBseUZpbHRlcnMoJ3RodW1iQm91bmRzJywgdGh1bWJCb3VuZHMsIGl0ZW1EYXRhLCBpbmRleCk7XG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9saWdodGJveC9saWdodGJveC5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGVMaWdodGJveCAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5QaG90b1N3aXBlT3B0aW9uc30gUGhvdG9Td2lwZU9wdGlvbnMgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5EYXRhU291cmNlfSBEYXRhU291cmNlICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi91aS91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vc2xpZGUvY29udGVudC5qcycpLmRlZmF1bHR9IENvbnRlbnREZWZhdWx0ICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9zbGlkZS5qcycpLmRlZmF1bHR9IFNsaWRlICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS96b29tLWxldmVsLmpzJykuZGVmYXVsdH0gWm9vbUxldmVsICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9zbGlkZS9nZXQtdGh1bWItYm91bmRzLmpzJykuQm91bmRzfSBCb3VuZHMgKi9cblxuLyoqXHJcbiAqIEFsbG93IGFkZGluZyBhbiBhcmJpdHJhcnkgcHJvcHMgdG8gdGhlIENvbnRlbnRcclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9jdXN0b20tY29udGVudC8jdXNpbmctd2VicC1pbWFnZS1mb3JtYXRcclxuICogQHR5cGVkZWYge0NvbnRlbnREZWZhdWx0ICYgUmVjb3JkPHN0cmluZywgYW55Pn0gQ29udGVudFxyXG4gKi9cblxuLyoqIEB0eXBlZGVmIHt7IHg/OiBudW1iZXI7IHk/OiBudW1iZXIgfX0gUG9pbnQgKi9cblxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFBob3RvU3dpcGVFdmVudHNNYXAgaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9ldmVudHMvXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vYWRkaW5nLXVpLWVsZW1lbnRzL1xyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSB1aVJlZ2lzdGVyXHJcbiAqIEBwcm9wIHt7IGRhdGE6IFVJRWxlbWVudERhdGEgfX0gdWlFbGVtZW50Q3JlYXRlXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNpbml0aWFsaXphdGlvbi1ldmVudHNcclxuICpcclxuICogQHByb3Age3VuZGVmaW5lZH0gYmVmb3JlT3BlblxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBmaXJzdFVwZGF0ZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0aWFsTGF5b3V0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGNoYW5nZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBhZnRlckluaXRcclxuICogQHByb3Age3VuZGVmaW5lZH0gYmluZEV2ZW50c1xyXG4gKlxyXG4gKlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2V2ZW50cy8jb3BlbmluZy1vci1jbG9zaW5nLXRyYW5zaXRpb24tZXZlbnRzXHJcbiAqXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IG9wZW5pbmdBbmltYXRpb25TdGFydFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBvcGVuaW5nQW5pbWF0aW9uRW5kXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGNsb3NpbmdBbmltYXRpb25TdGFydFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjbG9zaW5nQW5pbWF0aW9uRW5kXHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNjbG9zaW5nLWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBjbG9zZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBkZXN0cm95XHJcbiAqXHJcbiAqXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZXZlbnRzLyNwb2ludGVyLWFuZC1nZXN0dXJlLWV2ZW50c1xyXG4gKlxyXG4gKiBAcHJvcCB7eyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gcG9pbnRlckRvd25cclxuICogQHByb3Age3sgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50IH19IHBvaW50ZXJNb3ZlXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB9fSBwb2ludGVyVXBcclxuICogQHByb3Age3sgYmdPcGFjaXR5OiBudW1iZXIgfX0gcGluY2hDbG9zZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcGFuWTogbnVtYmVyIH19IHZlcnRpY2FsRHJhZyBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICpcclxuICpcclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9ldmVudHMvI3NsaWRlLWNvbnRlbnQtZXZlbnRzXHJcbiAqXHJcbiAqIEBwcm9wIHt7IGNvbnRlbnQ6IENvbnRlbnQgfX0gY29udGVudEluaXRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgaXNMYXp5OiBib29sZWFuIH19IGNvbnRlbnRMb2FkIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyBpc0xhenk6IGJvb2xlYW4gfX0gY29udGVudExvYWRJbWFnZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgc2xpZGU6IFNsaWRlOyBpc0Vycm9yPzogYm9vbGVhbiB9fSBsb2FkQ29tcGxldGVcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudDsgc2xpZGU6IFNsaWRlIH19IGxvYWRFcnJvclxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlciB9fSBjb250ZW50UmVzaXplIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50OyB3aWR0aDogbnVtYmVyOyBoZWlnaHQ6IG51bWJlcjsgc2xpZGU6IFNsaWRlIH19IGltYWdlU2l6ZUNoYW5nZVxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnRMYXp5TG9hZCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50QXBwZW5kIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnRBY3RpdmF0ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50RGVhY3RpdmF0ZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50UmVtb3ZlIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBjb250ZW50OiBDb250ZW50IH19IGNvbnRlbnREZXN0cm95IGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKlxyXG4gKlxyXG4gKiB1bmRvY3VtZW50ZWRcclxuICpcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gaW1hZ2VDbGlja0FjdGlvbiBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gYmdDbGlja0FjdGlvbiBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgcG9pbnQ6IFBvaW50OyBvcmlnaW5hbEV2ZW50OiBQb2ludGVyRXZlbnQgfX0gdGFwQWN0aW9uIGNhbiBiZSBkZWZhdWx0IHByZXZlbnRlZFxyXG4gKiBAcHJvcCB7eyBwb2ludDogUG9pbnQ7IG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB9fSBkb3VibGVUYXBBY3Rpb24gY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqXHJcbiAqIEBwcm9wIHt7IG9yaWdpbmFsRXZlbnQ6IEtleWJvYXJkRXZlbnQgfX0ga2V5ZG93biBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgeDogbnVtYmVyOyBkcmFnZ2luZzogYm9vbGVhbiB9fSBtb3ZlTWFpblNjcm9sbFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gZmlyc3Rab29tUGFuXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB8IHVuZGVmaW5lZCwgZGF0YTogU2xpZGVEYXRhLCBpbmRleDogbnVtYmVyIH19IGdldHRpbmdEYXRhXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGJlZm9yZVJlc2l6ZVxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSByZXNpemVcclxuICogQHByb3Age3VuZGVmaW5lZH0gdmlld3BvcnRTaXplXHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IHVwZGF0ZVNjcm9sbE9mZnNldFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gc2xpZGVJbml0XHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBhZnRlclNldENvbnRlbnRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlTG9hZFxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gYXBwZW5kSGVhdnkgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IHNsaWRlOiBTbGlkZSB9fSBhcHBlbmRIZWF2eUNvbnRlbnRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlQWN0aXZhdGVcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IHNsaWRlRGVhY3RpdmF0ZVxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gc2xpZGVEZXN0cm95XHJcbiAqIEBwcm9wIHt7IGRlc3Rab29tTGV2ZWw6IG51bWJlciwgY2VudGVyUG9pbnQ6IFBvaW50IHwgdW5kZWZpbmVkLCB0cmFuc2l0aW9uRHVyYXRpb246IG51bWJlciB8IGZhbHNlIHwgdW5kZWZpbmVkIH19IGJlZm9yZVpvb21Ub1xyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gem9vbVBhblVwZGF0ZVxyXG4gKiBAcHJvcCB7eyBzbGlkZTogU2xpZGUgfX0gaW5pdGlhbFpvb21QYW5cclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGNhbGNTbGlkZVNpemVcclxuICogQHByb3Age3VuZGVmaW5lZH0gcmVzb2x1dGlvbkNoYW5nZWRcclxuICogQHByb3Age3sgb3JpZ2luYWxFdmVudDogV2hlZWxFdmVudCB9fSB3aGVlbCBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3sgY29udGVudDogQ29udGVudCB9fSBjb250ZW50QXBwZW5kSW1hZ2UgY2FuIGJlIGRlZmF1bHQgcHJldmVudGVkXHJcbiAqIEBwcm9wIHt7IGluZGV4OiBudW1iZXI7IGl0ZW1EYXRhOiBTbGlkZURhdGEgfX0gbGF6eUxvYWRTbGlkZSBjYW4gYmUgZGVmYXVsdCBwcmV2ZW50ZWRcclxuICogQHByb3Age3VuZGVmaW5lZH0gbGF6eUxvYWRcclxuICogQHByb3Age3sgc2xpZGU6IFNsaWRlIH19IGNhbGNCb3VuZHNcclxuICogQHByb3Age3sgem9vbUxldmVsczogWm9vbUxldmVsLCBzbGlkZURhdGE6IFNsaWRlRGF0YSB9fSB6b29tTGV2ZWxzVXBkYXRlXHJcbiAqXHJcbiAqXHJcbiAqIGxlZ2FjeVxyXG4gKlxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0XHJcbiAqIEBwcm9wIHt1bmRlZmluZWR9IGluaXRpYWxab29tSW5cclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbFpvb21PdXRcclxuICogQHByb3Age3VuZGVmaW5lZH0gaW5pdGlhbFpvb21JbkVuZFxyXG4gKiBAcHJvcCB7dW5kZWZpbmVkfSBpbml0aWFsWm9vbU91dEVuZFxyXG4gKiBAcHJvcCB7eyBkYXRhU291cmNlOiBEYXRhU291cmNlIHwgdW5kZWZpbmVkLCBudW1JdGVtczogbnVtYmVyIH19IG51bUl0ZW1zXHJcbiAqIEBwcm9wIHt7IGl0ZW1EYXRhOiBTbGlkZURhdGE7IGluZGV4OiBudW1iZXIgfX0gaXRlbURhdGFcclxuICogQHByb3Age3sgaW5kZXg6IG51bWJlciwgaXRlbURhdGE6IFNsaWRlRGF0YSwgaW5zdGFuY2U6IFBob3RvU3dpcGUgfX0gdGh1bWJCb3VuZHNcclxuICovXG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQaG90b1N3aXBlRmlsdGVyc01hcCBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvXHJcbiAqXHJcbiAqIEBwcm9wIHsobnVtSXRlbXM6IG51bWJlciwgZGF0YVNvdXJjZTogRGF0YVNvdXJjZSB8IHVuZGVmaW5lZCkgPT4gbnVtYmVyfSBudW1JdGVtc1xyXG4gKiBNb2RpZnkgdGhlIHRvdGFsIGFtb3VudCBvZiBzbGlkZXMuIEV4YW1wbGUgb24gRGF0YSBzb3VyY2VzIHBhZ2UuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jbnVtaXRlbXNcclxuICpcclxuICogQHByb3AgeyhpdGVtRGF0YTogU2xpZGVEYXRhLCBpbmRleDogbnVtYmVyKSA9PiBTbGlkZURhdGF9IGl0ZW1EYXRhXHJcbiAqIE1vZGlmeSBzbGlkZSBpdGVtIGRhdGEuIEV4YW1wbGUgb24gRGF0YSBzb3VyY2VzIHBhZ2UuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jaXRlbWRhdGFcclxuICpcclxuICogQHByb3AgeyhpdGVtRGF0YTogU2xpZGVEYXRhLCBlbGVtZW50OiBIVE1MRWxlbWVudCwgbGlua0VsOiBIVE1MQW5jaG9yRWxlbWVudCkgPT4gU2xpZGVEYXRhfSBkb21JdGVtRGF0YVxyXG4gKiBNb2RpZnkgaXRlbSBkYXRhIHdoZW4gaXQncyBwYXJzZWQgZnJvbSBET00gZWxlbWVudC4gRXhhbXBsZSBvbiBEYXRhIHNvdXJjZXMgcGFnZS5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNkb21pdGVtZGF0YVxyXG4gKlxyXG4gKiBAcHJvcCB7KGNsaWNrZWRJbmRleDogbnVtYmVyLCBlOiBNb3VzZUV2ZW50LCBpbnN0YW5jZTogUGhvdG9Td2lwZUxpZ2h0Ym94KSA9PiBudW1iZXJ9IGNsaWNrZWRJbmRleFxyXG4gKiBNb2RpZnkgY2xpY2tlZCBnYWxsZXJ5IGl0ZW0gaW5kZXguXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jY2xpY2tlZGluZGV4XHJcbiAqXHJcbiAqIEBwcm9wIHsocGxhY2Vob2xkZXJTcmM6IHN0cmluZyB8IGZhbHNlLCBjb250ZW50OiBDb250ZW50KSA9PiBzdHJpbmcgfCBmYWxzZX0gcGxhY2Vob2xkZXJTcmNcclxuICogTW9kaWZ5IHBsYWNlaG9sZGVyIGltYWdlIHNvdXJjZS5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNwbGFjZWhvbGRlcnNyY1xyXG4gKlxyXG4gKiBAcHJvcCB7KGlzQ29udGVudExvYWRpbmc6IGJvb2xlYW4sIGNvbnRlbnQ6IENvbnRlbnQpID0+IGJvb2xlYW59IGlzQ29udGVudExvYWRpbmdcclxuICogTW9kaWZ5IGlmIHRoZSBjb250ZW50IGlzIGN1cnJlbnRseSBsb2FkaW5nLlxyXG4gKiBodHRwczovL3Bob3Rvc3dpcGUuY29tL2ZpbHRlcnMvI2lzY29udGVudGxvYWRpbmdcclxuICpcclxuICogQHByb3Ageyhpc0NvbnRlbnRab29tYWJsZTogYm9vbGVhbiwgY29udGVudDogQ29udGVudCkgPT4gYm9vbGVhbn0gaXNDb250ZW50Wm9vbWFibGVcclxuICogTW9kaWZ5IGlmIHRoZSBjb250ZW50IGNhbiBiZSB6b29tZWQuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jaXNjb250ZW50em9vbWFibGVcclxuICpcclxuICogQHByb3Ageyh1c2VDb250ZW50UGxhY2Vob2xkZXI6IGJvb2xlYW4sIGNvbnRlbnQ6IENvbnRlbnQpID0+IGJvb2xlYW59IHVzZUNvbnRlbnRQbGFjZWhvbGRlclxyXG4gKiBNb2RpZnkgaWYgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSB1c2VkIGZvciB0aGUgY29udGVudC5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyN1c2Vjb250ZW50cGxhY2Vob2xkZXJcclxuICpcclxuICogQHByb3Ageyhpc0tlZXBpbmdQbGFjZWhvbGRlcjogYm9vbGVhbiwgY29udGVudDogQ29udGVudCkgPT4gYm9vbGVhbn0gaXNLZWVwaW5nUGxhY2Vob2xkZXJcclxuICogTW9kaWZ5IGlmIHRoZSBwbGFjZWhvbGRlciBzaG91bGQgYmUga2VwdCBhZnRlciB0aGUgY29udGVudCBpcyBsb2FkZWQuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jaXNrZWVwaW5ncGxhY2Vob2xkZXJcclxuICpcclxuICpcclxuICogQHByb3Ageyhjb250ZW50RXJyb3JFbGVtZW50OiBIVE1MRWxlbWVudCwgY29udGVudDogQ29udGVudCkgPT4gSFRNTEVsZW1lbnR9IGNvbnRlbnRFcnJvckVsZW1lbnRcclxuICogTW9kaWZ5IGFuIGVsZW1lbnQgd2hlbiB0aGUgY29udGVudCBoYXMgZXJyb3Igc3RhdGUgKGZvciBleGFtcGxlLCBpZiBpbWFnZSBjYW5ub3QgYmUgbG9hZGVkKS5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyNjb250ZW50ZXJyb3JlbGVtZW50XHJcbiAqXHJcbiAqIEBwcm9wIHsoZWxlbWVudDogSFRNTEVsZW1lbnQsIGRhdGE6IFVJRWxlbWVudERhdGEpID0+IEhUTUxFbGVtZW50fSB1aUVsZW1lbnRcclxuICogTW9kaWZ5IGEgVUkgZWxlbWVudCB0aGF0J3MgYmVpbmcgY3JlYXRlZC5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyN1aWVsZW1lbnRcclxuICpcclxuICogQHByb3Ageyh0aHVtYm5haWw6IEhUTUxFbGVtZW50IHwgbnVsbCB8IHVuZGVmaW5lZCwgaXRlbURhdGE6IFNsaWRlRGF0YSwgaW5kZXg6IG51bWJlcikgPT4gSFRNTEVsZW1lbnR9IHRodW1iRWxcclxuICogTW9kaWZ5IHRoZSB0aHVtYm5haWwgZWxlbWVudCBmcm9tIHdoaWNoIG9wZW5pbmcgem9vbSBhbmltYXRpb24gc3RhcnRzIG9yIGVuZHMuXHJcbiAqIGh0dHBzOi8vcGhvdG9zd2lwZS5jb20vZmlsdGVycy8jdGh1bWJlbFxyXG4gKlxyXG4gKiBAcHJvcCB7KHRodW1iQm91bmRzOiBCb3VuZHMgfCB1bmRlZmluZWQsIGl0ZW1EYXRhOiBTbGlkZURhdGEsIGluZGV4OiBudW1iZXIpID0+IEJvdW5kc30gdGh1bWJCb3VuZHNcclxuICogTW9kaWZ5IHRoZSB0aHVtYm5haWwgYm91bmRzIGZyb20gd2hpY2ggb3BlbmluZyB6b29tIGFuaW1hdGlvbiBzdGFydHMgb3IgZW5kcy5cclxuICogaHR0cHM6Ly9waG90b3N3aXBlLmNvbS9maWx0ZXJzLyN0aHVtYmJvdW5kc1xyXG4gKlxyXG4gKiBAcHJvcCB7KHNyY3NldFNpemVzV2lkdGg6IG51bWJlciwgY29udGVudDogQ29udGVudCkgPT4gbnVtYmVyfSBzcmNzZXRTaXplc1dpZHRoXHJcbiAqXHJcbiAqIEBwcm9wIHsocHJldmVudFBvaW50ZXJFdmVudDogYm9vbGVhbiwgZXZlbnQ6IFBvaW50ZXJFdmVudCwgcG9pbnRlclR5cGU6IHN0cmluZykgPT4gYm9vbGVhbn0gcHJldmVudFBvaW50ZXJFdmVudFxyXG4gKlxyXG4gKi9cblxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUZpbHRlcnNNYXB9IFRcclxuICogQHR5cGVkZWYge3sgZm46IFBob3RvU3dpcGVGaWx0ZXJzTWFwW1RdLCBwcmlvcml0eTogbnVtYmVyIH19IEZpbHRlclxyXG4gKi9cblxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUV2ZW50c01hcH0gVFxyXG4gKiBAdHlwZWRlZiB7UGhvdG9Td2lwZUV2ZW50c01hcFtUXSBleHRlbmRzIHVuZGVmaW5lZCA/IFBob3RvU3dpcGVFdmVudDxUPiA6IFBob3RvU3dpcGVFdmVudDxUPiAmIFBob3RvU3dpcGVFdmVudHNNYXBbVF19IEF1Z21lbnRlZEV2ZW50XHJcbiAqL1xuXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHsoZXZlbnQ6IEF1Z21lbnRlZEV2ZW50PFQ+KSA9PiB2b2lkfSBFdmVudENhbGxiYWNrXHJcbiAqL1xuXG4vKipcclxuICogQmFzZSBQaG90b1N3aXBlIGV2ZW50IG9iamVjdFxyXG4gKlxyXG4gKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVFdmVudHNNYXB9IFRcclxuICovXG5jbGFzcyBQaG90b1N3aXBlRXZlbnQge1xuICAvKipcclxuICAgKiBAcGFyYW0ge1R9IHR5cGVcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVFdmVudHNNYXBbVF19IFtkZXRhaWxzXVxyXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBkZXRhaWxzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcblxuICAgIGlmIChkZXRhaWxzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGRldGFpbHMpO1xuICAgIH1cbiAgfVxuXG4gIHByZXZlbnREZWZhdWx0KCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gIH1cblxufVxuLyoqXHJcbiAqIFBob3RvU3dpcGUgYmFzZSBjbGFzcyB0aGF0IGNhbiBsaXN0ZW4gYW5kIGRpc3BhdGNoIGZvciBldmVudHMuXHJcbiAqIFNoYXJlZCBieSBQaG90b1N3aXBlIENvcmUgYW5kIFBob3RvU3dpcGUgTGlnaHRib3gsIGV4dGVuZGVkIGJ5IGJhc2UuanNcclxuICovXG5cblxuY2xhc3MgRXZlbnRhYmxlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZSB7eyBbVCBpbiBrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwXT86ICgoZXZlbnQ6IEF1Z21lbnRlZEV2ZW50PFQ+KSA9PiB2b2lkKVtdIH19XHJcbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHt7IFtUIGluIGtleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwXT86IEZpbHRlcjxUPltdIH19XHJcbiAgICAgKi9cblxuICAgIHRoaXMuX2ZpbHRlcnMgPSB7fTtcbiAgICAvKiogQHR5cGUge1Bob3RvU3dpcGUgfCB1bmRlZmluZWR9ICovXG5cbiAgICB0aGlzLnBzd3AgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtQaG90b1N3aXBlT3B0aW9ucyB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMub3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVGaWx0ZXJzTWFwfSBUXHJcbiAgICogQHBhcmFtIHtUfSBuYW1lXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlRmlsdGVyc01hcFtUXX0gZm5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcHJpb3JpdHlcclxuICAgKi9cblxuXG4gIGFkZEZpbHRlcihuYW1lLCBmbiwgcHJpb3JpdHkgPSAxMDApIHtcbiAgICB2YXIgX3RoaXMkX2ZpbHRlcnMkbmFtZSwgX3RoaXMkX2ZpbHRlcnMkbmFtZTIsIF90aGlzJHBzd3A7XG5cbiAgICBpZiAoIXRoaXMuX2ZpbHRlcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMuX2ZpbHRlcnNbbmFtZV0gPSBbXTtcbiAgICB9XG5cbiAgICAoX3RoaXMkX2ZpbHRlcnMkbmFtZSA9IHRoaXMuX2ZpbHRlcnNbbmFtZV0pID09PSBudWxsIHx8IF90aGlzJF9maWx0ZXJzJG5hbWUgPT09IHZvaWQgMCB8fCBfdGhpcyRfZmlsdGVycyRuYW1lLnB1c2goe1xuICAgICAgZm4sXG4gICAgICBwcmlvcml0eVxuICAgIH0pO1xuICAgIChfdGhpcyRfZmlsdGVycyRuYW1lMiA9IHRoaXMuX2ZpbHRlcnNbbmFtZV0pID09PSBudWxsIHx8IF90aGlzJF9maWx0ZXJzJG5hbWUyID09PSB2b2lkIDAgfHwgX3RoaXMkX2ZpbHRlcnMkbmFtZTIuc29ydCgoZjEsIGYyKSA9PiBmMS5wcmlvcml0eSAtIGYyLnByaW9yaXR5KTtcbiAgICAoX3RoaXMkcHN3cCA9IHRoaXMucHN3cCkgPT09IG51bGwgfHwgX3RoaXMkcHN3cCA9PT0gdm9pZCAwIHx8IF90aGlzJHBzd3AuYWRkRmlsdGVyKG5hbWUsIGZuLCBwcmlvcml0eSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRmlsdGVyc01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGhvdG9Td2lwZUZpbHRlcnNNYXBbVF19IGZuXHJcbiAgICovXG5cblxuICByZW1vdmVGaWx0ZXIobmFtZSwgZm4pIHtcbiAgICBpZiAodGhpcy5fZmlsdGVyc1tuYW1lXSkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgdGhpcy5fZmlsdGVyc1tuYW1lXSA9IHRoaXMuX2ZpbHRlcnNbbmFtZV0uZmlsdGVyKGZpbHRlciA9PiBmaWx0ZXIuZm4gIT09IGZuKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wc3dwKSB7XG4gICAgICB0aGlzLnBzd3AucmVtb3ZlRmlsdGVyKG5hbWUsIGZuKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRmlsdGVyc01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7UGFyYW1ldGVyczxQaG90b1N3aXBlRmlsdGVyc01hcFtUXT59IGFyZ3NcclxuICAgKiBAcmV0dXJucyB7UGFyYW1ldGVyczxQaG90b1N3aXBlRmlsdGVyc01hcFtUXT5bMF19XHJcbiAgICovXG5cblxuICBhcHBseUZpbHRlcnMobmFtZSwgLi4uYXJncykge1xuICAgIHZhciBfdGhpcyRfZmlsdGVycyRuYW1lMztcblxuICAgIChfdGhpcyRfZmlsdGVycyRuYW1lMyA9IHRoaXMuX2ZpbHRlcnNbbmFtZV0pID09PSBudWxsIHx8IF90aGlzJF9maWx0ZXJzJG5hbWUzID09PSB2b2lkIDAgfHwgX3RoaXMkX2ZpbHRlcnMkbmFtZTMuZm9yRWFjaChmaWx0ZXIgPT4ge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgYXJnc1swXSA9IGZpbHRlci5mbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVFdmVudHNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge0V2ZW50Q2FsbGJhY2s8VD59IGZuXHJcbiAgICovXG5cblxuICBvbihuYW1lLCBmbikge1xuICAgIHZhciBfdGhpcyRfbGlzdGVuZXJzJG5hbWUsIF90aGlzJHBzd3AyO1xuXG4gICAgaWYgKCF0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXSA9IFtdO1xuICAgIH1cblxuICAgIChfdGhpcyRfbGlzdGVuZXJzJG5hbWUgPSB0aGlzLl9saXN0ZW5lcnNbbmFtZV0pID09PSBudWxsIHx8IF90aGlzJF9saXN0ZW5lcnMkbmFtZSA9PT0gdm9pZCAwIHx8IF90aGlzJF9saXN0ZW5lcnMkbmFtZS5wdXNoKGZuKTsgLy8gV2hlbiBiaW5kaW5nIGV2ZW50cyB0byBsaWdodGJveCxcbiAgICAvLyBhbHNvIGJpbmQgZXZlbnRzIHRvIFBob3RvU3dpcGUgQ29yZSxcbiAgICAvLyBpZiBpdCdzIG9wZW4uXG5cbiAgICAoX3RoaXMkcHN3cDIgPSB0aGlzLnBzd3ApID09PSBudWxsIHx8IF90aGlzJHBzd3AyID09PSB2b2lkIDAgfHwgX3RoaXMkcHN3cDIub24obmFtZSwgZm4pO1xuICB9XG4gIC8qKlxyXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgUGhvdG9Td2lwZUV2ZW50c01hcH0gVFxyXG4gICAqIEBwYXJhbSB7VH0gbmFtZVxyXG4gICAqIEBwYXJhbSB7RXZlbnRDYWxsYmFjazxUPn0gZm5cclxuICAgKi9cblxuXG4gIG9mZihuYW1lLCBmbikge1xuICAgIHZhciBfdGhpcyRwc3dwMztcblxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnNbbmFtZV0pIHtcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tuYW1lXSA9IHRoaXMuX2xpc3RlbmVyc1tuYW1lXS5maWx0ZXIobGlzdGVuZXIgPT4gZm4gIT09IGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAoX3RoaXMkcHN3cDMgPSB0aGlzLnBzd3ApID09PSBudWxsIHx8IF90aGlzJHBzd3AzID09PSB2b2lkIDAgfHwgX3RoaXMkcHN3cDMub2ZmKG5hbWUsIGZuKTtcbiAgfVxuICAvKipcclxuICAgKiBAdGVtcGxhdGUge2tleW9mIFBob3RvU3dpcGVFdmVudHNNYXB9IFRcclxuICAgKiBAcGFyYW0ge1R9IG5hbWVcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVFdmVudHNNYXBbVF19IFtkZXRhaWxzXVxyXG4gICAqIEByZXR1cm5zIHtBdWdtZW50ZWRFdmVudDxUPn1cclxuICAgKi9cblxuXG4gIGRpc3BhdGNoKG5hbWUsIGRldGFpbHMpIHtcbiAgICB2YXIgX3RoaXMkX2xpc3RlbmVycyRuYW1lMjtcblxuICAgIGlmICh0aGlzLnBzd3ApIHtcbiAgICAgIHJldHVybiB0aGlzLnBzd3AuZGlzcGF0Y2gobmFtZSwgZGV0YWlscyk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPVxuICAgIC8qKiBAdHlwZSB7QXVnbWVudGVkRXZlbnQ8VD59ICovXG4gICAgbmV3IFBob3RvU3dpcGVFdmVudChuYW1lLCBkZXRhaWxzKTtcbiAgICAoX3RoaXMkX2xpc3RlbmVycyRuYW1lMiA9IHRoaXMuX2xpc3RlbmVyc1tuYW1lXSkgPT09IG51bGwgfHwgX3RoaXMkX2xpc3RlbmVycyRuYW1lMiA9PT0gdm9pZCAwIHx8IF90aGlzJF9saXN0ZW5lcnMkbmFtZTIuZm9yRWFjaChsaXN0ZW5lciA9PiB7XG4gICAgICBsaXN0ZW5lci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cblxufVxuXG5jbGFzcyBQbGFjZWhvbGRlciB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nIHwgZmFsc2V9IGltYWdlU3JjXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKGltYWdlU3JjLCBjb250YWluZXIpIHtcbiAgICAvLyBDcmVhdGUgcGxhY2Vob2xkZXJcbiAgICAvLyAoc3RyZXRjaGVkIHRodW1ibmFpbCBvciBzaW1wbGUgZGl2IGJlaGluZCB0aGUgbWFpbiBpbWFnZSlcblxuICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudCB8IEhUTUxEaXZFbGVtZW50IHwgbnVsbH0gKi9cbiAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19pbWcgcHN3cF9faW1nLS1wbGFjZWhvbGRlcicsIGltYWdlU3JjID8gJ2ltZycgOiAnZGl2JywgY29udGFpbmVyKTtcblxuICAgIGlmIChpbWFnZVNyYykge1xuICAgICAgY29uc3QgaW1nRWwgPVxuICAgICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50fSAqL1xuICAgICAgdGhpcy5lbGVtZW50O1xuICAgICAgaW1nRWwuZGVjb2RpbmcgPSAnYXN5bmMnO1xuICAgICAgaW1nRWwuYWx0ID0gJyc7XG4gICAgICBpbWdFbC5zcmMgPSBpbWFnZVNyYztcbiAgICAgIGltZ0VsLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gICAqL1xuXG5cbiAgc2V0RGlzcGxheWVkU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50LnRhZ05hbWUgPT09ICdJTUcnKSB7XG4gICAgICAvLyBVc2UgdHJhbnNmb3JtIHNjYWxlKCkgdG8gbW9kaWZ5IGltZyBwbGFjZWhvbGRlciBzaXplXG4gICAgICAvLyAoaW5zdGVhZCBvZiBjaGFuZ2luZyB3aWR0aC9oZWlnaHQgZGlyZWN0bHkpLlxuICAgICAgLy8gVGhpcyBoZWxwcyB3aXRoIHBlcmZvcm1hbmNlLCBzcGVjaWZpY2FsbHkgaW4gaU9TMTUgU2FmYXJpLlxuICAgICAgc2V0V2lkdGhIZWlnaHQodGhpcy5lbGVtZW50LCAyNTAsICdhdXRvJyk7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdG9UcmFuc2Zvcm1TdHJpbmcoMCwgMCwgd2lkdGggLyAyNTApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRXaWR0aEhlaWdodCh0aGlzLmVsZW1lbnQsIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdmFyIF90aGlzJGVsZW1lbnQ7XG5cbiAgICBpZiAoKF90aGlzJGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQpICE9PSBudWxsICYmIF90aGlzJGVsZW1lbnQgIT09IHZvaWQgMCAmJiBfdGhpcyRlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBudWxsO1xuICB9XG5cbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5kZWZhdWx0fSBTbGlkZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuLi9jb3JlL2Jhc2UuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlQmFzZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vdXRpbC91dGlsLmpzJykuTG9hZFN0YXRlfSBMb2FkU3RhdGUgKi9cblxuY2xhc3MgQ29udGVudCB7XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBTbGlkZSBkYXRhXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlQmFzZX0gaW5zdGFuY2UgUGhvdG9Td2lwZSBvciBQaG90b1N3aXBlTGlnaHRib3ggaW5zdGFuY2VcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKi9cbiAgY29uc3RydWN0b3IoaXRlbURhdGEsIGluc3RhbmNlLCBpbmRleCkge1xuICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICB0aGlzLmRhdGEgPSBpdGVtRGF0YTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgLyoqIEB0eXBlIHtIVE1MSW1hZ2VFbGVtZW50IHwgSFRNTERpdkVsZW1lbnQgfCB1bmRlZmluZWR9ICovXG5cbiAgICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtQbGFjZWhvbGRlciB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtTbGlkZSB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMuc2xpZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5kaXNwbGF5ZWRJbWFnZVdpZHRoID0gMDtcbiAgICB0aGlzLmRpc3BsYXllZEltYWdlSGVpZ2h0ID0gMDtcbiAgICB0aGlzLndpZHRoID0gTnVtYmVyKHRoaXMuZGF0YS53KSB8fCBOdW1iZXIodGhpcy5kYXRhLndpZHRoKSB8fCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gTnVtYmVyKHRoaXMuZGF0YS5oKSB8fCBOdW1iZXIodGhpcy5kYXRhLmhlaWdodCkgfHwgMDtcbiAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmhhc1NsaWRlID0gZmFsc2U7XG4gICAgdGhpcy5pc0RlY29kaW5nID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtMb2FkU3RhdGV9ICovXG5cbiAgICB0aGlzLnN0YXRlID0gTE9BRF9TVEFURS5JRExFO1xuXG4gICAgaWYgKHRoaXMuZGF0YS50eXBlKSB7XG4gICAgICB0aGlzLnR5cGUgPSB0aGlzLmRhdGEudHlwZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5zcmMpIHtcbiAgICAgIHRoaXMudHlwZSA9ICdpbWFnZSc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHlwZSA9ICdodG1sJztcbiAgICB9XG5cbiAgICB0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50SW5pdCcsIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZVBsYWNlaG9sZGVyKCkge1xuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyICYmICF0aGlzLmtlZXBQbGFjZWhvbGRlcigpKSB7XG4gICAgICAvLyBXaXRoIGRlbGF5LCBhcyBpbWFnZSBtaWdodCBiZSBsb2FkZWQsIGJ1dCBub3QgcmVuZGVyZWRcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIuZGVzdHJveSgpO1xuICAgICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBQcmVsb2FkIGNvbnRlbnRcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMYXp5XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVsb2FkXVxyXG4gICAqL1xuXG5cbiAgbG9hZChpc0xhenksIHJlbG9hZCkge1xuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMudXNlUGxhY2Vob2xkZXIoKSkge1xuICAgICAgaWYgKCF0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyU3JjID0gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoJ3BsYWNlaG9sZGVyU3JjJywgLy8gdXNlICBpbWFnZS1iYXNlZCBwbGFjZWhvbGRlciBvbmx5IGZvciB0aGUgZmlyc3Qgc2xpZGUsXG4gICAgICAgIC8vIGFzIHJlbmRlcmluZyAoZXZlbiBzbWFsbCBzdHJldGNoZWQgdGh1bWJuYWlsKSBpcyBhbiBleHBlbnNpdmUgb3BlcmF0aW9uXG4gICAgICAgIHRoaXMuZGF0YS5tc3JjICYmIHRoaXMuc2xpZGUuaXNGaXJzdFNsaWRlID8gdGhpcy5kYXRhLm1zcmMgOiBmYWxzZSwgdGhpcyk7XG4gICAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSBuZXcgUGxhY2Vob2xkZXIocGxhY2Vob2xkZXJTcmMsIHRoaXMuc2xpZGUuY29udGFpbmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyRWwgPSB0aGlzLnBsYWNlaG9sZGVyLmVsZW1lbnQ7IC8vIEFkZCBwbGFjZWhvbGRlciB0byBET00gaWYgaXQgd2FzIGFscmVhZHkgY3JlYXRlZFxuXG4gICAgICAgIGlmIChwbGFjZWhvbGRlckVsICYmICFwbGFjZWhvbGRlckVsLnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5wcmVwZW5kKHBsYWNlaG9sZGVyRWwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZWxlbWVudCAmJiAhcmVsb2FkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRMb2FkJywge1xuICAgICAgY29udGVudDogdGhpcyxcbiAgICAgIGlzTGF6eVxuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0ltYWdlQ29udGVudCgpKSB7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19pbWcnLCAnaW1nJyk7IC8vIFN0YXJ0IGxvYWRpbmcgb25seSBhZnRlciB3aWR0aCBpcyBkZWZpbmVkLCBhcyBzaXplcyBtaWdodCBkZXBlbmQgb24gaXQuXG4gICAgICAvLyBEdWUgdG8gU2FmYXJpIGZlYXR1cmUsIHdlIG11c3QgZGVmaW5lIHNpemVzIGJlZm9yZSBzcmNzZXQuXG5cbiAgICAgIGlmICh0aGlzLmRpc3BsYXllZEltYWdlV2lkdGgpIHtcbiAgICAgICAgdGhpcy5sb2FkSW1hZ2UoaXNMYXp5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50ID0gY3JlYXRlRWxlbWVudCgncHN3cF9fY29udGVudCcsICdkaXYnKTtcbiAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLmRhdGEuaHRtbCB8fCAnJztcbiAgICB9XG5cbiAgICBpZiAocmVsb2FkICYmIHRoaXMuc2xpZGUpIHtcbiAgICAgIHRoaXMuc2xpZGUudXBkYXRlQ29udGVudFNpemUodHJ1ZSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFByZWxvYWQgaW1hZ2VcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMYXp5XHJcbiAgICovXG5cblxuICBsb2FkSW1hZ2UoaXNMYXp5KSB7XG4gICAgdmFyIF90aGlzJGRhdGEkc3JjLCBfdGhpcyRkYXRhJGFsdDtcblxuICAgIGlmICghdGhpcy5pc0ltYWdlQ29udGVudCgpIHx8ICF0aGlzLmVsZW1lbnQgfHwgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnY29udGVudExvYWRJbWFnZScsIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXMsXG4gICAgICBpc0xhenlcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VFbGVtZW50ID1cbiAgICAvKiogQHR5cGUgSFRNTEltYWdlRWxlbWVudCAqL1xuICAgIHRoaXMuZWxlbWVudDtcbiAgICB0aGlzLnVwZGF0ZVNyY3NldFNpemVzKCk7XG5cbiAgICBpZiAodGhpcy5kYXRhLnNyY3NldCkge1xuICAgICAgaW1hZ2VFbGVtZW50LnNyY3NldCA9IHRoaXMuZGF0YS5zcmNzZXQ7XG4gICAgfVxuXG4gICAgaW1hZ2VFbGVtZW50LnNyYyA9IChfdGhpcyRkYXRhJHNyYyA9IHRoaXMuZGF0YS5zcmMpICE9PSBudWxsICYmIF90aGlzJGRhdGEkc3JjICE9PSB2b2lkIDAgPyBfdGhpcyRkYXRhJHNyYyA6ICcnO1xuICAgIGltYWdlRWxlbWVudC5hbHQgPSAoX3RoaXMkZGF0YSRhbHQgPSB0aGlzLmRhdGEuYWx0KSAhPT0gbnVsbCAmJiBfdGhpcyRkYXRhJGFsdCAhPT0gdm9pZCAwID8gX3RoaXMkZGF0YSRhbHQgOiAnJztcbiAgICB0aGlzLnN0YXRlID0gTE9BRF9TVEFURS5MT0FESU5HO1xuXG4gICAgaWYgKGltYWdlRWxlbWVudC5jb21wbGV0ZSkge1xuICAgICAgdGhpcy5vbkxvYWRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbWFnZUVsZW1lbnQub25sb2FkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLm9uTG9hZGVkKCk7XG4gICAgICB9O1xuXG4gICAgICBpbWFnZUVsZW1lbnQub25lcnJvciA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vbkVycm9yKCk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBc3NpZ24gc2xpZGUgdG8gY29udGVudFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtTbGlkZX0gc2xpZGVcclxuICAgKi9cblxuXG4gIHNldFNsaWRlKHNsaWRlKSB7XG4gICAgdGhpcy5zbGlkZSA9IHNsaWRlO1xuICAgIHRoaXMuaGFzU2xpZGUgPSB0cnVlO1xuICAgIHRoaXMuaW5zdGFuY2UgPSBzbGlkZS5wc3dwOyAvLyB0b2RvOiBkbyB3ZSBuZWVkIHRvIHVuc2V0IHNsaWRlP1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnRlbnQgbG9hZCBzdWNjZXNzIGhhbmRsZXJcclxuICAgKi9cblxuXG4gIG9uTG9hZGVkKCkge1xuICAgIHRoaXMuc3RhdGUgPSBMT0FEX1NUQVRFLkxPQURFRDtcblxuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMuZWxlbWVudCkge1xuICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnbG9hZENvbXBsZXRlJywge1xuICAgICAgICBzbGlkZTogdGhpcy5zbGlkZSxcbiAgICAgICAgY29udGVudDogdGhpc1xuICAgICAgfSk7IC8vIGlmIGNvbnRlbnQgaXMgcmVsb2FkZWRcblxuICAgICAgaWYgKHRoaXMuc2xpZGUuaXNBY3RpdmUgJiYgdGhpcy5zbGlkZS5oZWF2eUFwcGVuZGVkICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgICB0aGlzLmFwcGVuZCgpO1xuICAgICAgICB0aGlzLnNsaWRlLnVwZGF0ZUNvbnRlbnRTaXplKHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5MT0FERUQgfHwgdGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUikge1xuICAgICAgICB0aGlzLnJlbW92ZVBsYWNlaG9sZGVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIENvbnRlbnQgbG9hZCBlcnJvciBoYW5kbGVyXHJcbiAgICovXG5cblxuICBvbkVycm9yKCkge1xuICAgIHRoaXMuc3RhdGUgPSBMT0FEX1NUQVRFLkVSUk9SO1xuXG4gICAgaWYgKHRoaXMuc2xpZGUpIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKCk7XG4gICAgICB0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdsb2FkQ29tcGxldGUnLCB7XG4gICAgICAgIHNsaWRlOiB0aGlzLnNsaWRlLFxuICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2xvYWRFcnJvcicsIHtcbiAgICAgICAgc2xpZGU6IHRoaXMuc2xpZGUsXG4gICAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgaXMgY3VycmVudGx5IGxvYWRpbmdcclxuICAgKi9cblxuXG4gIGlzTG9hZGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoJ2lzQ29udGVudExvYWRpbmcnLCB0aGlzLnN0YXRlID09PSBMT0FEX1NUQVRFLkxPQURJTkcsIHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBJZiB0aGUgY29udGVudCBpcyBpbiBlcnJvciBzdGF0ZVxyXG4gICAqL1xuXG5cbiAgaXNFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUjtcbiAgfVxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgaXMgaW1hZ2VcclxuICAgKi9cblxuXG4gIGlzSW1hZ2VDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLnR5cGUgPT09ICdpbWFnZSc7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGNvbnRlbnQgc2l6ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdpZHRoXHJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhlaWdodFxyXG4gICAqL1xuXG5cbiAgc2V0RGlzcGxheWVkU2l6ZSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wbGFjZWhvbGRlcikge1xuICAgICAgdGhpcy5wbGFjZWhvbGRlci5zZXREaXNwbGF5ZWRTaXplKHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50UmVzaXplJywge1xuICAgICAgY29udGVudDogdGhpcyxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldFdpZHRoSGVpZ2h0KHRoaXMuZWxlbWVudCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBpZiAodGhpcy5pc0ltYWdlQ29udGVudCgpICYmICF0aGlzLmlzRXJyb3IoKSkge1xuICAgICAgY29uc3QgaXNJbml0aWFsU2l6ZVVwZGF0ZSA9ICF0aGlzLmRpc3BsYXllZEltYWdlV2lkdGggJiYgd2lkdGg7XG4gICAgICB0aGlzLmRpc3BsYXllZEltYWdlV2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuZGlzcGxheWVkSW1hZ2VIZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgIGlmIChpc0luaXRpYWxTaXplVXBkYXRlKSB7XG4gICAgICAgIHRoaXMubG9hZEltYWdlKGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Jjc2V0U2l6ZXMoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2xpZGUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5kaXNwYXRjaCgnaW1hZ2VTaXplQ2hhbmdlJywge1xuICAgICAgICAgIHNsaWRlOiB0aGlzLnNsaWRlLFxuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICBjb250ZW50OiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgdGhlIGNvbnRlbnQgY2FuIGJlIHpvb21lZFxyXG4gICAqL1xuXG5cbiAgaXNab29tYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoJ2lzQ29udGVudFpvb21hYmxlJywgdGhpcy5pc0ltYWdlQ29udGVudCgpICYmIHRoaXMuc3RhdGUgIT09IExPQURfU1RBVEUuRVJST1IsIHRoaXMpO1xuICB9XG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBpbWFnZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlIGJhc2VkIG9uIHdpZHRoIGFuZCBoZWlnaHRcclxuICAgKi9cblxuXG4gIHVwZGF0ZVNyY3NldFNpemVzKCkge1xuICAgIC8vIEhhbmRsZSBzcmNzZXQgc2l6ZXMgYXR0cmlidXRlLlxuICAgIC8vXG4gICAgLy8gTmV2ZXIgbG93ZXIgcXVhbGl0eSwgaWYgaXQgd2FzIGluY3JlYXNlZCBwcmV2aW91c2x5LlxuICAgIC8vIENocm9tZSBkb2VzIHRoaXMgYXV0b21hdGljYWxseSwgRmlyZWZveCBhbmQgU2FmYXJpIGRvIG5vdCxcbiAgICAvLyBzbyB3ZSBzdG9yZSBsYXJnZXN0IHVzZWQgc2l6ZSBpbiBkYXRhc2V0LlxuICAgIGlmICghdGhpcy5pc0ltYWdlQ29udGVudCgpIHx8ICF0aGlzLmVsZW1lbnQgfHwgIXRoaXMuZGF0YS5zcmNzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpbWFnZSA9XG4gICAgLyoqIEB0eXBlIEhUTUxJbWFnZUVsZW1lbnQgKi9cbiAgICB0aGlzLmVsZW1lbnQ7XG4gICAgY29uc3Qgc2l6ZXNXaWR0aCA9IHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKCdzcmNzZXRTaXplc1dpZHRoJywgdGhpcy5kaXNwbGF5ZWRJbWFnZVdpZHRoLCB0aGlzKTtcblxuICAgIGlmICghaW1hZ2UuZGF0YXNldC5sYXJnZXN0VXNlZFNpemUgfHwgc2l6ZXNXaWR0aCA+IHBhcnNlSW50KGltYWdlLmRhdGFzZXQubGFyZ2VzdFVzZWRTaXplLCAxMCkpIHtcbiAgICAgIGltYWdlLnNpemVzID0gc2l6ZXNXaWR0aCArICdweCc7XG4gICAgICBpbWFnZS5kYXRhc2V0Lmxhcmdlc3RVc2VkU2l6ZSA9IFN0cmluZyhzaXplc1dpZHRoKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IElmIGNvbnRlbnQgc2hvdWxkIHVzZSBhIHBsYWNlaG9sZGVyIChmcm9tIG1zcmMgYnkgZGVmYXVsdClcclxuICAgKi9cblxuXG4gIHVzZVBsYWNlaG9sZGVyKCkge1xuICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmFwcGx5RmlsdGVycygndXNlQ29udGVudFBsYWNlaG9sZGVyJywgdGhpcy5pc0ltYWdlQ29udGVudCgpLCB0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBQcmVsb2FkIGNvbnRlbnQgd2l0aCBsYXp5LWxvYWRpbmcgcGFyYW1cclxuICAgKi9cblxuXG4gIGxhenlMb2FkKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50TGF6eUxvYWQnLCB7XG4gICAgICBjb250ZW50OiB0aGlzXG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubG9hZCh0cnVlKTtcbiAgfVxuICAvKipcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gSWYgcGxhY2Vob2xkZXIgc2hvdWxkIGJlIGtlcHQgYWZ0ZXIgY29udGVudCBpcyBsb2FkZWRcclxuICAgKi9cblxuXG4gIGtlZXBQbGFjZWhvbGRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0YW5jZS5hcHBseUZpbHRlcnMoJ2lzS2VlcGluZ1BsYWNlaG9sZGVyJywgdGhpcy5pc0xvYWRpbmcoKSwgdGhpcyk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVzdHJveSB0aGUgY29udGVudFxyXG4gICAqL1xuXG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmhhc1NsaWRlID0gZmFsc2U7XG4gICAgdGhpcy5zbGlkZSA9IHVuZGVmaW5lZDtcblxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50RGVzdHJveScsIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yZW1vdmUoKTtcblxuICAgIGlmICh0aGlzLnBsYWNlaG9sZGVyKSB7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucGxhY2Vob2xkZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNJbWFnZUNvbnRlbnQoKSAmJiB0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5vbmxvYWQgPSBudWxsO1xuICAgICAgdGhpcy5lbGVtZW50Lm9uZXJyb3IgPSBudWxsO1xuICAgICAgdGhpcy5lbGVtZW50ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBEaXNwbGF5IGVycm9yIG1lc3NhZ2VcclxuICAgKi9cblxuXG4gIGRpc3BsYXlFcnJvcigpIHtcbiAgICBpZiAodGhpcy5zbGlkZSkge1xuICAgICAgdmFyIF90aGlzJGluc3RhbmNlJG9wdGlvbiwgX3RoaXMkaW5zdGFuY2Ukb3B0aW9uMjtcblxuICAgICAgbGV0IGVycm9yTXNnRWwgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19lcnJvci1tc2cnLCAnZGl2Jyk7XG4gICAgICBlcnJvck1zZ0VsLmlubmVyVGV4dCA9IChfdGhpcyRpbnN0YW5jZSRvcHRpb24gPSAoX3RoaXMkaW5zdGFuY2Ukb3B0aW9uMiA9IHRoaXMuaW5zdGFuY2Uub3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkaW5zdGFuY2Ukb3B0aW9uMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkaW5zdGFuY2Ukb3B0aW9uMi5lcnJvck1zZykgIT09IG51bGwgJiYgX3RoaXMkaW5zdGFuY2Ukb3B0aW9uICE9PSB2b2lkIDAgPyBfdGhpcyRpbnN0YW5jZSRvcHRpb24gOiAnJztcbiAgICAgIGVycm9yTXNnRWwgPVxuICAgICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudH0gKi9cbiAgICAgIHRoaXMuaW5zdGFuY2UuYXBwbHlGaWx0ZXJzKCdjb250ZW50RXJyb3JFbGVtZW50JywgZXJyb3JNc2dFbCwgdGhpcyk7XG4gICAgICB0aGlzLmVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19jb250ZW50IHBzd3BfX2Vycm9yLW1zZy1jb250YWluZXInLCAnZGl2Jyk7XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoZXJyb3JNc2dFbCk7XG4gICAgICB0aGlzLnNsaWRlLmNvbnRhaW5lci5pbm5lclRleHQgPSAnJztcbiAgICAgIHRoaXMuc2xpZGUuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICB0aGlzLnNsaWRlLnVwZGF0ZUNvbnRlbnRTaXplKHRydWUpO1xuICAgICAgdGhpcy5yZW1vdmVQbGFjZWhvbGRlcigpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBBcHBlbmQgdGhlIGNvbnRlbnRcclxuICAgKi9cblxuXG4gIGFwcGVuZCgpIHtcbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkIHx8ICF0aGlzLmVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IExPQURfU1RBVEUuRVJST1IpIHtcbiAgICAgIHRoaXMuZGlzcGxheUVycm9yKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRBcHBlbmQnLCB7XG4gICAgICBjb250ZW50OiB0aGlzXG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHN1cHBvcnRzRGVjb2RlID0gKCdkZWNvZGUnIGluIHRoaXMuZWxlbWVudCk7XG5cbiAgICBpZiAodGhpcy5pc0ltYWdlQ29udGVudCgpKSB7XG4gICAgICAvLyBVc2UgZGVjb2RlKCkgb24gbmVhcmJ5IHNsaWRlc1xuICAgICAgLy9cbiAgICAgIC8vIE5lYXJieSBzbGlkZSBpbWFnZXMgYXJlIGluIERPTSBhbmQgbm90IGhpZGRlbiB2aWEgZGlzcGxheTpub25lLlxuICAgICAgLy8gSG93ZXZlciwgdGhleSBhcmUgcGxhY2VkIG9mZnNjcmVlbiAodG8gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGUpLlxuICAgICAgLy9cbiAgICAgIC8vIFNvbWUgYnJvd3NlcnMgZG8gbm90IGNvbXBvc2l0ZSB0aGUgaW1hZ2UgdW50aWwgaXQncyBhY3R1YWxseSB2aXNpYmxlLFxuICAgICAgLy8gdXNpbmcgZGVjb2RlKCkgaGVscHMuXG4gICAgICAvL1xuICAgICAgLy8gWW91IG1pZ2h0IGFzayBcIndoeSBkb250IHlvdSBqdXN0IGRlY29kZSgpIGFuZCB0aGVuIGFwcGVuZCBhbGwgaW1hZ2VzXCIsXG4gICAgICAvLyB0aGF0J3MgYmVjYXVzZSBJIHdhbnQgdG8gc2hvdyBpbWFnZSBiZWZvcmUgaXQncyBmdWxseSBsb2FkZWQsXG4gICAgICAvLyBhcyBicm93c2VyIGNhbiByZW5kZXIgcGFydHMgb2YgaW1hZ2Ugd2hpbGUgaXQgaXMgbG9hZGluZy5cbiAgICAgIC8vIFdlIGRvIG5vdCBkbyB0aGlzIGluIFNhZmFyaSBkdWUgdG8gcGFydGlhbCBsb2FkaW5nIGJ1Zy5cbiAgICAgIGlmIChzdXBwb3J0c0RlY29kZSAmJiB0aGlzLnNsaWRlICYmICghdGhpcy5zbGlkZS5pc0FjdGl2ZSB8fCBpc1NhZmFyaSgpKSkge1xuICAgICAgICB0aGlzLmlzRGVjb2RpbmcgPSB0cnVlOyAvLyBwdXJwb3NlZnVsbHkgdXNpbmcgZmluYWxseSBpbnN0ZWFkIG9mIHRoZW4sXG4gICAgICAgIC8vIGFzIGlmIHNyY3NldCBzaXplcyBjaGFuZ2VzIGR5bmFtaWNhbGx5IC0gaXQgbWF5IGNhdXNlIGRlY29kZSBlcnJvclxuXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi9cblxuICAgICAgICB0aGlzLmVsZW1lbnQuZGVjb2RlKCkuY2F0Y2goKCkgPT4ge30pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaXNEZWNvZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuYXBwZW5kSW1hZ2UoKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZEltYWdlKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnNsaWRlICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5zbGlkZS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQWN0aXZhdGUgdGhlIHNsaWRlLFxyXG4gICAqIGFjdGl2ZSBzbGlkZSBpcyBnZW5lcmFsbHkgdGhlIGN1cnJlbnQgb25lLFxyXG4gICAqIG1lYW5pbmcgdGhlIHVzZXIgY2FuIHNlZSBpdC5cclxuICAgKi9cblxuXG4gIGFjdGl2YXRlKCkge1xuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50QWN0aXZhdGUnLCB7XG4gICAgICBjb250ZW50OiB0aGlzXG4gICAgfSkuZGVmYXVsdFByZXZlbnRlZCB8fCAhdGhpcy5zbGlkZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmlzSW1hZ2VDb250ZW50KCkgJiYgdGhpcy5pc0RlY29kaW5nICYmICFpc1NhZmFyaSgpKSB7XG4gICAgICAvLyBhZGQgaW1hZ2UgdG8gc2xpZGUgd2hlbiBpdCBiZWNvbWVzIGFjdGl2ZSxcbiAgICAgIC8vIGV2ZW4gaWYgaXQncyBub3QgZmluaXNoZWQgZGVjb2RpbmdcbiAgICAgIHRoaXMuYXBwZW5kSW1hZ2UoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNFcnJvcigpKSB7XG4gICAgICB0aGlzLmxvYWQoZmFsc2UsIHRydWUpOyAvLyB0cnkgdG8gcmVsb2FkXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc2xpZGUuaG9sZGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5zbGlkZS5ob2xkZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogRGVhY3RpdmF0ZSB0aGUgY29udGVudFxyXG4gICAqL1xuXG5cbiAgZGVhY3RpdmF0ZSgpIHtcbiAgICB0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50RGVhY3RpdmF0ZScsIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnNsaWRlICYmIHRoaXMuc2xpZGUuaG9sZGVyRWxlbWVudCkge1xuICAgICAgdGhpcy5zbGlkZS5ob2xkZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgdGhlIGNvbnRlbnQgZnJvbSBET01cclxuICAgKi9cblxuXG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcblxuICAgIGlmICh0aGlzLmluc3RhbmNlLmRpc3BhdGNoKCdjb250ZW50UmVtb3ZlJywge1xuICAgICAgY29udGVudDogdGhpc1xuICAgIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50ICYmIHRoaXMuZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucGxhY2Vob2xkZXIgJiYgdGhpcy5wbGFjZWhvbGRlci5lbGVtZW50KSB7XG4gICAgICB0aGlzLnBsYWNlaG9sZGVyLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFwcGVuZCB0aGUgaW1hZ2UgY29udGVudCB0byBzbGlkZSBjb250YWluZXJcclxuICAgKi9cblxuXG4gIGFwcGVuZEltYWdlKCkge1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaW5zdGFuY2UuZGlzcGF0Y2goJ2NvbnRlbnRBcHBlbmRJbWFnZScsIHtcbiAgICAgIGNvbnRlbnQ6IHRoaXNcbiAgICB9KS5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlbnN1cmUgdGhhdCBlbGVtZW50IGV4aXN0cyBhbmQgaXMgbm90IGFscmVhZHkgYXBwZW5kZWRcblxuXG4gICAgaWYgKHRoaXMuc2xpZGUgJiYgdGhpcy5lbGVtZW50ICYmICF0aGlzLmVsZW1lbnQucGFyZW50Tm9kZSkge1xuICAgICAgdGhpcy5zbGlkZS5jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5MT0FERUQgfHwgdGhpcy5zdGF0ZSA9PT0gTE9BRF9TVEFURS5FUlJPUikge1xuICAgICAgdGhpcy5yZW1vdmVQbGFjZWhvbGRlcigpO1xuICAgIH1cbiAgfVxuXG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvbnRlbnQuanMnKS5kZWZhdWx0fSBDb250ZW50ICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlLmpzJykuZGVmYXVsdH0gU2xpZGUgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUuanMnKS5TbGlkZURhdGF9IFNsaWRlRGF0YSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi4vY29yZS9iYXNlLmpzJykuZGVmYXVsdH0gUGhvdG9Td2lwZUJhc2UgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4uL3Bob3Rvc3dpcGUuanMnKS5kZWZhdWx0fSBQaG90b1N3aXBlICovXG5cbmNvbnN0IE1JTl9TTElERVNfVE9fQ0FDSEUgPSA1O1xuLyoqXHJcbiAqIExhenktbG9hZCBhbiBpbWFnZVxyXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYm90aCBieSBMaWdodGJveCBhbmQgUGhvdG9Td2lwZSBjb3JlLFxyXG4gKiB0aHVzIGl0IGNhbiBiZSBjYWxsZWQgYmVmb3JlIGRpYWxvZyBpcyBvcGVuZWQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBEYXRhIGFib3V0IHRoZSBzbGlkZVxyXG4gKiBAcGFyYW0ge1Bob3RvU3dpcGVCYXNlfSBpbnN0YW5jZSBQaG90b1N3aXBlIG9yIFBob3RvU3dpcGVMaWdodGJveCBpbnN0YW5jZVxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICogQHJldHVybnMge0NvbnRlbnR9IEltYWdlIHRoYXQgaXMgYmVpbmcgZGVjb2RlZCBvciBmYWxzZS5cclxuICovXG5cbmZ1bmN0aW9uIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgaW5zdGFuY2UsIGluZGV4KSB7XG4gIGNvbnN0IGNvbnRlbnQgPSBpbnN0YW5jZS5jcmVhdGVDb250ZW50RnJvbURhdGEoaXRlbURhdGEsIGluZGV4KTtcbiAgLyoqIEB0eXBlIHtab29tTGV2ZWwgfCB1bmRlZmluZWR9ICovXG5cbiAgbGV0IHpvb21MZXZlbDtcbiAgY29uc3Qge1xuICAgIG9wdGlvbnNcbiAgfSA9IGluc3RhbmNlOyAvLyBXZSBuZWVkIHRvIGtub3cgZGltZW5zaW9ucyBvZiB0aGUgaW1hZ2UgdG8gcHJlbG9hZCBpdCxcbiAgLy8gYXMgaXQgbWlnaHQgdXNlIHNyY3NldCwgYW5kIHdlIG5lZWQgdG8gZGVmaW5lIHNpemVzXG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB6b29tTGV2ZWwgPSBuZXcgWm9vbUxldmVsKG9wdGlvbnMsIGl0ZW1EYXRhLCAtMSk7XG4gICAgbGV0IHZpZXdwb3J0U2l6ZTtcblxuICAgIGlmIChpbnN0YW5jZS5wc3dwKSB7XG4gICAgICB2aWV3cG9ydFNpemUgPSBpbnN0YW5jZS5wc3dwLnZpZXdwb3J0U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlld3BvcnRTaXplID0gZ2V0Vmlld3BvcnRTaXplKG9wdGlvbnMsIGluc3RhbmNlKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYW5BcmVhU2l6ZSA9IGdldFBhbkFyZWFTaXplKG9wdGlvbnMsIHZpZXdwb3J0U2l6ZSwgaXRlbURhdGEsIGluZGV4KTtcbiAgICB6b29tTGV2ZWwudXBkYXRlKGNvbnRlbnQud2lkdGgsIGNvbnRlbnQuaGVpZ2h0LCBwYW5BcmVhU2l6ZSk7XG4gIH1cblxuICBjb250ZW50LmxhenlMb2FkKCk7XG5cbiAgaWYgKHpvb21MZXZlbCkge1xuICAgIGNvbnRlbnQuc2V0RGlzcGxheWVkU2l6ZShNYXRoLmNlaWwoY29udGVudC53aWR0aCAqIHpvb21MZXZlbC5pbml0aWFsKSwgTWF0aC5jZWlsKGNvbnRlbnQuaGVpZ2h0ICogem9vbUxldmVsLmluaXRpYWwpKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufVxuLyoqXHJcbiAqIExhenktbG9hZHMgc3BlY2lmaWMgc2xpZGUuXHJcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBib3RoIGJ5IExpZ2h0Ym94IGFuZCBQaG90b1N3aXBlIGNvcmUsXHJcbiAqIHRodXMgaXQgY2FuIGJlIGNhbGxlZCBiZWZvcmUgZGlhbG9nIGlzIG9wZW5lZC5cclxuICpcclxuICogQnkgZGVmYXVsdCwgaXQgbG9hZHMgaW1hZ2UgYmFzZWQgb24gdmlld3BvcnQgc2l6ZSBhbmQgaW5pdGlhbCB6b29tIGxldmVsLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggU2xpZGUgaW5kZXhcclxuICogQHBhcmFtIHtQaG90b1N3aXBlQmFzZX0gaW5zdGFuY2UgUGhvdG9Td2lwZSBvciBQaG90b1N3aXBlTGlnaHRib3ggZXZlbnRhYmxlIGluc3RhbmNlXHJcbiAqIEByZXR1cm5zIHtDb250ZW50IHwgdW5kZWZpbmVkfVxyXG4gKi9cblxuZnVuY3Rpb24gbGF6eUxvYWRTbGlkZShpbmRleCwgaW5zdGFuY2UpIHtcbiAgY29uc3QgaXRlbURhdGEgPSBpbnN0YW5jZS5nZXRJdGVtRGF0YShpbmRleCk7XG5cbiAgaWYgKGluc3RhbmNlLmRpc3BhdGNoKCdsYXp5TG9hZFNsaWRlJywge1xuICAgIGluZGV4LFxuICAgIGl0ZW1EYXRhXG4gIH0pLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICByZXR1cm4gbGF6eUxvYWREYXRhKGl0ZW1EYXRhLCBpbnN0YW5jZSwgaW5kZXgpO1xufVxuXG5jbGFzcyBDb250ZW50TG9hZGVyIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwOyAvLyBUb3RhbCBhbW91bnQgb2YgY2FjaGVkIGltYWdlc1xuXG4gICAgdGhpcy5saW1pdCA9IE1hdGgubWF4KHBzd3Aub3B0aW9ucy5wcmVsb2FkWzBdICsgcHN3cC5vcHRpb25zLnByZWxvYWRbMV0gKyAxLCBNSU5fU0xJREVTX1RPX0NBQ0hFKTtcbiAgICAvKiogQHR5cGUge0NvbnRlbnRbXX0gKi9cblxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zID0gW107XG4gIH1cbiAgLyoqXHJcbiAgICogTGF6eSBsb2FkIG5lYXJieSBzbGlkZXMgYmFzZWQgb24gYHByZWxvYWRgIG9wdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGlmZl0gRGlmZmVyZW5jZSBiZXR3ZWVuIHNsaWRlIGluZGV4ZXMgdGhhdCB3YXMgY2hhbmdlZCByZWNlbnRseSwgb3IgMC5cclxuICAgKi9cblxuXG4gIHVwZGF0ZUxhenkoZGlmZikge1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChwc3dwLmRpc3BhdGNoKCdsYXp5TG9hZCcpLmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBwcmVsb2FkXG4gICAgfSA9IHBzd3Aub3B0aW9ucztcbiAgICBjb25zdCBpc0ZvcndhcmQgPSBkaWZmID09PSB1bmRlZmluZWQgPyB0cnVlIDogZGlmZiA+PSAwO1xuICAgIGxldCBpOyAvLyBwcmVsb2FkWzFdIC0gbnVtIGl0ZW1zIHRvIHByZWxvYWQgaW4gZm9yd2FyZCBkaXJlY3Rpb25cblxuICAgIGZvciAoaSA9IDA7IGkgPD0gcHJlbG9hZFsxXTsgaSsrKSB7XG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gaSA6IC1pKSk7XG4gICAgfSAvLyBwcmVsb2FkWzBdIC0gbnVtIGl0ZW1zIHRvIHByZWxvYWQgaW4gYmFja3dhcmQgZGlyZWN0aW9uXG5cblxuICAgIGZvciAoaSA9IDE7IGkgPD0gcHJlbG9hZFswXTsgaSsrKSB7XG4gICAgICB0aGlzLmxvYWRTbGlkZUJ5SW5kZXgocHN3cC5jdXJySW5kZXggKyAoaXNGb3J3YXJkID8gLWkgOiBpKSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbml0aWFsSW5kZXhcclxuICAgKi9cblxuXG4gIGxvYWRTbGlkZUJ5SW5kZXgoaW5pdGlhbEluZGV4KSB7XG4gICAgY29uc3QgaW5kZXggPSB0aGlzLnBzd3AuZ2V0TG9vcGVkSW5kZXgoaW5pdGlhbEluZGV4KTsgLy8gdHJ5IHRvIGdldCBjYWNoZWQgY29udGVudFxuXG4gICAgbGV0IGNvbnRlbnQgPSB0aGlzLmdldENvbnRlbnRCeUluZGV4KGluZGV4KTtcblxuICAgIGlmICghY29udGVudCkge1xuICAgICAgLy8gbm8gY2FjaGVkIGNvbnRlbnQsIHNvIHRyeSB0byBsb2FkIGZyb20gc2NyYXRjaDpcbiAgICAgIGNvbnRlbnQgPSBsYXp5TG9hZFNsaWRlKGluZGV4LCB0aGlzLnBzd3ApOyAvLyBpZiBjb250ZW50IGNhbiBiZSBsb2FkZWQsIGFkZCBpdCB0byBjYWNoZTpcblxuICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgdGhpcy5hZGRUb0NhY2hlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge1NsaWRlfSBzbGlkZVxyXG4gICAqIEByZXR1cm5zIHtDb250ZW50fVxyXG4gICAqL1xuXG5cbiAgZ2V0Q29udGVudEJ5U2xpZGUoc2xpZGUpIHtcbiAgICBsZXQgY29udGVudCA9IHRoaXMuZ2V0Q29udGVudEJ5SW5kZXgoc2xpZGUuaW5kZXgpO1xuXG4gICAgaWYgKCFjb250ZW50KSB7XG4gICAgICAvLyBjcmVhdGUgY29udGVudCBpZiBub3QgZm91bmQgaW4gY2FjaGVcbiAgICAgIGNvbnRlbnQgPSB0aGlzLnBzd3AuY3JlYXRlQ29udGVudEZyb21EYXRhKHNsaWRlLmRhdGEsIHNsaWRlLmluZGV4KTtcbiAgICAgIHRoaXMuYWRkVG9DYWNoZShjb250ZW50KTtcbiAgICB9IC8vIGFzc2lnbiBzbGlkZSB0byBjb250ZW50XG5cblxuICAgIGNvbnRlbnQuc2V0U2xpZGUoc2xpZGUpO1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7Q29udGVudH0gY29udGVudFxyXG4gICAqL1xuXG5cbiAgYWRkVG9DYWNoZShjb250ZW50KSB7XG4gICAgLy8gbW92ZSB0byB0aGUgZW5kIG9mIGFycmF5XG4gICAgdGhpcy5yZW1vdmVCeUluZGV4KGNvbnRlbnQuaW5kZXgpO1xuXG4gICAgdGhpcy5fY2FjaGVkSXRlbXMucHVzaChjb250ZW50KTtcblxuICAgIGlmICh0aGlzLl9jYWNoZWRJdGVtcy5sZW5ndGggPiB0aGlzLmxpbWl0KSB7XG4gICAgICAvLyBEZXN0cm95IHRoZSBmaXJzdCBjb250ZW50IHRoYXQncyBub3QgYXR0YWNoZWRcbiAgICAgIGNvbnN0IGluZGV4VG9SZW1vdmUgPSB0aGlzLl9jYWNoZWRJdGVtcy5maW5kSW5kZXgoaXRlbSA9PiB7XG4gICAgICAgIHJldHVybiAhaXRlbS5pc0F0dGFjaGVkICYmICFpdGVtLmhhc1NsaWRlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChpbmRleFRvUmVtb3ZlICE9PSAtMSkge1xuICAgICAgICBjb25zdCByZW1vdmVkSXRlbSA9IHRoaXMuX2NhY2hlZEl0ZW1zLnNwbGljZShpbmRleFRvUmVtb3ZlLCAxKVswXTtcblxuICAgICAgICByZW1vdmVkSXRlbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYW4gaW1hZ2UgZnJvbSBjYWNoZSwgZG9lcyBub3QgZGVzdHJveSgpIGl0LCBqdXN0IHJlbW92ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKi9cblxuXG4gIHJlbW92ZUJ5SW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBpbmRleFRvUmVtb3ZlID0gdGhpcy5fY2FjaGVkSXRlbXMuZmluZEluZGV4KGl0ZW0gPT4gaXRlbS5pbmRleCA9PT0gaW5kZXgpO1xuXG4gICAgaWYgKGluZGV4VG9SZW1vdmUgIT09IC0xKSB7XG4gICAgICB0aGlzLl9jYWNoZWRJdGVtcy5zcGxpY2UoaW5kZXhUb1JlbW92ZSwgMSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtDb250ZW50IHwgdW5kZWZpbmVkfVxyXG4gICAqL1xuXG5cbiAgZ2V0Q29udGVudEJ5SW5kZXgoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkSXRlbXMuZmluZChjb250ZW50ID0+IGNvbnRlbnQuaW5kZXggPT09IGluZGV4KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fY2FjaGVkSXRlbXMuZm9yRWFjaChjb250ZW50ID0+IGNvbnRlbnQuZGVzdHJveSgpKTtcblxuICAgIHRoaXMuX2NhY2hlZEl0ZW1zID0gW107XG4gIH1cblxufVxuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL3Bob3Rvc3dpcGUuanNcIikuZGVmYXVsdH0gUGhvdG9Td2lwZSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydChcIi4uL3NsaWRlL3NsaWRlLmpzXCIpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXG5cbi8qKlxyXG4gKiBQaG90b1N3aXBlIGJhc2UgY2xhc3MgdGhhdCBjYW4gcmV0cmlldmUgZGF0YSBhYm91dCBldmVyeSBzbGlkZS5cclxuICogU2hhcmVkIGJ5IFBob3RvU3dpcGUgQ29yZSBhbmQgUGhvdG9Td2lwZSBMaWdodGJveFxyXG4gKi9cblxuY2xhc3MgUGhvdG9Td2lwZUJhc2UgZXh0ZW5kcyBFdmVudGFibGUge1xuICAvKipcclxuICAgKiBHZXQgdG90YWwgbnVtYmVyIG9mIHNsaWRlc1xyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cbiAgZ2V0TnVtSXRlbXMoKSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnM7XG5cbiAgICBsZXQgbnVtSXRlbXMgPSAwO1xuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSAoX3RoaXMkb3B0aW9ucyA9IHRoaXMub3B0aW9ucykgPT09IG51bGwgfHwgX3RoaXMkb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkb3B0aW9ucy5kYXRhU291cmNlO1xuXG4gICAgaWYgKGRhdGFTb3VyY2UgJiYgJ2xlbmd0aCcgaW4gZGF0YVNvdXJjZSkge1xuICAgICAgLy8gbWF5IGJlIGFuIGFycmF5IG9yIGp1c3Qgb2JqZWN0IHdpdGggbGVuZ3RoIHByb3BlcnR5XG4gICAgICBudW1JdGVtcyA9IGRhdGFTb3VyY2UubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoZGF0YVNvdXJjZSAmJiAnZ2FsbGVyeScgaW4gZGF0YVNvdXJjZSkge1xuICAgICAgLy8gcXVlcnkgRE9NIGVsZW1lbnRzXG4gICAgICBpZiAoIWRhdGFTb3VyY2UuaXRlbXMpIHtcbiAgICAgICAgZGF0YVNvdXJjZS5pdGVtcyA9IHRoaXMuX2dldEdhbGxlcnlET01FbGVtZW50cyhkYXRhU291cmNlLmdhbGxlcnkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZGF0YVNvdXJjZS5pdGVtcykge1xuICAgICAgICBudW1JdGVtcyA9IGRhdGFTb3VyY2UuaXRlbXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0gLy8gbGVnYWN5IGV2ZW50LCBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcblxuXG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmRpc3BhdGNoKCdudW1JdGVtcycsIHtcbiAgICAgIGRhdGFTb3VyY2UsXG4gICAgICBudW1JdGVtc1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLmFwcGx5RmlsdGVycygnbnVtSXRlbXMnLCBldmVudC5udW1JdGVtcywgZGF0YVNvdXJjZSk7XG4gIH1cbiAgLyoqXHJcbiAgICogQHBhcmFtIHtTbGlkZURhdGF9IHNsaWRlRGF0YVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtDb250ZW50fVxyXG4gICAqL1xuXG5cbiAgY3JlYXRlQ29udGVudEZyb21EYXRhKHNsaWRlRGF0YSwgaW5kZXgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnQoc2xpZGVEYXRhLCB0aGlzLCBpbmRleCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGl0ZW0gZGF0YSBieSBpbmRleC5cclxuICAgKlxyXG4gICAqIFwiaXRlbSBkYXRhXCIgc2hvdWxkIGNvbnRhaW4gbm9ybWFsaXplZCBpbmZvcm1hdGlvbiB0aGF0IFBob3RvU3dpcGUgbmVlZHMgdG8gZ2VuZXJhdGUgYSBzbGlkZS5cclxuICAgKiBGb3IgZXhhbXBsZSwgaXQgbWF5IGNvbnRhaW4gcHJvcGVydGllcyBsaWtlXHJcbiAgICogYHNyY2AsIGBzcmNzZXRgLCBgd2AsIGBoYCwgd2hpY2ggd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgc2xpZGUgd2l0aCBpbWFnZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtTbGlkZURhdGF9XHJcbiAgICovXG5cblxuICBnZXRJdGVtRGF0YShpbmRleCkge1xuICAgIHZhciBfdGhpcyRvcHRpb25zMjtcblxuICAgIGNvbnN0IGRhdGFTb3VyY2UgPSAoX3RoaXMkb3B0aW9uczIgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF90aGlzJG9wdGlvbnMyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRvcHRpb25zMi5kYXRhU291cmNlO1xuICAgIC8qKiBAdHlwZSB7U2xpZGVEYXRhIHwgSFRNTEVsZW1lbnR9ICovXG5cbiAgICBsZXQgZGF0YVNvdXJjZUl0ZW0gPSB7fTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFTb3VyY2UpKSB7XG4gICAgICAvLyBEYXRhc291cmNlIGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzXG4gICAgICBkYXRhU291cmNlSXRlbSA9IGRhdGFTb3VyY2VbaW5kZXhdO1xuICAgIH0gZWxzZSBpZiAoZGF0YVNvdXJjZSAmJiAnZ2FsbGVyeScgaW4gZGF0YVNvdXJjZSkge1xuICAgICAgLy8gZGF0YVNvdXJjZSBoYXMgZ2FsbGVyeSBwcm9wZXJ0eSxcbiAgICAgIC8vIHRodXMgaXQgd2FzIGNyZWF0ZWQgYnkgTGlnaHRib3gsIGJhc2VkIG9uXG4gICAgICAvLyBnYWxsZXJ5IGFuZCBjaGlsZHJlbiBvcHRpb25zXG4gICAgICAvLyBxdWVyeSBET00gZWxlbWVudHNcbiAgICAgIGlmICghZGF0YVNvdXJjZS5pdGVtcykge1xuICAgICAgICBkYXRhU291cmNlLml0ZW1zID0gdGhpcy5fZ2V0R2FsbGVyeURPTUVsZW1lbnRzKGRhdGFTb3VyY2UuZ2FsbGVyeSk7XG4gICAgICB9XG5cbiAgICAgIGRhdGFTb3VyY2VJdGVtID0gZGF0YVNvdXJjZS5pdGVtc1tpbmRleF07XG4gICAgfVxuXG4gICAgbGV0IGl0ZW1EYXRhID0gZGF0YVNvdXJjZUl0ZW07XG5cbiAgICBpZiAoaXRlbURhdGEgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBpdGVtRGF0YSA9IHRoaXMuX2RvbUVsZW1lbnRUb0l0ZW1EYXRhKGl0ZW1EYXRhKTtcbiAgICB9IC8vIERpc3BhdGNoaW5nIHRoZSBpdGVtRGF0YSBldmVudCxcbiAgICAvLyBpdCdzIGEgbGVnYWN5IHZlcmlvbiBiZWZvcmUgZmlsdGVycyB3ZXJlIGludHJvZHVjZWRcblxuXG4gICAgY29uc3QgZXZlbnQgPSB0aGlzLmRpc3BhdGNoKCdpdGVtRGF0YScsIHtcbiAgICAgIGl0ZW1EYXRhOiBpdGVtRGF0YSB8fCB7fSxcbiAgICAgIGluZGV4XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuYXBwbHlGaWx0ZXJzKCdpdGVtRGF0YScsIGV2ZW50Lml0ZW1EYXRhLCBpbmRleCk7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGFycmF5IG9mIGdhbGxlcnkgRE9NIGVsZW1lbnRzLFxyXG4gICAqIGJhc2VkIG9uIGNoaWxkU2VsZWN0b3IgYW5kIGdhbGxlcnkgZWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGdhbGxlcnlFbGVtZW50XHJcbiAgICogQHJldHVybnMge0hUTUxFbGVtZW50W119XHJcbiAgICovXG5cblxuICBfZ2V0R2FsbGVyeURPTUVsZW1lbnRzKGdhbGxlcnlFbGVtZW50KSB7XG4gICAgdmFyIF90aGlzJG9wdGlvbnMzLCBfdGhpcyRvcHRpb25zNDtcblxuICAgIGlmICgoX3RoaXMkb3B0aW9uczMgPSB0aGlzLm9wdGlvbnMpICE9PSBudWxsICYmIF90aGlzJG9wdGlvbnMzICE9PSB2b2lkIDAgJiYgX3RoaXMkb3B0aW9uczMuY2hpbGRyZW4gfHwgKF90aGlzJG9wdGlvbnM0ID0gdGhpcy5vcHRpb25zKSAhPT0gbnVsbCAmJiBfdGhpcyRvcHRpb25zNCAhPT0gdm9pZCAwICYmIF90aGlzJG9wdGlvbnM0LmNoaWxkU2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiBnZXRFbGVtZW50c0Zyb21PcHRpb24odGhpcy5vcHRpb25zLmNoaWxkcmVuLCB0aGlzLm9wdGlvbnMuY2hpbGRTZWxlY3RvciwgZ2FsbGVyeUVsZW1lbnQpIHx8IFtdO1xuICAgIH1cblxuICAgIHJldHVybiBbZ2FsbGVyeUVsZW1lbnRdO1xuICB9XG4gIC8qKlxyXG4gICAqIENvbnZlcnRzIERPTSBlbGVtZW50IHRvIGl0ZW0gZGF0YSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IERPTSBlbGVtZW50XHJcbiAgICogQHJldHVybnMge1NsaWRlRGF0YX1cclxuICAgKi9cblxuXG4gIF9kb21FbGVtZW50VG9JdGVtRGF0YShlbGVtZW50KSB7XG4gICAgLyoqIEB0eXBlIHtTbGlkZURhdGF9ICovXG4gICAgY29uc3QgaXRlbURhdGEgPSB7XG4gICAgICBlbGVtZW50XG4gICAgfTtcbiAgICBjb25zdCBsaW5rRWwgPVxuICAgIC8qKiBAdHlwZSB7SFRNTEFuY2hvckVsZW1lbnR9ICovXG4gICAgZWxlbWVudC50YWdOYW1lID09PSAnQScgPyBlbGVtZW50IDogZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdhJyk7XG5cbiAgICBpZiAobGlua0VsKSB7XG4gICAgICAvLyBzcmMgY29tZXMgZnJvbSBkYXRhLXBzd3Atc3JjIGF0dHJpYnV0ZSxcbiAgICAgIC8vIGlmIGl0J3MgZW1wdHkgbGluayBocmVmIGlzIHVzZWRcbiAgICAgIGl0ZW1EYXRhLnNyYyA9IGxpbmtFbC5kYXRhc2V0LnBzd3BTcmMgfHwgbGlua0VsLmhyZWY7XG5cbiAgICAgIGlmIChsaW5rRWwuZGF0YXNldC5wc3dwU3Jjc2V0KSB7XG4gICAgICAgIGl0ZW1EYXRhLnNyY3NldCA9IGxpbmtFbC5kYXRhc2V0LnBzd3BTcmNzZXQ7XG4gICAgICB9XG5cbiAgICAgIGl0ZW1EYXRhLndpZHRoID0gbGlua0VsLmRhdGFzZXQucHN3cFdpZHRoID8gcGFyc2VJbnQobGlua0VsLmRhdGFzZXQucHN3cFdpZHRoLCAxMCkgOiAwO1xuICAgICAgaXRlbURhdGEuaGVpZ2h0ID0gbGlua0VsLmRhdGFzZXQucHN3cEhlaWdodCA/IHBhcnNlSW50KGxpbmtFbC5kYXRhc2V0LnBzd3BIZWlnaHQsIDEwKSA6IDA7IC8vIHN1cHBvcnQgbGVnYWN5IHcgJiBoIHByb3BlcnRpZXNcblxuICAgICAgaXRlbURhdGEudyA9IGl0ZW1EYXRhLndpZHRoO1xuICAgICAgaXRlbURhdGEuaCA9IGl0ZW1EYXRhLmhlaWdodDtcblxuICAgICAgaWYgKGxpbmtFbC5kYXRhc2V0LnBzd3BUeXBlKSB7XG4gICAgICAgIGl0ZW1EYXRhLnR5cGUgPSBsaW5rRWwuZGF0YXNldC5wc3dwVHlwZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgdGh1bWJuYWlsRWwgPSBlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2ltZycpO1xuXG4gICAgICBpZiAodGh1bWJuYWlsRWwpIHtcbiAgICAgICAgdmFyIF90aHVtYm5haWxFbCRnZXRBdHRyaTtcblxuICAgICAgICAvLyBtc3JjIGlzIFVSTCB0byBwbGFjZWhvbGRlciBpbWFnZSB0aGF0J3MgZGlzcGxheWVkIGJlZm9yZSBsYXJnZSBpbWFnZSBpcyBsb2FkZWRcbiAgICAgICAgLy8gYnkgZGVmYXVsdCBpdCdzIGRpc3BsYXllZCBvbmx5IGZvciB0aGUgZmlyc3Qgc2xpZGVcbiAgICAgICAgaXRlbURhdGEubXNyYyA9IHRodW1ibmFpbEVsLmN1cnJlbnRTcmMgfHwgdGh1bWJuYWlsRWwuc3JjO1xuICAgICAgICBpdGVtRGF0YS5hbHQgPSAoX3RodW1ibmFpbEVsJGdldEF0dHJpID0gdGh1bWJuYWlsRWwuZ2V0QXR0cmlidXRlKCdhbHQnKSkgIT09IG51bGwgJiYgX3RodW1ibmFpbEVsJGdldEF0dHJpICE9PSB2b2lkIDAgPyBfdGh1bWJuYWlsRWwkZ2V0QXR0cmkgOiAnJztcbiAgICAgIH1cblxuICAgICAgaWYgKGxpbmtFbC5kYXRhc2V0LnBzd3BDcm9wcGVkIHx8IGxpbmtFbC5kYXRhc2V0LmNyb3BwZWQpIHtcbiAgICAgICAgaXRlbURhdGEudGh1bWJDcm9wcGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5hcHBseUZpbHRlcnMoJ2RvbUl0ZW1EYXRhJywgaXRlbURhdGEsIGVsZW1lbnQsIGxpbmtFbCk7XG4gIH1cbiAgLyoqXHJcbiAgICogTGF6eS1sb2FkIGJ5IHNsaWRlIGRhdGFcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7U2xpZGVEYXRhfSBpdGVtRGF0YSBEYXRhIGFib3V0IHRoZSBzbGlkZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxyXG4gICAqIEByZXR1cm5zIHtDb250ZW50fSBJbWFnZSB0aGF0IGlzIGJlaW5nIGRlY29kZWQgb3IgZmFsc2UuXHJcbiAgICovXG5cblxuICBsYXp5TG9hZERhdGEoaXRlbURhdGEsIGluZGV4KSB7XG4gICAgcmV0dXJuIGxhenlMb2FkRGF0YShpdGVtRGF0YSwgdGhpcywgaW5kZXgpO1xuICB9XG5cbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vcGhvdG9zd2lwZS5qcycpLmRlZmF1bHR9IFBob3RvU3dpcGUgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vc2xpZGUvZ2V0LXRodW1iLWJvdW5kcy5qcycpLkJvdW5kc30gQm91bmRzICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3V0aWwvYW5pbWF0aW9ucy5qcycpLkFuaW1hdGlvblByb3BzfSBBbmltYXRpb25Qcm9wcyAqL1xuLy8gc29tZSBicm93c2VycyBkbyBub3QgcGFpbnRcbi8vIGVsZW1lbnRzIHdoaWNoIG9wYWNpdHkgaXMgc2V0IHRvIDAsXG4vLyBzaW5jZSB3ZSBuZWVkIHRvIHByZS1yZW5kZXIgZWxlbWVudHMgZm9yIHRoZSBhbmltYXRpb24gLVxuLy8gd2Ugc2V0IGl0IHRvIHRoZSBtaW5pbXVtIGFtb3VudFxuXG5jb25zdCBNSU5fT1BBQ0lUWSA9IDAuMDAzO1xuLyoqXHJcbiAqIE1hbmFnZXMgb3BlbmluZyBhbmQgY2xvc2luZyB0cmFuc2l0aW9ucyBvZiB0aGUgUGhvdG9Td2lwZS5cclxuICpcclxuICogSXQgY2FuIHBlcmZvcm0gem9vbSwgZmFkZSBvciBubyB0cmFuc2l0aW9uLlxyXG4gKi9cblxuY2xhc3MgT3BlbmVyIHtcbiAgLyoqXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlfSBwc3dwXHJcbiAgICovXG4gIGNvbnN0cnVjdG9yKHBzd3ApIHtcbiAgICB0aGlzLnBzd3AgPSBwc3dwO1xuICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzT3BlbmluZyA9IGZhbHNlO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHtudW1iZXIgfCBmYWxzZSB8IHVuZGVmaW5lZH1cclxuICAgICAqL1xuXG4gICAgdGhpcy5fZHVyYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl91c2VBbmltYXRpb24gPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX2Nyb3BwZWRab29tID0gZmFsc2U7XG4gICAgLyoqIEBwcml2YXRlICovXG5cbiAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSBmYWxzZTtcbiAgICAvKiogQHByaXZhdGUgKi9cblxuICAgIHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7IEhUTUxEaXZFbGVtZW50IHwgSFRNTEltYWdlRWxlbWVudCB8IG51bGwgfCB1bmRlZmluZWQgfVxyXG4gICAgICovXG5cbiAgICB0aGlzLl9wbGFjZWhvbGRlciA9IHVuZGVmaW5lZDtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7IEhUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkIH1cclxuICAgICAqL1xuXG4gICAgdGhpcy5fb3BhY2l0eUVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUgeyBIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZCB9XHJcbiAgICAgKi9cblxuICAgIHRoaXMuX2Nyb3BDb250YWluZXIxID0gdW5kZWZpbmVkO1xuICAgIC8qKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEB0eXBlIHsgSFRNTEVsZW1lbnQgfCBudWxsIHwgdW5kZWZpbmVkIH1cclxuICAgICAqL1xuXG4gICAgdGhpcy5fY3JvcENvbnRhaW5lcjIgPSB1bmRlZmluZWQ7XG4gICAgLyoqXHJcbiAgICAgKiBAcHJpdmF0ZVxyXG4gICAgICogQHR5cGUge0JvdW5kcyB8IHVuZGVmaW5lZH1cclxuICAgICAqL1xuXG4gICAgdGhpcy5fdGh1bWJCb3VuZHMgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fcHJlcGFyZU9wZW4gPSB0aGlzLl9wcmVwYXJlT3Blbi5iaW5kKHRoaXMpOyAvLyBPdmVycmlkZSBpbml0aWFsIHpvb20gYW5kIHBhbiBwb3NpdGlvblxuXG4gICAgcHN3cC5vbignZmlyc3Rab29tUGFuJywgdGhpcy5fcHJlcGFyZU9wZW4pO1xuICB9XG5cbiAgb3BlbigpIHtcbiAgICB0aGlzLl9wcmVwYXJlT3BlbigpO1xuXG4gICAgdGhpcy5fc3RhcnQoKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkIHx8IHRoaXMuaXNDbG9zaW5nIHx8IHRoaXMuaXNPcGVuaW5nKSB7XG4gICAgICAvLyBpZiB3ZSBjbG9zZSBkdXJpbmcgb3BlbmluZyBhbmltYXRpb25cbiAgICAgIC8vIGZvciBub3cgZG8gbm90aGluZyxcbiAgICAgIC8vIGJyb3dzZXJzIGFyZW4ndCBnb29kIGF0IGNoYW5naW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIENTUyB0cmFuc2l0aW9uXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLnBzd3AuY3VyclNsaWRlO1xuICAgIHRoaXMuaXNPcGVuID0gZmFsc2U7XG4gICAgdGhpcy5pc09wZW5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmlzQ2xvc2luZyA9IHRydWU7XG4gICAgdGhpcy5fZHVyYXRpb24gPSB0aGlzLnBzd3Aub3B0aW9ucy5oaWRlQW5pbWF0aW9uRHVyYXRpb247XG5cbiAgICBpZiAoc2xpZGUgJiYgc2xpZGUuY3Vyclpvb21MZXZlbCAqIHNsaWRlLndpZHRoID49IHRoaXMucHN3cC5vcHRpb25zLm1heFdpZHRoVG9BbmltYXRlKSB7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgfVxuXG4gICAgdGhpcy5fYXBwbHlTdGFydFByb3BzKCk7XG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgfSwgdGhpcy5fY3JvcHBlZFpvb20gPyAzMCA6IDApO1xuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgX3ByZXBhcmVPcGVuKCkge1xuICAgIHRoaXMucHN3cC5vZmYoJ2ZpcnN0Wm9vbVBhbicsIHRoaXMuX3ByZXBhcmVPcGVuKTtcblxuICAgIGlmICghdGhpcy5pc09wZW5pbmcpIHtcbiAgICAgIGNvbnN0IHNsaWRlID0gdGhpcy5wc3dwLmN1cnJTbGlkZTtcbiAgICAgIHRoaXMuaXNPcGVuaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuaXNDbG9zaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IHRoaXMucHN3cC5vcHRpb25zLnNob3dBbmltYXRpb25EdXJhdGlvbjtcblxuICAgICAgaWYgKHNsaWRlICYmIHNsaWRlLnpvb21MZXZlbHMuaW5pdGlhbCAqIHNsaWRlLndpZHRoID49IHRoaXMucHN3cC5vcHRpb25zLm1heFdpZHRoVG9BbmltYXRlKSB7XG4gICAgICAgIHRoaXMuX2R1cmF0aW9uID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fYXBwbHlTdGFydFByb3BzKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgX2FwcGx5U3RhcnRQcm9wcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2xpZGUgPSB0aGlzLnBzd3AuY3VyclNsaWRlO1xuICAgIGNvbnN0IHtcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gcHN3cDtcblxuICAgIGlmIChvcHRpb25zLnNob3dIaWRlQW5pbWF0aW9uVHlwZSA9PT0gJ2ZhZGUnKSB7XG4gICAgICBvcHRpb25zLnNob3dIaWRlT3BhY2l0eSA9IHRydWU7XG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMuc2hvd0hpZGVBbmltYXRpb25UeXBlID09PSAnbm9uZScpIHtcbiAgICAgIG9wdGlvbnMuc2hvd0hpZGVPcGFjaXR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9kdXJhdGlvbiA9IDA7XG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNPcGVuaW5nICYmIHBzd3AuX2luaXRpYWxUaHVtYkJvdW5kcykge1xuICAgICAgLy8gVXNlIGluaXRpYWwgYm91bmRzIGlmIGRlZmluZWRcbiAgICAgIHRoaXMuX3RodW1iQm91bmRzID0gcHN3cC5faW5pdGlhbFRodW1iQm91bmRzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl90aHVtYkJvdW5kcyA9IHRoaXMucHN3cC5nZXRUaHVtYkJvdW5kcygpO1xuICAgIH1cblxuICAgIHRoaXMuX3BsYWNlaG9sZGVyID0gc2xpZGUgPT09IG51bGwgfHwgc2xpZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNsaWRlLmdldFBsYWNlaG9sZGVyRWxlbWVudCgpO1xuICAgIHBzd3AuYW5pbWF0aW9ucy5zdG9wQWxsKCk7IC8vIERpc2NhcmQgYW5pbWF0aW9ucyB3aGVuIGR1cmF0aW9uIGlzIGxlc3MgdGhhbiA1MG1zXG5cbiAgICB0aGlzLl91c2VBbmltYXRpb24gPSBCb29sZWFuKHRoaXMuX2R1cmF0aW9uICYmIHRoaXMuX2R1cmF0aW9uID4gNTApO1xuICAgIHRoaXMuX2FuaW1hdGVab29tID0gQm9vbGVhbih0aGlzLl90aHVtYkJvdW5kcykgJiYgKHNsaWRlID09PSBudWxsIHx8IHNsaWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzbGlkZS5jb250ZW50LnVzZVBsYWNlaG9sZGVyKCkpICYmICghdGhpcy5pc0Nsb3NpbmcgfHwgIXBzd3AubWFpblNjcm9sbC5pc1NoaWZ0ZWQoKSk7XG5cbiAgICBpZiAoIXRoaXMuX2FuaW1hdGVab29tKSB7XG4gICAgICB0aGlzLl9hbmltYXRlUm9vdE9wYWNpdHkgPSB0cnVlO1xuXG4gICAgICBpZiAodGhpcy5pc09wZW5pbmcgJiYgc2xpZGUpIHtcbiAgICAgICAgc2xpZGUuem9vbUFuZFBhblRvSW5pdGlhbCgpO1xuICAgICAgICBzbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfb3B0aW9ucyRzaG93SGlkZU9wYWM7XG5cbiAgICAgIHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSA9IChfb3B0aW9ucyRzaG93SGlkZU9wYWMgPSBvcHRpb25zLnNob3dIaWRlT3BhY2l0eSkgIT09IG51bGwgJiYgX29wdGlvbnMkc2hvd0hpZGVPcGFjICE9PSB2b2lkIDAgPyBfb3B0aW9ucyRzaG93SGlkZU9wYWMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9hbmltYXRlQmdPcGFjaXR5ID0gIXRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSAmJiB0aGlzLnBzd3Aub3B0aW9ucy5iZ09wYWNpdHkgPiBNSU5fT1BBQ0lUWTtcbiAgICB0aGlzLl9vcGFjaXR5RWxlbWVudCA9IHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSA/IHBzd3AuZWxlbWVudCA6IHBzd3AuYmc7XG5cbiAgICBpZiAoIXRoaXMuX3VzZUFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fZHVyYXRpb24gPSAwO1xuICAgICAgdGhpcy5fYW5pbWF0ZVpvb20gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSA9IHRydWU7XG5cbiAgICAgIGlmICh0aGlzLmlzT3BlbmluZykge1xuICAgICAgICBpZiAocHN3cC5lbGVtZW50KSB7XG4gICAgICAgICAgcHN3cC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcoTUlOX09QQUNJVFkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHN3cC5hcHBseUJnT3BhY2l0eSgxKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9hbmltYXRlWm9vbSAmJiB0aGlzLl90aHVtYkJvdW5kcyAmJiB0aGlzLl90aHVtYkJvdW5kcy5pbm5lclJlY3QpIHtcbiAgICAgIHZhciBfdGhpcyRwc3dwJGN1cnJTbGlkZTtcblxuICAgICAgLy8gUHJvcGVydGllcyBhcmUgdXNlZCB3aGVuIGFuaW1hdGlvbiBmcm9tIGNyb3BwZWQgdGh1bWJuYWlsXG4gICAgICB0aGlzLl9jcm9wcGVkWm9vbSA9IHRydWU7XG4gICAgICB0aGlzLl9jcm9wQ29udGFpbmVyMSA9IHRoaXMucHN3cC5jb250YWluZXI7XG4gICAgICB0aGlzLl9jcm9wQ29udGFpbmVyMiA9IChfdGhpcyRwc3dwJGN1cnJTbGlkZSA9IHRoaXMucHN3cC5jdXJyU2xpZGUpID09PSBudWxsIHx8IF90aGlzJHBzd3AkY3VyclNsaWRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwc3dwJGN1cnJTbGlkZS5ob2xkZXJFbGVtZW50O1xuXG4gICAgICBpZiAocHN3cC5jb250YWluZXIpIHtcbiAgICAgICAgcHN3cC5jb250YWluZXIuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICAgICAgcHN3cC5jb250YWluZXIuc3R5bGUud2lkdGggPSBwc3dwLnZpZXdwb3J0U2l6ZS54ICsgJ3B4JztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY3JvcHBlZFpvb20gPSBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc09wZW5pbmcpIHtcbiAgICAgIC8vIEFwcGx5IHN0eWxlcyBiZWZvcmUgb3BlbmluZyB0cmFuc2l0aW9uXG4gICAgICBpZiAodGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5KSB7XG4gICAgICAgIGlmIChwc3dwLmVsZW1lbnQpIHtcbiAgICAgICAgICBwc3dwLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XG4gICAgICAgIH1cblxuICAgICAgICBwc3dwLmFwcGx5QmdPcGFjaXR5KDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgJiYgcHN3cC5iZykge1xuICAgICAgICAgIHBzd3AuYmcuc3R5bGUub3BhY2l0eSA9IFN0cmluZyhNSU5fT1BBQ0lUWSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocHN3cC5lbGVtZW50KSB7XG4gICAgICAgICAgcHN3cC5lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2FuaW1hdGVab29tKSB7XG4gICAgICAgIHRoaXMuX3NldENsb3NlZFN0YXRlWm9vbVBhbigpO1xuXG4gICAgICAgIGlmICh0aGlzLl9wbGFjZWhvbGRlcikge1xuICAgICAgICAgIC8vIHRlbGwgYnJvd3NlciB0aGF0IHdlIHBsYW4gdG8gYW5pbWF0ZSB0aGUgcGxhY2Vob2xkZXJcbiAgICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7IC8vIGhpZGUgcGxhY2Vob2xkZXIgdG8gYWxsb3cgaGlkaW5nIG9mXG4gICAgICAgICAgLy8gZWxlbWVudHMgdGhhdCBvdmVybGFwIGl0IChzdWNoIGFzIGljb25zIG92ZXIgdGhlIHRodW1ibmFpbClcblxuICAgICAgICAgIHRoaXMuX3BsYWNlaG9sZGVyLnN0eWxlLm9wYWNpdHkgPSBTdHJpbmcoTUlOX09QQUNJVFkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzQ2xvc2luZykge1xuICAgICAgLy8gaGlkZSBuZWFyYnkgc2xpZGVzIHRvIG1ha2Ugc3VyZSB0aGF0XG4gICAgICAvLyB0aGV5IGFyZSBub3QgcGFpbnRlZCBkdXJpbmcgdGhlIHRyYW5zaXRpb25cbiAgICAgIGlmIChwc3dwLm1haW5TY3JvbGwuaXRlbUhvbGRlcnNbMF0pIHtcbiAgICAgICAgcHN3cC5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGlmIChwc3dwLm1haW5TY3JvbGwuaXRlbUhvbGRlcnNbMl0pIHtcbiAgICAgICAgcHN3cC5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzWzJdLmVsLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9jcm9wcGVkWm9vbSkge1xuICAgICAgICBpZiAocHN3cC5tYWluU2Nyb2xsLnggIT09IDApIHtcbiAgICAgICAgICAvLyBzaGlmdCB0aGUgbWFpbiBzY3JvbGxlciB0byB6ZXJvIHBvc2l0aW9uXG4gICAgICAgICAgcHN3cC5tYWluU2Nyb2xsLnJlc2V0UG9zaXRpb24oKTtcbiAgICAgICAgICBwc3dwLm1haW5TY3JvbGwucmVzaXplKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBwcml2YXRlICovXG5cblxuICBfc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuaW5nICYmIHRoaXMuX3VzZUFuaW1hdGlvbiAmJiB0aGlzLl9wbGFjZWhvbGRlciAmJiB0aGlzLl9wbGFjZWhvbGRlci50YWdOYW1lID09PSAnSU1HJykge1xuICAgICAgLy8gVG8gZW5zdXJlIHNtb290aCBhbmltYXRpb25cbiAgICAgIC8vIHdlIHdhaXQgdGlsbCB0aGUgY3VycmVudCBzbGlkZSBpbWFnZSBwbGFjZWhvbGRlciBpcyBkZWNvZGVkLFxuICAgICAgLy8gYnV0IG5vIGxvbmdlciB0aGFuIDI1MG1zLFxuICAgICAgLy8gYW5kIG5vIHNob3J0ZXIgdGhhbiA1MG1zXG4gICAgICAvLyAoanVzdCB1c2luZyByZXF1ZXN0YW5pbWF0aW9uZnJhbWUgaXMgbm90IGVub3VnaCBpbiBGaXJlZm94LFxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uKVxuICAgICAgbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgIGxldCBkZWNvZGVkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc0RlbGF5aW5nID0gdHJ1ZTtcbiAgICAgICAgZGVjb2RlSW1hZ2UoXG4gICAgICAgIC8qKiBAdHlwZSB7SFRNTEltYWdlRWxlbWVudH0gKi9cbiAgICAgICAgdGhpcy5fcGxhY2Vob2xkZXIpLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIGRlY29kZWQgPSB0cnVlO1xuXG4gICAgICAgICAgaWYgKCFpc0RlbGF5aW5nKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIGlzRGVsYXlpbmcgPSBmYWxzZTtcblxuICAgICAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTApO1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIDI1MCk7XG4gICAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuX2luaXRpYXRlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pbml0aWF0ZSgpO1xuICAgIH1cbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIF9pbml0aWF0ZSgpIHtcbiAgICB2YXIgX3RoaXMkcHN3cCRlbGVtZW50LCBfdGhpcyRwc3dwJGVsZW1lbnQyO1xuXG4gICAgKF90aGlzJHBzd3AkZWxlbWVudCA9IHRoaXMucHN3cC5lbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwc3dwJGVsZW1lbnQgPT09IHZvaWQgMCB8fCBfdGhpcyRwc3dwJGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tcHN3cC10cmFuc2l0aW9uLWR1cmF0aW9uJywgdGhpcy5fZHVyYXRpb24gKyAnbXMnKTtcbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2godGhpcy5pc09wZW5pbmcgPyAnb3BlbmluZ0FuaW1hdGlvblN0YXJ0JyA6ICdjbG9zaW5nQW5pbWF0aW9uU3RhcnQnKTsgLy8gbGVnYWN5IGV2ZW50XG5cbiAgICB0aGlzLnBzd3AuZGlzcGF0Y2goXG4gICAgLyoqIEB0eXBlIHsnaW5pdGlhbFpvb21JbicgfCAnaW5pdGlhbFpvb21PdXQnfSAqL1xuICAgICdpbml0aWFsWm9vbScgKyAodGhpcy5pc09wZW5pbmcgPyAnSW4nIDogJ091dCcpKTtcbiAgICAoX3RoaXMkcHN3cCRlbGVtZW50MiA9IHRoaXMucHN3cC5lbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRwc3dwJGVsZW1lbnQyID09PSB2b2lkIDAgfHwgX3RoaXMkcHN3cCRlbGVtZW50Mi5jbGFzc0xpc3QudG9nZ2xlKCdwc3dwLS11aS12aXNpYmxlJywgdGhpcy5pc09wZW5pbmcpO1xuXG4gICAgaWYgKHRoaXMuaXNPcGVuaW5nKSB7XG4gICAgICBpZiAodGhpcy5fcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgLy8gdW5oaWRlIHRoZSBwbGFjZWhvbGRlclxuICAgICAgICB0aGlzLl9wbGFjZWhvbGRlci5zdHlsZS5vcGFjaXR5ID0gJzEnO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hbmltYXRlVG9PcGVuU3RhdGUoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNDbG9zaW5nKSB7XG4gICAgICB0aGlzLl9hbmltYXRlVG9DbG9zZWRTdGF0ZSgpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fdXNlQW5pbWF0aW9uKSB7XG4gICAgICB0aGlzLl9vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgfVxuICB9XG4gIC8qKiBAcHJpdmF0ZSAqL1xuXG5cbiAgX29uQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzO1xuICAgIHRoaXMuaXNPcGVuID0gdGhpcy5pc09wZW5pbmc7XG4gICAgdGhpcy5pc0Nsb3NlZCA9IHRoaXMuaXNDbG9zaW5nO1xuICAgIHRoaXMuaXNPcGVuaW5nID0gZmFsc2U7XG4gICAgdGhpcy5pc0Nsb3NpbmcgPSBmYWxzZTtcbiAgICBwc3dwLmRpc3BhdGNoKHRoaXMuaXNPcGVuID8gJ29wZW5pbmdBbmltYXRpb25FbmQnIDogJ2Nsb3NpbmdBbmltYXRpb25FbmQnKTsgLy8gbGVnYWN5IGV2ZW50XG5cbiAgICBwc3dwLmRpc3BhdGNoKFxuICAgIC8qKiBAdHlwZSB7J2luaXRpYWxab29tSW5FbmQnIHwgJ2luaXRpYWxab29tT3V0RW5kJ30gKi9cbiAgICAnaW5pdGlhbFpvb20nICsgKHRoaXMuaXNPcGVuID8gJ0luRW5kJyA6ICdPdXRFbmQnKSk7XG5cbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgcHN3cC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgdmFyIF9wc3dwJGN1cnJTbGlkZTtcblxuICAgICAgaWYgKHRoaXMuX2FuaW1hdGVab29tICYmIHBzd3AuY29udGFpbmVyKSB7XG4gICAgICAgIHBzd3AuY29udGFpbmVyLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgICAgICBwc3dwLmNvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgIH1cblxuICAgICAgKF9wc3dwJGN1cnJTbGlkZSA9IHBzd3AuY3VyclNsaWRlKSA9PT0gbnVsbCB8fCBfcHN3cCRjdXJyU2xpZGUgPT09IHZvaWQgMCB8fCBfcHN3cCRjdXJyU2xpZGUuYXBwbHlDdXJyZW50Wm9vbVBhbigpO1xuICAgIH1cbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIF9hbmltYXRlVG9PcGVuU3RhdGUoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHN3cFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVab29tKSB7XG4gICAgICBpZiAodGhpcy5fY3JvcHBlZFpvb20gJiYgdGhpcy5fY3JvcENvbnRhaW5lcjEgJiYgdGhpcy5fY3JvcENvbnRhaW5lcjIpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKHRoaXMuX2Nyb3BDb250YWluZXIxLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZTNkKDAsMCwwKScpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyh0aGlzLl9jcm9wQ29udGFpbmVyMiwgJ3RyYW5zZm9ybScsICdub25lJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwc3dwLmN1cnJTbGlkZSkge1xuICAgICAgICBwc3dwLmN1cnJTbGlkZS56b29tQW5kUGFuVG9Jbml0aWFsKCk7XG5cbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuY3VyclNsaWRlLmNvbnRhaW5lciwgJ3RyYW5zZm9ybScsIHBzd3AuY3VyclNsaWRlLmdldEN1cnJlbnRUcmFuc2Zvcm0oKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgJiYgcHN3cC5iZykge1xuICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuYmcsICdvcGFjaXR5JywgU3RyaW5nKHBzd3Aub3B0aW9ucy5iZ09wYWNpdHkpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fYW5pbWF0ZVJvb3RPcGFjaXR5ICYmIHBzd3AuZWxlbWVudCkge1xuICAgICAgdGhpcy5fYW5pbWF0ZVRvKHBzd3AuZWxlbWVudCwgJ29wYWNpdHknLCAnMScpO1xuICAgIH1cbiAgfVxuICAvKiogQHByaXZhdGUgKi9cblxuXG4gIF9hbmltYXRlVG9DbG9zZWRTdGF0ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwc3dwXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5fYW5pbWF0ZVpvb20pIHtcbiAgICAgIHRoaXMuX3NldENsb3NlZFN0YXRlWm9vbVBhbih0cnVlKTtcbiAgICB9IC8vIGRvIG5vdCBhbmltYXRlIG9wYWNpdHkgaWYgaXQncyBhbHJlYWR5IGF0IDBcblxuXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVCZ09wYWNpdHkgJiYgcHN3cC5iZ09wYWNpdHkgPiAwLjAxICYmIHBzd3AuYmcpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGVUbyhwc3dwLmJnLCAnb3BhY2l0eScsICcwJyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FuaW1hdGVSb290T3BhY2l0eSAmJiBwc3dwLmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGVUbyhwc3dwLmVsZW1lbnQsICdvcGFjaXR5JywgJzAnKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogQHByaXZhdGVcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFthbmltYXRlXVxyXG4gICAqL1xuXG5cbiAgX3NldENsb3NlZFN0YXRlWm9vbVBhbihhbmltYXRlKSB7XG4gICAgaWYgKCF0aGlzLl90aHVtYkJvdW5kcykgcmV0dXJuO1xuICAgIGNvbnN0IHtcbiAgICAgIHBzd3BcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBpbm5lclJlY3RcbiAgICB9ID0gdGhpcy5fdGh1bWJCb3VuZHM7XG4gICAgY29uc3Qge1xuICAgICAgY3VyclNsaWRlLFxuICAgICAgdmlld3BvcnRTaXplXG4gICAgfSA9IHBzd3A7XG5cbiAgICBpZiAodGhpcy5fY3JvcHBlZFpvb20gJiYgaW5uZXJSZWN0ICYmIHRoaXMuX2Nyb3BDb250YWluZXIxICYmIHRoaXMuX2Nyb3BDb250YWluZXIyKSB7XG4gICAgICBjb25zdCBjb250YWluZXJPbmVQYW5YID0gLXZpZXdwb3J0U2l6ZS54ICsgKHRoaXMuX3RodW1iQm91bmRzLnggLSBpbm5lclJlY3QueCkgKyBpbm5lclJlY3QudztcbiAgICAgIGNvbnN0IGNvbnRhaW5lck9uZVBhblkgPSAtdmlld3BvcnRTaXplLnkgKyAodGhpcy5fdGh1bWJCb3VuZHMueSAtIGlubmVyUmVjdC55KSArIGlubmVyUmVjdC5oO1xuICAgICAgY29uc3QgY29udGFpbmVyVHdvUGFuWCA9IHZpZXdwb3J0U2l6ZS54IC0gaW5uZXJSZWN0Lnc7XG4gICAgICBjb25zdCBjb250YWluZXJUd29QYW5ZID0gdmlld3BvcnRTaXplLnkgLSBpbm5lclJlY3QuaDtcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKHRoaXMuX2Nyb3BDb250YWluZXIxLCAndHJhbnNmb3JtJywgdG9UcmFuc2Zvcm1TdHJpbmcoY29udGFpbmVyT25lUGFuWCwgY29udGFpbmVyT25lUGFuWSkpO1xuXG4gICAgICAgIHRoaXMuX2FuaW1hdGVUbyh0aGlzLl9jcm9wQ29udGFpbmVyMiwgJ3RyYW5zZm9ybScsIHRvVHJhbnNmb3JtU3RyaW5nKGNvbnRhaW5lclR3b1BhblgsIGNvbnRhaW5lclR3b1BhblkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFRyYW5zZm9ybSh0aGlzLl9jcm9wQ29udGFpbmVyMSwgY29udGFpbmVyT25lUGFuWCwgY29udGFpbmVyT25lUGFuWSk7XG4gICAgICAgIHNldFRyYW5zZm9ybSh0aGlzLl9jcm9wQ29udGFpbmVyMiwgY29udGFpbmVyVHdvUGFuWCwgY29udGFpbmVyVHdvUGFuWSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGN1cnJTbGlkZSkge1xuICAgICAgZXF1YWxpemVQb2ludHMoY3VyclNsaWRlLnBhbiwgaW5uZXJSZWN0IHx8IHRoaXMuX3RodW1iQm91bmRzKTtcbiAgICAgIGN1cnJTbGlkZS5jdXJyWm9vbUxldmVsID0gdGhpcy5fdGh1bWJCb3VuZHMudyAvIGN1cnJTbGlkZS53aWR0aDtcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fYW5pbWF0ZVRvKGN1cnJTbGlkZS5jb250YWluZXIsICd0cmFuc2Zvcm0nLCBjdXJyU2xpZGUuZ2V0Q3VycmVudFRyYW5zZm9ybSgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJTbGlkZS5hcHBseUN1cnJlbnRab29tUGFuKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XHJcbiAgICogQHBhcmFtIHsndHJhbnNmb3JtJyB8ICdvcGFjaXR5J30gcHJvcFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wVmFsdWVcclxuICAgKi9cblxuXG4gIF9hbmltYXRlVG8odGFyZ2V0LCBwcm9wLCBwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXRoaXMuX2R1cmF0aW9uKSB7XG4gICAgICB0YXJnZXQuc3R5bGVbcHJvcF0gPSBwcm9wVmFsdWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgYW5pbWF0aW9uc1xuICAgIH0gPSB0aGlzLnBzd3A7XG4gICAgLyoqIEB0eXBlIHtBbmltYXRpb25Qcm9wc30gKi9cblxuICAgIGNvbnN0IGFuaW1Qcm9wcyA9IHtcbiAgICAgIGR1cmF0aW9uOiB0aGlzLl9kdXJhdGlvbixcbiAgICAgIGVhc2luZzogdGhpcy5wc3dwLm9wdGlvbnMuZWFzaW5nLFxuICAgICAgb25Db21wbGV0ZTogKCkgPT4ge1xuICAgICAgICBpZiAoIWFuaW1hdGlvbnMuYWN0aXZlQW5pbWF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLl9vbkFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0YXJnZXRcbiAgICB9O1xuICAgIGFuaW1Qcm9wc1twcm9wXSA9IHByb3BWYWx1ZTtcbiAgICBhbmltYXRpb25zLnN0YXJ0VHJhbnNpdGlvbihhbmltUHJvcHMpO1xuICB9XG5cbn1cblxuLyoqXHJcbiAqIEB0ZW1wbGF0ZSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vdHlwZXMuanMnKS5UeXBlPFQ+fSBUeXBlPFQ+XHJcbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9zbGlkZS9zbGlkZS5qcycpLlNsaWRlRGF0YX0gU2xpZGVEYXRhICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL3pvb20tbGV2ZWwuanMnKS5ab29tTGV2ZWxPcHRpb259IFpvb21MZXZlbE9wdGlvbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi91aS91aS1lbGVtZW50LmpzJykuVUlFbGVtZW50RGF0YX0gVUlFbGVtZW50RGF0YSAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnLi9tYWluLXNjcm9sbC5qcycpLkl0ZW1Ib2xkZXJ9IEl0ZW1Ib2xkZXIgKi9cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5QaG90b1N3aXBlRXZlbnRzTWFwfSBQaG90b1N3aXBlRXZlbnRzTWFwICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL2NvcmUvZXZlbnRhYmxlLmpzJykuUGhvdG9Td2lwZUZpbHRlcnNNYXB9IFBob3RvU3dpcGVGaWx0ZXJzTWFwICovXG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCcuL3NsaWRlL2dldC10aHVtYi1ib3VuZHMnKS5Cb3VuZHN9IEJvdW5kcyAqL1xuXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5FdmVudENhbGxiYWNrPFQ+fSBFdmVudENhbGxiYWNrPFQ+XHJcbiAqL1xuXG4vKipcclxuICogQHRlbXBsYXRlIHtrZXlvZiBQaG90b1N3aXBlRXZlbnRzTWFwfSBUXHJcbiAqIEB0eXBlZGVmIHtpbXBvcnQoJy4vY29yZS9ldmVudGFibGUuanMnKS5BdWdtZW50ZWRFdmVudDxUPn0gQXVnbWVudGVkRXZlbnQ8VD5cclxuICovXG5cbi8qKiBAdHlwZWRlZiB7eyB4OiBudW1iZXI7IHk6IG51bWJlcjsgaWQ/OiBzdHJpbmcgfCBudW1iZXIgfX0gUG9pbnQgKi9cblxuLyoqIEB0eXBlZGVmIHt7IHRvcDogbnVtYmVyOyBib3R0b206IG51bWJlcjsgbGVmdDogbnVtYmVyOyByaWdodDogbnVtYmVyIH19IFBhZGRpbmcgKi9cblxuLyoqIEB0eXBlZGVmIHtTbGlkZURhdGFbXX0gRGF0YVNvdXJjZUFycmF5ICovXG5cbi8qKiBAdHlwZWRlZiB7eyBnYWxsZXJ5OiBIVE1MRWxlbWVudDsgaXRlbXM/OiBIVE1MRWxlbWVudFtdIH19IERhdGFTb3VyY2VPYmplY3QgKi9cblxuLyoqIEB0eXBlZGVmIHtEYXRhU291cmNlQXJyYXkgfCBEYXRhU291cmNlT2JqZWN0fSBEYXRhU291cmNlICovXG5cbi8qKiBAdHlwZWRlZiB7KHBvaW50OiBQb2ludCwgb3JpZ2luYWxFdmVudDogUG9pbnRlckV2ZW50KSA9PiB2b2lkfSBBY3Rpb25GbiAqL1xuXG4vKiogQHR5cGVkZWYgeydjbG9zZScgfCAnbmV4dCcgfCAnem9vbScgfCAnem9vbS1vci1jbG9zZScgfCAndG9nZ2xlLWNvbnRyb2xzJ30gQWN0aW9uVHlwZSAqL1xuXG4vKiogQHR5cGVkZWYge1R5cGU8UGhvdG9Td2lwZT4gfCB7IGRlZmF1bHQ6IFR5cGU8UGhvdG9Td2lwZT4gfX0gUGhvdG9Td2lwZU1vZHVsZSAqL1xuXG4vKiogQHR5cGVkZWYge1Bob3RvU3dpcGVNb2R1bGUgfCBQcm9taXNlPFBob3RvU3dpcGVNb2R1bGU+IHwgKCgpID0+IFByb21pc2U8UGhvdG9Td2lwZU1vZHVsZT4pfSBQaG90b1N3aXBlTW9kdWxlT3B0aW9uICovXG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7c3RyaW5nIHwgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD4gfCBIVE1MRWxlbWVudFtdIHwgSFRNTEVsZW1lbnR9IEVsZW1lbnRQcm92aWRlclxyXG4gKi9cblxuLyoqIEB0eXBlZGVmIHtQYXJ0aWFsPFByZXBhcmVkUGhvdG9Td2lwZU9wdGlvbnM+fSBQaG90b1N3aXBlT3B0aW9ucyBodHRwczovL3Bob3Rvc3dpcGUuY29tL29wdGlvbnMvICovXG5cbi8qKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zXHJcbiAqXHJcbiAqIEBwcm9wIHtEYXRhU291cmNlfSBbZGF0YVNvdXJjZV1cclxuICogUGFzcyBhbiBhcnJheSBvZiBhbnkgaXRlbXMgdmlhIGRhdGFTb3VyY2Ugb3B0aW9uLiBJdHMgbGVuZ3RoIHdpbGwgZGV0ZXJtaW5lIGFtb3VudCBvZiBzbGlkZXNcclxuICogKHdoaWNoIG1heSBiZSBtb2RpZmllZCBmdXJ0aGVyIGZyb20gbnVtSXRlbXMgZXZlbnQpLlxyXG4gKlxyXG4gKiBFYWNoIGl0ZW0gc2hvdWxkIGNvbnRhaW4gZGF0YSB0aGF0IHlvdSBuZWVkIHRvIGdlbmVyYXRlIHNsaWRlXHJcbiAqIChmb3IgaW1hZ2Ugc2xpZGUgaXQgd291bGQgYmUgc3JjIChpbWFnZSBVUkwpLCB3aWR0aCAoaW1hZ2Ugd2lkdGgpLCBoZWlnaHQsIHNyY3NldCwgYWx0KS5cclxuICpcclxuICogSWYgdGhlc2UgcHJvcGVydGllcyBhcmUgbm90IHByZXNlbnQgaW4geW91ciBpbml0aWFsIGFycmF5LCB5b3UgbWF5IFwicHJlLXBhcnNlXCIgZWFjaCBpdGVtIGZyb20gaXRlbURhdGEgZmlsdGVyLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyfSBiZ09wYWNpdHlcclxuICogQmFja2dyb3VuZCBiYWNrZHJvcCBvcGFjaXR5LCBhbHdheXMgZGVmaW5lIGl0IHZpYSB0aGlzIG9wdGlvbiBhbmQgbm90IHZpYSBDU1MgcmdiYSBjb2xvci5cclxuICpcclxuICogQHByb3Age251bWJlcn0gc3BhY2luZ1xyXG4gKiBTcGFjaW5nIGJldHdlZW4gc2xpZGVzLiBEZWZpbmVkIGFzIHJhdGlvIHJlbGF0aXZlIHRvIHRoZSB2aWV3cG9ydCB3aWR0aCAoMC4xID0gMTAlIG9mIHZpZXdwb3J0KS5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IGFsbG93UGFuVG9OZXh0XHJcbiAqIEFsbG93IHN3aXBlIG5hdmlnYXRpb24gdG8gdGhlIG5leHQgc2xpZGUgd2hlbiB0aGUgY3VycmVudCBzbGlkZSBpcyB6b29tZWQuIERvZXMgbm90IGFwcGx5IHRvIG1vdXNlIGV2ZW50cy5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IGxvb3BcclxuICogSWYgc2V0IHRvIHRydWUgeW91J2xsIGJlIGFibGUgdG8gc3dpcGUgZnJvbSB0aGUgbGFzdCB0byB0aGUgZmlyc3QgaW1hZ2UuXHJcbiAqIE9wdGlvbiBpcyBhbHdheXMgZmFsc2Ugd2hlbiB0aGVyZSBhcmUgbGVzcyB0aGFuIDMgc2xpZGVzLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW3doZWVsVG9ab29tXVxyXG4gKiBCeSBkZWZhdWx0IFBob3RvU3dpcGUgem9vbXMgaW1hZ2Ugd2l0aCBjdHJsLXdoZWVsLCBpZiB5b3UgZW5hYmxlIHRoaXMgb3B0aW9uIC0gaW1hZ2Ugd2lsbCB6b29tIGp1c3QgdmlhIHdoZWVsLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gcGluY2hUb0Nsb3NlXHJcbiAqIFBpbmNoIHRvdWNoIGdlc3R1cmUgdG8gY2xvc2UgdGhlIGdhbGxlcnkuXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBjbG9zZU9uVmVydGljYWxEcmFnXHJcbiAqIFZlcnRpY2FsIGRyYWcgZ2VzdHVyZSB0byBjbG9zZSB0aGUgUGhvdG9Td2lwZS5cclxuICpcclxuICogQHByb3Age1BhZGRpbmd9IFtwYWRkaW5nXVxyXG4gKiBTbGlkZSBhcmVhIHBhZGRpbmcgKGluIHBpeGVscykuXHJcbiAqXHJcbiAqIEBwcm9wIHsodmlld3BvcnRTaXplOiBQb2ludCwgaXRlbURhdGE6IFNsaWRlRGF0YSwgaW5kZXg6IG51bWJlcikgPT4gUGFkZGluZ30gW3BhZGRpbmdGbl1cclxuICogVGhlIG9wdGlvbiBpcyBjaGVja2VkIGZyZXF1ZW50bHksIHNvIG1ha2Ugc3VyZSBpdCdzIHBlcmZvcm1hbnQuIE92ZXJyaWRlcyBwYWRkaW5nIG9wdGlvbiBpZiBkZWZpbmVkLiBGb3IgZXhhbXBsZTpcclxuICpcclxuICogQHByb3Age251bWJlciB8IGZhbHNlfSBoaWRlQW5pbWF0aW9uRHVyYXRpb25cclxuICogVHJhbnNpdGlvbiBkdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMsIGNhbiBiZSAwLlxyXG4gKlxyXG4gKiBAcHJvcCB7bnVtYmVyIHwgZmFsc2V9IHNob3dBbmltYXRpb25EdXJhdGlvblxyXG4gKiBUcmFuc2l0aW9uIGR1cmF0aW9uIGluIG1pbGxpc2Vjb25kcywgY2FuIGJlIDAuXHJcbiAqXHJcbiAqIEBwcm9wIHtudW1iZXIgfCBmYWxzZX0gem9vbUFuaW1hdGlvbkR1cmF0aW9uXHJcbiAqIFRyYW5zaXRpb24gZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLCBjYW4gYmUgMC5cclxuICpcclxuICogQHByb3Age3N0cmluZ30gZWFzaW5nXHJcbiAqIFN0cmluZywgJ2N1YmljLWJlemllciguNCwwLC4yMiwxKScuIENTUyBlYXNpbmcgZnVuY3Rpb24gZm9yIG9wZW4vY2xvc2Uvem9vbSB0cmFuc2l0aW9ucy5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IGVzY0tleVxyXG4gKiBFc2Mga2V5IHRvIGNsb3NlLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gYXJyb3dLZXlzXHJcbiAqIExlZnQvcmlnaHQgYXJyb3cga2V5cyBmb3IgbmF2aWdhdGlvbi5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IHRyYXBGb2N1c1xyXG4gKiBUcmFwIGZvY3VzIHdpdGhpbiBQaG90b1N3aXBlIGVsZW1lbnQgd2hpbGUgaXQncyBvcGVuLlxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gcmV0dXJuRm9jdXNcclxuICogUmVzdG9yZSBmb2N1cyB0aGUgbGFzdCBhY3RpdmUgZWxlbWVudCBhZnRlciBQaG90b1N3aXBlIGlzIGNsb3NlZC5cclxuICpcclxuICogQHByb3Age2Jvb2xlYW59IGNsaWNrVG9DbG9zZU5vblpvb21hYmxlXHJcbiAqIElmIGltYWdlIGlzIG5vdCB6b29tYWJsZSAoZm9yIGV4YW1wbGUsIHNtYWxsZXIgdGhhbiB2aWV3cG9ydCkgaXQgY2FuIGJlIGNsb3NlZCBieSBjbGlja2luZyBvbiBpdC5cclxuICpcclxuICogQHByb3Age0FjdGlvblR5cGUgfCBBY3Rpb25GbiB8IGZhbHNlfSBpbWFnZUNsaWNrQWN0aW9uXHJcbiAqIFJlZmVyIHRvIGNsaWNrIGFuZCB0YXAgYWN0aW9ucyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7QWN0aW9uVHlwZSB8IEFjdGlvbkZuIHwgZmFsc2V9IGJnQ2xpY2tBY3Rpb25cclxuICogUmVmZXIgdG8gY2xpY2sgYW5kIHRhcCBhY3Rpb25zIHBhZ2UuXHJcbiAqXHJcbiAqIEBwcm9wIHtBY3Rpb25UeXBlIHwgQWN0aW9uRm4gfCBmYWxzZX0gdGFwQWN0aW9uXHJcbiAqIFJlZmVyIHRvIGNsaWNrIGFuZCB0YXAgYWN0aW9ucyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7QWN0aW9uVHlwZSB8IEFjdGlvbkZuIHwgZmFsc2V9IGRvdWJsZVRhcEFjdGlvblxyXG4gKiBSZWZlciB0byBjbGljayBhbmQgdGFwIGFjdGlvbnMgcGFnZS5cclxuICpcclxuICogQHByb3Age251bWJlcn0gcHJlbG9hZGVyRGVsYXlcclxuICogRGVsYXkgYmVmb3JlIHRoZSBsb2FkaW5nIGluZGljYXRvciB3aWxsIGJlIGRpc3BsYXllZCxcclxuICogaWYgaW1hZ2UgaXMgbG9hZGVkIGR1cmluZyBpdCAtIHRoZSBpbmRpY2F0b3Igd2lsbCBub3QgYmUgZGlzcGxheWVkIGF0IGFsbC4gQ2FuIGJlIHplcm8uXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IGluZGV4SW5kaWNhdG9yU2VwXHJcbiAqIFVzZWQgZm9yIHNsaWRlIGNvdW50IGluZGljYXRvciAoXCIxIG9mIDEwIFwiKS5cclxuICpcclxuICogQHByb3AgeyhvcHRpb25zOiBQaG90b1N3aXBlT3B0aW9ucywgcHN3cDogUGhvdG9Td2lwZUJhc2UpID0+IFBvaW50fSBbZ2V0Vmlld3BvcnRTaXplRm5dXHJcbiAqIEEgZnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIHNsaWRlIHZpZXdwb3J0IHdpZHRoIGFuZCBoZWlnaHQsIGluIGZvcm1hdCB7eDogMTAwLCB5OiAxMDB9LlxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBlcnJvck1zZ1xyXG4gKiBNZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB0aGUgaW1hZ2Ugd2Fzbid0IGFibGUgdG8gbG9hZC4gSWYgeW91IG5lZWQgdG8gZGlzcGxheSBIVE1MIC0gdXNlIGNvbnRlbnRFcnJvckVsZW1lbnQgZmlsdGVyLlxyXG4gKlxyXG4gKiBAcHJvcCB7W251bWJlciwgbnVtYmVyXX0gcHJlbG9hZFxyXG4gKiBMYXp5IGxvYWRpbmcgb2YgbmVhcmJ5IHNsaWRlcyBiYXNlZCBvbiBkaXJlY3Rpb24gb2YgbW92ZW1lbnQuIFNob3VsZCBiZSBhbiBhcnJheSB3aXRoIHR3byBpbnRlZ2VycyxcclxuICogZmlyc3Qgb25lIC0gbnVtYmVyIG9mIGl0ZW1zIHRvIHByZWxvYWQgYmVmb3JlIHRoZSBjdXJyZW50IGltYWdlLCBzZWNvbmQgb25lIC0gYWZ0ZXIgdGhlIGN1cnJlbnQgaW1hZ2UuXHJcbiAqIFR3byBuZWFyYnkgaW1hZ2VzIGFyZSBhbHdheXMgbG9hZGVkLlxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbbWFpbkNsYXNzXVxyXG4gKiBDbGFzcyB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHJvb3QgZWxlbWVudCBvZiBQaG90b1N3aXBlLCBtYXkgY29udGFpbiBtdWx0aXBsZSBzZXBhcmF0ZWQgYnkgc3BhY2UuXHJcbiAqIEV4YW1wbGUgb24gU3R5bGluZyBwYWdlLlxyXG4gKlxyXG4gKiBAcHJvcCB7SFRNTEVsZW1lbnR9IFthcHBlbmRUb0VsXVxyXG4gKiBFbGVtZW50IHRvIHdoaWNoIFBob3RvU3dpcGUgZGlhbG9nIHdpbGwgYmUgYXBwZW5kZWQgd2hlbiBpdCBvcGVucy5cclxuICpcclxuICogQHByb3Age251bWJlcn0gbWF4V2lkdGhUb0FuaW1hdGVcclxuICogTWF4aW11bSB3aWR0aCBvZiBpbWFnZSB0byBhbmltYXRlLCBpZiBpbml0aWFsIHJlbmRlcmVkIGltYWdlIHdpZHRoXHJcbiAqIGlzIGxhcmdlciB0aGFuIHRoaXMgdmFsdWUgLSB0aGUgb3BlbmluZy9jbG9zaW5nIHRyYW5zaXRpb24gd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGRpc2FibGVkLlxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbY2xvc2VUaXRsZV1cclxuICogVHJhbnNsYXRpbmdcclxuICpcclxuICogQHByb3Age3N0cmluZ30gW3pvb21UaXRsZV1cclxuICogVHJhbnNsYXRpbmdcclxuICpcclxuICogQHByb3Age3N0cmluZ30gW2Fycm93UHJldlRpdGxlXVxyXG4gKiBUcmFuc2xhdGluZ1xyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbYXJyb3dOZXh0VGl0bGVdXHJcbiAqIFRyYW5zbGF0aW5nXHJcbiAqXHJcbiAqIEBwcm9wIHsnem9vbScgfCAnZmFkZScgfCAnbm9uZSd9IFtzaG93SGlkZUFuaW1hdGlvblR5cGVdXHJcbiAqIFRvIGFkanVzdCBvcGVuaW5nIG9yIGNsb3NpbmcgdHJhbnNpdGlvbiB0eXBlIHVzZSBsaWdodGJveCBvcHRpb24gYHNob3dIaWRlQW5pbWF0aW9uVHlwZWAgKGBTdHJpbmdgKS5cclxuICogSXQgc3VwcG9ydHMgdGhyZWUgdmFsdWVzIC0gYHpvb21gIChkZWZhdWx0KSwgYGZhZGVgIChkZWZhdWx0IGlmIHRoZXJlIGlzIG5vIHRodW1ibmFpbCkgYW5kIGBub25lYC5cclxuICpcclxuICogQW5pbWF0aW9ucyBhcmUgYXV0b21hdGljYWxseSBkaXNhYmxlZCBpZiB1c2VyIGAocHJlZmVycy1yZWR1Y2VkLW1vdGlvbjogcmVkdWNlKWAuXHJcbiAqXHJcbiAqIEBwcm9wIHtudW1iZXJ9IGluZGV4XHJcbiAqIERlZmluZXMgc3RhcnQgc2xpZGUgaW5kZXguXHJcbiAqXHJcbiAqIEBwcm9wIHsoZTogTW91c2VFdmVudCkgPT4gbnVtYmVyfSBbZ2V0Q2xpY2tlZEluZGV4Rm5dXHJcbiAqXHJcbiAqIEBwcm9wIHtib29sZWFufSBbYXJyb3dQcmV2XVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW2Fycm93TmV4dF1cclxuICogQHByb3Age2Jvb2xlYW59IFt6b29tXVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW2Nsb3NlXVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW2NvdW50ZXJdXHJcbiAqXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFthcnJvd1ByZXZTVkddXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFthcnJvd05leHRTVkddXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFt6b29tU1ZHXVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbY2xvc2VTVkddXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtjb3VudGVyU1ZHXVxyXG4gKlxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbYXJyb3dQcmV2VGl0bGVdXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFthcnJvd05leHRUaXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW3pvb21UaXRsZV1cclxuICogQHByb3Age3N0cmluZ30gW2Nsb3NlVGl0bGVdXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtjb3VudGVyVGl0bGVdXHJcbiAqXHJcbiAqIEBwcm9wIHtab29tTGV2ZWxPcHRpb259IFtpbml0aWFsWm9vbUxldmVsXVxyXG4gKiBAcHJvcCB7Wm9vbUxldmVsT3B0aW9ufSBbc2Vjb25kYXJ5Wm9vbUxldmVsXVxyXG4gKiBAcHJvcCB7Wm9vbUxldmVsT3B0aW9ufSBbbWF4Wm9vbUxldmVsXVxyXG4gKlxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW21vdXNlTW92ZVBhbl1cclxuICogQHByb3Age1BvaW50IHwgbnVsbH0gW2luaXRpYWxQb2ludGVyUG9zXVxyXG4gKiBAcHJvcCB7Ym9vbGVhbn0gW3Nob3dIaWRlT3BhY2l0eV1cclxuICpcclxuICogQHByb3Age1Bob3RvU3dpcGVNb2R1bGVPcHRpb259IFtwc3dwTW9kdWxlXVxyXG4gKiBAcHJvcCB7KCkgPT4gUHJvbWlzZTxhbnk+fSBbb3BlblByb21pc2VdXHJcbiAqIEBwcm9wIHtib29sZWFufSBbcHJlbG9hZEZpcnN0U2xpZGVdXHJcbiAqIEBwcm9wIHtFbGVtZW50UHJvdmlkZXJ9IFtnYWxsZXJ5XVxyXG4gKiBAcHJvcCB7c3RyaW5nfSBbZ2FsbGVyeVNlbGVjdG9yXVxyXG4gKiBAcHJvcCB7RWxlbWVudFByb3ZpZGVyfSBbY2hpbGRyZW5dXHJcbiAqIEBwcm9wIHtzdHJpbmd9IFtjaGlsZFNlbGVjdG9yXVxyXG4gKiBAcHJvcCB7c3RyaW5nIHwgZmFsc2V9IFt0aHVtYlNlbGVjdG9yXVxyXG4gKi9cblxuLyoqIEB0eXBlIHtQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zfSAqL1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWxsb3dQYW5Ub05leHQ6IHRydWUsXG4gIHNwYWNpbmc6IDAuMSxcbiAgbG9vcDogdHJ1ZSxcbiAgcGluY2hUb0Nsb3NlOiB0cnVlLFxuICBjbG9zZU9uVmVydGljYWxEcmFnOiB0cnVlLFxuICBoaWRlQW5pbWF0aW9uRHVyYXRpb246IDMzMyxcbiAgc2hvd0FuaW1hdGlvbkR1cmF0aW9uOiAzMzMsXG4gIHpvb21BbmltYXRpb25EdXJhdGlvbjogMzMzLFxuICBlc2NLZXk6IHRydWUsXG4gIGFycm93S2V5czogdHJ1ZSxcbiAgdHJhcEZvY3VzOiB0cnVlLFxuICByZXR1cm5Gb2N1czogdHJ1ZSxcbiAgbWF4V2lkdGhUb0FuaW1hdGU6IDQwMDAsXG4gIGNsaWNrVG9DbG9zZU5vblpvb21hYmxlOiB0cnVlLFxuICBpbWFnZUNsaWNrQWN0aW9uOiAnem9vbS1vci1jbG9zZScsXG4gIGJnQ2xpY2tBY3Rpb246ICdjbG9zZScsXG4gIHRhcEFjdGlvbjogJ3RvZ2dsZS1jb250cm9scycsXG4gIGRvdWJsZVRhcEFjdGlvbjogJ3pvb20nLFxuICBpbmRleEluZGljYXRvclNlcDogJyAvICcsXG4gIHByZWxvYWRlckRlbGF5OiAyMDAwLFxuICBiZ09wYWNpdHk6IDAuOCxcbiAgaW5kZXg6IDAsXG4gIGVycm9yTXNnOiAnVGhlIGltYWdlIGNhbm5vdCBiZSBsb2FkZWQnLFxuICBwcmVsb2FkOiBbMSwgMl0sXG4gIGVhc2luZzogJ2N1YmljLWJlemllciguNCwwLC4yMiwxKSdcbn07XG4vKipcclxuICogUGhvdG9Td2lwZSBDb3JlXHJcbiAqL1xuXG5jbGFzcyBQaG90b1N3aXBlIGV4dGVuZHMgUGhvdG9Td2lwZUJhc2Uge1xuICAvKipcclxuICAgKiBAcGFyYW0ge1Bob3RvU3dpcGVPcHRpb25zfSBbb3B0aW9uc11cclxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5vcHRpb25zID0gdGhpcy5fcHJlcGFyZU9wdGlvbnMob3B0aW9ucyB8fCB7fSk7XG4gICAgLyoqXHJcbiAgICAgKiBvZmZzZXQgb2Ygdmlld3BvcnQgcmVsYXRpdmUgdG8gZG9jdW1lbnRcclxuICAgICAqXHJcbiAgICAgKiBAdHlwZSB7UG9pbnR9XHJcbiAgICAgKi9cblxuICAgIHRoaXMub2Zmc2V0ID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuICAgIC8qKlxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqL1xuXG4gICAgdGhpcy5fcHJldlZpZXdwb3J0U2l6ZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIFNpemUgb2Ygc2Nyb2xsYWJsZSBQaG90b1N3aXBlIHZpZXdwb3J0XHJcbiAgICAgKlxyXG4gICAgICogQHR5cGUge1BvaW50fVxyXG4gICAgICovXG5cbiAgICB0aGlzLnZpZXdwb3J0U2l6ZSA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgICAvKipcclxuICAgICAqIGJhY2tncm91bmQgKGJhY2tkcm9wKSBvcGFjaXR5XHJcbiAgICAgKi9cblxuICAgIHRoaXMuYmdPcGFjaXR5ID0gMTtcbiAgICB0aGlzLmN1cnJJbmRleCA9IDA7XG4gICAgdGhpcy5wb3RlbnRpYWxJbmRleCA9IDA7XG4gICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICB0aGlzLmlzRGVzdHJveWluZyA9IGZhbHNlO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcbiAgICAvKipcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAdHlwZSB7U2xpZGVEYXRhfVxyXG4gICAgICovXG5cbiAgICB0aGlzLl9pbml0aWFsSXRlbURhdGEgPSB7fTtcbiAgICAvKiogQHR5cGUge0JvdW5kcyB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMuX2luaXRpYWxUaHVtYkJvdW5kcyA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkfSAqL1xuXG4gICAgdGhpcy50b3BCYXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtIVE1MRGl2RWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMuZWxlbWVudCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkfSAqL1xuXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge0hUTUxEaXZFbGVtZW50IHwgdW5kZWZpbmVkfSAqL1xuXG4gICAgdGhpcy5jb250YWluZXIgPSB1bmRlZmluZWQ7XG4gICAgLyoqIEB0eXBlIHtIVE1MRWxlbWVudCB8IHVuZGVmaW5lZH0gKi9cblxuICAgIHRoaXMuc2Nyb2xsV3JhcCA9IHVuZGVmaW5lZDtcbiAgICAvKiogQHR5cGUge1NsaWRlIHwgdW5kZWZpbmVkfSAqL1xuXG4gICAgdGhpcy5jdXJyU2xpZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5ldmVudHMgPSBuZXcgRE9NRXZlbnRzKCk7XG4gICAgdGhpcy5hbmltYXRpb25zID0gbmV3IEFuaW1hdGlvbnMoKTtcbiAgICB0aGlzLm1haW5TY3JvbGwgPSBuZXcgTWFpblNjcm9sbCh0aGlzKTtcbiAgICB0aGlzLmdlc3R1cmVzID0gbmV3IEdlc3R1cmVzKHRoaXMpO1xuICAgIHRoaXMub3BlbmVyID0gbmV3IE9wZW5lcih0aGlzKTtcbiAgICB0aGlzLmtleWJvYXJkID0gbmV3IEtleWJvYXJkKHRoaXMpO1xuICAgIHRoaXMuY29udGVudExvYWRlciA9IG5ldyBDb250ZW50TG9hZGVyKHRoaXMpO1xuICB9XG4gIC8qKiBAcmV0dXJucyB7Ym9vbGVhbn0gKi9cblxuXG4gIGluaXQoKSB7XG4gICAgaWYgKHRoaXMuaXNPcGVuIHx8IHRoaXMuaXNEZXN0cm95aW5nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuICAgIHRoaXMuZGlzcGF0Y2goJ2luaXQnKTsgLy8gbGVnYWN5XG5cbiAgICB0aGlzLmRpc3BhdGNoKCdiZWZvcmVPcGVuJyk7XG5cbiAgICB0aGlzLl9jcmVhdGVNYWluU3RydWN0dXJlKCk7IC8vIGFkZCBjbGFzc2VzIHRvIHRoZSByb290IGVsZW1lbnQgb2YgUGhvdG9Td2lwZVxuXG5cbiAgICBsZXQgcm9vdENsYXNzZXMgPSAncHN3cC0tb3Blbic7XG5cbiAgICBpZiAodGhpcy5nZXN0dXJlcy5zdXBwb3J0c1RvdWNoKSB7XG4gICAgICByb290Q2xhc3NlcyArPSAnIHBzd3AtLXRvdWNoJztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm1haW5DbGFzcykge1xuICAgICAgcm9vdENsYXNzZXMgKz0gJyAnICsgdGhpcy5vcHRpb25zLm1haW5DbGFzcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuY2xhc3NOYW1lICs9ICcgJyArIHJvb3RDbGFzc2VzO1xuICAgIH1cblxuICAgIHRoaXMuY3VyckluZGV4ID0gdGhpcy5vcHRpb25zLmluZGV4IHx8IDA7XG4gICAgdGhpcy5wb3RlbnRpYWxJbmRleCA9IHRoaXMuY3VyckluZGV4O1xuICAgIHRoaXMuZGlzcGF0Y2goJ2ZpcnN0VXBkYXRlJyk7IC8vIHN0YXJ0aW5nIGluZGV4IGNhbiBiZSBtb2RpZmllZCBoZXJlXG4gICAgLy8gaW5pdGlhbGl6ZSBzY3JvbGwgd2hlZWwgaGFuZGxlciB0byBibG9jayB0aGUgc2Nyb2xsXG5cbiAgICB0aGlzLnNjcm9sbFdoZWVsID0gbmV3IFNjcm9sbFdoZWVsKHRoaXMpOyAvLyBzYW5pdGl6ZSBpbmRleFxuXG4gICAgaWYgKE51bWJlci5pc05hTih0aGlzLmN1cnJJbmRleCkgfHwgdGhpcy5jdXJySW5kZXggPCAwIHx8IHRoaXMuY3VyckluZGV4ID49IHRoaXMuZ2V0TnVtSXRlbXMoKSkge1xuICAgICAgdGhpcy5jdXJySW5kZXggPSAwO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXN0dXJlcy5zdXBwb3J0c1RvdWNoKSB7XG4gICAgICAvLyBlbmFibGUgbW91c2UgZmVhdHVyZXMgaWYgbm8gdG91Y2ggc3VwcG9ydCBkZXRlY3RlZFxuICAgICAgdGhpcy5tb3VzZURldGVjdGVkKCk7XG4gICAgfSAvLyBjYXVzZXMgZm9yY2VkIHN5bmNocm9ub3VzIGxheW91dFxuXG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB0aGlzLm9mZnNldC55ID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHRoaXMuX2luaXRpYWxJdGVtRGF0YSA9IHRoaXMuZ2V0SXRlbURhdGEodGhpcy5jdXJySW5kZXgpO1xuICAgIHRoaXMuZGlzcGF0Y2goJ2dldHRpbmdEYXRhJywge1xuICAgICAgaW5kZXg6IHRoaXMuY3VyckluZGV4LFxuICAgICAgZGF0YTogdGhpcy5faW5pdGlhbEl0ZW1EYXRhLFxuICAgICAgc2xpZGU6IHVuZGVmaW5lZFxuICAgIH0pOyAvLyAqTGF5b3V0KiAtIGNhbGN1bGF0ZSBzaXplIGFuZCBwb3NpdGlvbiBvZiBlbGVtZW50cyBoZXJlXG5cbiAgICB0aGlzLl9pbml0aWFsVGh1bWJCb3VuZHMgPSB0aGlzLmdldFRodW1iQm91bmRzKCk7XG4gICAgdGhpcy5kaXNwYXRjaCgnaW5pdGlhbExheW91dCcpO1xuICAgIHRoaXMub24oJ29wZW5pbmdBbmltYXRpb25FbmQnLCAoKSA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGl0ZW1Ib2xkZXJzXG4gICAgICB9ID0gdGhpcy5tYWluU2Nyb2xsOyAvLyBBZGQgY29udGVudCB0byB0aGUgcHJldmlvdXMgYW5kIG5leHQgc2xpZGVcblxuICAgICAgaWYgKGl0ZW1Ib2xkZXJzWzBdKSB7XG4gICAgICAgIGl0ZW1Ib2xkZXJzWzBdLmVsLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0aGlzLnNldENvbnRlbnQoaXRlbUhvbGRlcnNbMF0sIHRoaXMuY3VyckluZGV4IC0gMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVtSG9sZGVyc1syXSkge1xuICAgICAgICBpdGVtSG9sZGVyc1syXS5lbC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgdGhpcy5zZXRDb250ZW50KGl0ZW1Ib2xkZXJzWzJdLCB0aGlzLmN1cnJJbmRleCArIDEpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFwcGVuZEhlYXZ5KCk7XG4gICAgICB0aGlzLmNvbnRlbnRMb2FkZXIudXBkYXRlTGF6eSgpO1xuICAgICAgdGhpcy5ldmVudHMuYWRkKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZVBhZ2VSZXNpemUuYmluZCh0aGlzKSk7XG4gICAgICB0aGlzLmV2ZW50cy5hZGQod2luZG93LCAnc2Nyb2xsJywgdGhpcy5fdXBkYXRlUGFnZVNjcm9sbE9mZnNldC5iaW5kKHRoaXMpKTtcbiAgICAgIHRoaXMuZGlzcGF0Y2goJ2JpbmRFdmVudHMnKTtcbiAgICB9KTsgLy8gc2V0IGNvbnRlbnQgZm9yIGNlbnRlciBzbGlkZSAoZmlyc3QgdGltZSlcblxuICAgIGlmICh0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnNbMV0pIHtcbiAgICAgIHRoaXMuc2V0Q29udGVudCh0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnNbMV0sIHRoaXMuY3VyckluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoKCdjaGFuZ2UnKTtcbiAgICB0aGlzLm9wZW5lci5vcGVuKCk7XG4gICAgdGhpcy5kaXNwYXRjaCgnYWZ0ZXJJbml0Jyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXHJcbiAgICogR2V0IGxvb3BlZCBzbGlkZSBpbmRleFxyXG4gICAqIChmb3IgZXhhbXBsZSwgLTEgd2lsbCByZXR1cm4gdGhlIGxhc3Qgc2xpZGUpXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xuXG5cbiAgZ2V0TG9vcGVkSW5kZXgoaW5kZXgpIHtcbiAgICBjb25zdCBudW1TbGlkZXMgPSB0aGlzLmdldE51bUl0ZW1zKCk7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmxvb3ApIHtcbiAgICAgIGlmIChpbmRleCA+IG51bVNsaWRlcyAtIDEpIHtcbiAgICAgICAgaW5kZXggLT0gbnVtU2xpZGVzO1xuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ICs9IG51bVNsaWRlcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xhbXAoaW5kZXgsIDAsIG51bVNsaWRlcyAtIDEpO1xuICB9XG5cbiAgYXBwZW5kSGVhdnkoKSB7XG4gICAgdGhpcy5tYWluU2Nyb2xsLml0ZW1Ib2xkZXJzLmZvckVhY2goaXRlbUhvbGRlciA9PiB7XG4gICAgICB2YXIgX2l0ZW1Ib2xkZXIkc2xpZGU7XG5cbiAgICAgIChfaXRlbUhvbGRlciRzbGlkZSA9IGl0ZW1Ib2xkZXIuc2xpZGUpID09PSBudWxsIHx8IF9pdGVtSG9sZGVyJHNsaWRlID09PSB2b2lkIDAgfHwgX2l0ZW1Ib2xkZXIkc2xpZGUuYXBwZW5kSGVhdnkoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBDaGFuZ2UgdGhlIHNsaWRlXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IE5ldyBpbmRleFxyXG4gICAqL1xuXG5cbiAgZ29UbyhpbmRleCkge1xuICAgIHRoaXMubWFpblNjcm9sbC5tb3ZlSW5kZXhCeSh0aGlzLmdldExvb3BlZEluZGV4KGluZGV4KSAtIHRoaXMucG90ZW50aWFsSW5kZXgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBuZXh0IHNsaWRlLlxyXG4gICAqL1xuXG5cbiAgbmV4dCgpIHtcbiAgICB0aGlzLmdvVG8odGhpcy5wb3RlbnRpYWxJbmRleCArIDEpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdvIHRvIHRoZSBwcmV2aW91cyBzbGlkZS5cclxuICAgKi9cblxuXG4gIHByZXYoKSB7XG4gICAgdGhpcy5nb1RvKHRoaXMucG90ZW50aWFsSW5kZXggLSAxKTtcbiAgfVxuICAvKipcclxuICAgKiBAc2VlIHNsaWRlL3NsaWRlLmpzIHpvb21Ub1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJzPFNsaWRlWyd6b29tVG8nXT59IGFyZ3NcclxuICAgKi9cblxuXG4gIHpvb21UbyguLi5hcmdzKSB7XG4gICAgdmFyIF90aGlzJGN1cnJTbGlkZTtcblxuICAgIChfdGhpcyRjdXJyU2xpZGUgPSB0aGlzLmN1cnJTbGlkZSkgPT09IG51bGwgfHwgX3RoaXMkY3VyclNsaWRlID09PSB2b2lkIDAgfHwgX3RoaXMkY3VyclNsaWRlLnpvb21UbyguLi5hcmdzKTtcbiAgfVxuICAvKipcclxuICAgKiBAc2VlIHNsaWRlL3NsaWRlLmpzIHRvZ2dsZVpvb21cclxuICAgKi9cblxuXG4gIHRvZ2dsZVpvb20oKSB7XG4gICAgdmFyIF90aGlzJGN1cnJTbGlkZTI7XG5cbiAgICAoX3RoaXMkY3VyclNsaWRlMiA9IHRoaXMuY3VyclNsaWRlKSA9PT0gbnVsbCB8fCBfdGhpcyRjdXJyU2xpZGUyID09PSB2b2lkIDAgfHwgX3RoaXMkY3VyclNsaWRlMi50b2dnbGVab29tKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQ2xvc2UgdGhlIGdhbGxlcnkuXHJcbiAgICogQWZ0ZXIgY2xvc2luZyB0cmFuc2l0aW9uIGVuZHMgLSBkZXN0cm95IGl0XHJcbiAgICovXG5cblxuICBjbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVyLmlzT3BlbiB8fCB0aGlzLmlzRGVzdHJveWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuaXNEZXN0cm95aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpc3BhdGNoKCdjbG9zZScpO1xuICAgIHRoaXMuZXZlbnRzLnJlbW92ZUFsbCgpO1xuICAgIHRoaXMub3BlbmVyLmNsb3NlKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGVzdHJveXMgdGhlIGdhbGxlcnk6XHJcbiAgICogLSBpbnN0YW50bHkgY2xvc2VzIHRoZSBnYWxsZXJ5XHJcbiAgICogLSB1bmJpbmRzIGV2ZW50cyxcclxuICAgKiAtIGNsZWFucyBpbnRlcnZhbHMgYW5kIHRpbWVvdXRzXHJcbiAgICogLSByZW1vdmVzIGVsZW1lbnRzIGZyb20gRE9NXHJcbiAgICovXG5cblxuICBkZXN0cm95KCkge1xuICAgIHZhciBfdGhpcyRlbGVtZW50O1xuXG4gICAgaWYgKCF0aGlzLmlzRGVzdHJveWluZykge1xuICAgICAgdGhpcy5vcHRpb25zLnNob3dIaWRlQW5pbWF0aW9uVHlwZSA9ICdub25lJztcbiAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoKCdkZXN0cm95Jyk7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG5cbiAgICBpZiAodGhpcy5zY3JvbGxXcmFwKSB7XG4gICAgICB0aGlzLnNjcm9sbFdyYXAub250b3VjaG1vdmUgPSBudWxsO1xuICAgICAgdGhpcy5zY3JvbGxXcmFwLm9udG91Y2hlbmQgPSBudWxsO1xuICAgIH1cblxuICAgIChfdGhpcyRlbGVtZW50ID0gdGhpcy5lbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRlbGVtZW50ID09PSB2b2lkIDAgfHwgX3RoaXMkZWxlbWVudC5yZW1vdmUoKTtcbiAgICB0aGlzLm1haW5TY3JvbGwuaXRlbUhvbGRlcnMuZm9yRWFjaChpdGVtSG9sZGVyID0+IHtcbiAgICAgIHZhciBfaXRlbUhvbGRlciRzbGlkZTI7XG5cbiAgICAgIChfaXRlbUhvbGRlciRzbGlkZTIgPSBpdGVtSG9sZGVyLnNsaWRlKSA9PT0gbnVsbCB8fCBfaXRlbUhvbGRlciRzbGlkZTIgPT09IHZvaWQgMCB8fCBfaXRlbUhvbGRlciRzbGlkZTIuZGVzdHJveSgpO1xuICAgIH0pO1xuICAgIHRoaXMuY29udGVudExvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy5ldmVudHMucmVtb3ZlQWxsKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVmcmVzaC9yZWxvYWQgY29udGVudCBvZiBhIHNsaWRlIGJ5IGl0cyBpbmRleFxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHNsaWRlSW5kZXhcclxuICAgKi9cblxuXG4gIHJlZnJlc2hTbGlkZUNvbnRlbnQoc2xpZGVJbmRleCkge1xuICAgIHRoaXMuY29udGVudExvYWRlci5yZW1vdmVCeUluZGV4KHNsaWRlSW5kZXgpO1xuICAgIHRoaXMubWFpblNjcm9sbC5pdGVtSG9sZGVycy5mb3JFYWNoKChpdGVtSG9sZGVyLCBpKSA9PiB7XG4gICAgICB2YXIgX3RoaXMkY3VyclNsaWRlJGluZGV4LCBfdGhpcyRjdXJyU2xpZGUzO1xuXG4gICAgICBsZXQgcG90ZW50aWFsSG9sZGVySW5kZXggPSAoKF90aGlzJGN1cnJTbGlkZSRpbmRleCA9IChfdGhpcyRjdXJyU2xpZGUzID0gdGhpcy5jdXJyU2xpZGUpID09PSBudWxsIHx8IF90aGlzJGN1cnJTbGlkZTMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJGN1cnJTbGlkZTMuaW5kZXgpICE9PSBudWxsICYmIF90aGlzJGN1cnJTbGlkZSRpbmRleCAhPT0gdm9pZCAwID8gX3RoaXMkY3VyclNsaWRlJGluZGV4IDogMCkgLSAxICsgaTtcblxuICAgICAgaWYgKHRoaXMuY2FuTG9vcCgpKSB7XG4gICAgICAgIHBvdGVudGlhbEhvbGRlckluZGV4ID0gdGhpcy5nZXRMb29wZWRJbmRleChwb3RlbnRpYWxIb2xkZXJJbmRleCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3RlbnRpYWxIb2xkZXJJbmRleCA9PT0gc2xpZGVJbmRleCkge1xuICAgICAgICAvLyBzZXQgdGhlIG5ldyBzbGlkZSBjb250ZW50XG4gICAgICAgIHRoaXMuc2V0Q29udGVudChpdGVtSG9sZGVyLCBzbGlkZUluZGV4LCB0cnVlKTsgLy8gYWN0aXZhdGUgdGhlIG5ldyBzbGlkZSBpZiBpdCdzIGN1cnJlbnRcblxuICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgIHZhciBfaXRlbUhvbGRlciRzbGlkZTM7XG5cbiAgICAgICAgICB0aGlzLmN1cnJTbGlkZSA9IGl0ZW1Ib2xkZXIuc2xpZGU7XG4gICAgICAgICAgKF9pdGVtSG9sZGVyJHNsaWRlMyA9IGl0ZW1Ib2xkZXIuc2xpZGUpID09PSBudWxsIHx8IF9pdGVtSG9sZGVyJHNsaWRlMyA9PT0gdm9pZCAwIHx8IF9pdGVtSG9sZGVyJHNsaWRlMy5zZXRJc0FjdGl2ZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZGlzcGF0Y2goJ2NoYW5nZScpO1xuICB9XG4gIC8qKlxyXG4gICAqIFNldCBzbGlkZSBjb250ZW50XHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0l0ZW1Ib2xkZXJ9IGhvbGRlciBtYWluU2Nyb2xsLml0ZW1Ib2xkZXJzIGFycmF5IGl0ZW1cclxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggU2xpZGUgaW5kZXhcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gSWYgY29udGVudCBzaG91bGQgYmUgc2V0IGV2ZW4gaWYgaW5kZXggd2Fzbid0IGNoYW5nZWRcclxuICAgKi9cblxuXG4gIHNldENvbnRlbnQoaG9sZGVyLCBpbmRleCwgZm9yY2UpIHtcbiAgICBpZiAodGhpcy5jYW5Mb29wKCkpIHtcbiAgICAgIGluZGV4ID0gdGhpcy5nZXRMb29wZWRJbmRleChpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGhvbGRlci5zbGlkZSkge1xuICAgICAgaWYgKGhvbGRlci5zbGlkZS5pbmRleCA9PT0gaW5kZXggJiYgIWZvcmNlKSB7XG4gICAgICAgIC8vIGV4aXQgaWYgaG9sZGVyIGFscmVhZHkgY29udGFpbnMgdGhpcyBzbGlkZVxuICAgICAgICAvLyB0aGlzIGNvdWxkIGJlIGNvbW1vbiB3aGVuIGp1c3QgdGhyZWUgc2xpZGVzIGFyZSB1c2VkXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gZGVzdHJveSBwcmV2aW91cyBzbGlkZVxuXG5cbiAgICAgIGhvbGRlci5zbGlkZS5kZXN0cm95KCk7XG4gICAgICBob2xkZXIuc2xpZGUgPSB1bmRlZmluZWQ7XG4gICAgfSAvLyBleGl0IGlmIG5vIGxvb3AgYW5kIGluZGV4IGlzIG91dCBvZiBib3VuZHNcblxuXG4gICAgaWYgKCF0aGlzLmNhbkxvb3AoKSAmJiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMuZ2V0TnVtSXRlbXMoKSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBpdGVtRGF0YSA9IHRoaXMuZ2V0SXRlbURhdGEoaW5kZXgpO1xuICAgIGhvbGRlci5zbGlkZSA9IG5ldyBTbGlkZShpdGVtRGF0YSwgaW5kZXgsIHRoaXMpOyAvLyBzZXQgY3VycmVudCBzbGlkZVxuXG4gICAgaWYgKGluZGV4ID09PSB0aGlzLmN1cnJJbmRleCkge1xuICAgICAgdGhpcy5jdXJyU2xpZGUgPSBob2xkZXIuc2xpZGU7XG4gICAgfVxuXG4gICAgaG9sZGVyLnNsaWRlLmFwcGVuZChob2xkZXIuZWwpO1xuICB9XG4gIC8qKiBAcmV0dXJucyB7UG9pbnR9ICovXG5cblxuICBnZXRWaWV3cG9ydENlbnRlclBvaW50KCkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiB0aGlzLnZpZXdwb3J0U2l6ZS54IC8gMixcbiAgICAgIHk6IHRoaXMudmlld3BvcnRTaXplLnkgLyAyXG4gICAgfTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgc2l6ZSBvZiBhbGwgZWxlbWVudHMuXHJcbiAgICogRXhlY3V0ZWQgb24gaW5pdCBhbmQgb24gcGFnZSByZXNpemUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gVXBkYXRlIHNpemUgZXZlbiBpZiBzaXplIG9mIHZpZXdwb3J0IHdhcyBub3QgY2hhbmdlZC5cclxuICAgKi9cblxuXG4gIHVwZGF0ZVNpemUoZm9yY2UpIHtcbiAgICAvLyBsZXQgaXRlbTtcbiAgICAvLyBsZXQgaXRlbUluZGV4O1xuICAgIGlmICh0aGlzLmlzRGVzdHJveWluZykge1xuICAgICAgLy8gZXhpdCBpZiBQaG90b1N3aXBlIGlzIGNsb3NlZCBvciBjbG9zaW5nXG4gICAgICAvLyAodG8gYXZvaWQgZXJyb3JzLCBhcyByZXNpemUgZXZlbnQgbWlnaHQgYmUgZGVsYXllZClcbiAgICAgIHJldHVybjtcbiAgICB9IC8vY29uc3QgbmV3V2lkdGggPSB0aGlzLnNjcm9sbFdyYXAuY2xpZW50V2lkdGg7XG4gICAgLy9jb25zdCBuZXdIZWlnaHQgPSB0aGlzLnNjcm9sbFdyYXAuY2xpZW50SGVpZ2h0O1xuXG5cbiAgICBjb25zdCBuZXdWaWV3cG9ydFNpemUgPSBnZXRWaWV3cG9ydFNpemUodGhpcy5vcHRpb25zLCB0aGlzKTtcblxuICAgIGlmICghZm9yY2UgJiYgcG9pbnRzRXF1YWwobmV3Vmlld3BvcnRTaXplLCB0aGlzLl9wcmV2Vmlld3BvcnRTaXplKSkge1xuICAgICAgLy8gRXhpdCBpZiBkaW1lbnNpb25zIHdlcmUgbm90IGNoYW5nZWRcbiAgICAgIHJldHVybjtcbiAgICB9IC8vdGhpcy5fcHJldlZpZXdwb3J0U2l6ZS54ID0gbmV3V2lkdGg7XG4gICAgLy90aGlzLl9wcmV2Vmlld3BvcnRTaXplLnkgPSBuZXdIZWlnaHQ7XG5cblxuICAgIGVxdWFsaXplUG9pbnRzKHRoaXMuX3ByZXZWaWV3cG9ydFNpemUsIG5ld1ZpZXdwb3J0U2l6ZSk7XG4gICAgdGhpcy5kaXNwYXRjaCgnYmVmb3JlUmVzaXplJyk7XG4gICAgZXF1YWxpemVQb2ludHModGhpcy52aWV3cG9ydFNpemUsIHRoaXMuX3ByZXZWaWV3cG9ydFNpemUpO1xuXG4gICAgdGhpcy5fdXBkYXRlUGFnZVNjcm9sbE9mZnNldCgpO1xuXG4gICAgdGhpcy5kaXNwYXRjaCgndmlld3BvcnRTaXplJyk7IC8vIFJlc2l6ZSBzbGlkZXMgb25seSBhZnRlciBvcGVuZXIgYW5pbWF0aW9uIGlzIGZpbmlzaGVkXG4gICAgLy8gYW5kIGRvbid0IHJlLWNhbGN1bGF0ZSBzaXplIG9uIGluaXRhbCBzaXplIHVwZGF0ZVxuXG4gICAgdGhpcy5tYWluU2Nyb2xsLnJlc2l6ZSh0aGlzLm9wZW5lci5pc09wZW4pO1xuXG4gICAgaWYgKCF0aGlzLmhhc01vdXNlICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcoYW55LWhvdmVyOiBob3ZlciknKS5tYXRjaGVzKSB7XG4gICAgICB0aGlzLm1vdXNlRGV0ZWN0ZWQoKTtcbiAgICB9XG5cbiAgICB0aGlzLmRpc3BhdGNoKCdyZXNpemUnKTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0gb3BhY2l0eVxyXG4gICAqL1xuXG5cbiAgYXBwbHlCZ09wYWNpdHkob3BhY2l0eSkge1xuICAgIHRoaXMuYmdPcGFjaXR5ID0gTWF0aC5tYXgob3BhY2l0eSwgMCk7XG5cbiAgICBpZiAodGhpcy5iZykge1xuICAgICAgdGhpcy5iZy5zdHlsZS5vcGFjaXR5ID0gU3RyaW5nKHRoaXMuYmdPcGFjaXR5ICogdGhpcy5vcHRpb25zLmJnT3BhY2l0eSk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIFdoZXRoZXIgbW91c2UgaXMgZGV0ZWN0ZWRcclxuICAgKi9cblxuXG4gIG1vdXNlRGV0ZWN0ZWQoKSB7XG4gICAgaWYgKCF0aGlzLmhhc01vdXNlKSB7XG4gICAgICB2YXIgX3RoaXMkZWxlbWVudDI7XG5cbiAgICAgIHRoaXMuaGFzTW91c2UgPSB0cnVlO1xuICAgICAgKF90aGlzJGVsZW1lbnQyID0gdGhpcy5lbGVtZW50KSA9PT0gbnVsbCB8fCBfdGhpcyRlbGVtZW50MiA9PT0gdm9pZCAwIHx8IF90aGlzJGVsZW1lbnQyLmNsYXNzTGlzdC5hZGQoJ3Bzd3AtLWhhc19tb3VzZScpO1xuICAgIH1cbiAgfVxuICAvKipcclxuICAgKiBQYWdlIHJlc2l6ZSBldmVudCBoYW5kbGVyXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG5cbiAgX2hhbmRsZVBhZ2VSZXNpemUoKSB7XG4gICAgdGhpcy51cGRhdGVTaXplKCk7IC8vIEluIGlPUyB3ZWJ2aWV3LCBpZiBlbGVtZW50IHNpemUgZGVwZW5kcyBvbiBkb2N1bWVudCBzaXplLFxuICAgIC8vIGl0J2xsIGJlIG1lYXN1cmVkIGluY29ycmVjdGx5IGluIHJlc2l6ZSBldmVudFxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE3MDU5NVxuICAgIC8vIGh0dHBzOi8vaGFja2Vybm9vbi5jb20vb25yZXNpemUtZXZlbnQtYnJva2VuLWluLW1vYmlsZS1zYWZhcmktZDg0NjkwMjdiZjRkXG5cbiAgICBpZiAoL2lQaG9uZXxpUGFkfGlQb2QvaS50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6ZSgpO1xuICAgICAgfSwgNTAwKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUGFnZSBzY3JvbGwgb2Zmc2V0IGlzIHVzZWRcclxuICAgKiB0byBnZXQgY29ycmVjdCBjb29yZGluYXRlc1xyXG4gICAqIHJlbGF0aXZlIHRvIFBob3RvU3dpcGUgdmlld3BvcnQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xuXG5cbiAgX3VwZGF0ZVBhZ2VTY3JvbGxPZmZzZXQoKSB7XG4gICAgdGhpcy5zZXRTY3JvbGxPZmZzZXQoMCwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcbiAgfVxuICAvKipcclxuICAgKiBAcGFyYW0ge251bWJlcn0geFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XHJcbiAgICovXG5cblxuICBzZXRTY3JvbGxPZmZzZXQoeCwgeSkge1xuICAgIHRoaXMub2Zmc2V0LnggPSB4O1xuICAgIHRoaXMub2Zmc2V0LnkgPSB5O1xuICAgIHRoaXMuZGlzcGF0Y2goJ3VwZGF0ZVNjcm9sbE9mZnNldCcpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBtYWluIEhUTUwgc3RydWN0dXJlIG9mIFBob3RvU3dpcGUsXHJcbiAgICogYW5kIGFkZCBpdCB0byBET01cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXG5cblxuICBfY3JlYXRlTWFpblN0cnVjdHVyZSgpIHtcbiAgICAvLyByb290IERPTSBlbGVtZW50IG9mIFBob3RvU3dpcGUgKC5wc3dwKVxuICAgIHRoaXMuZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3AnLCAnZGl2Jyk7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpOyAvLyB0ZW1wbGF0ZSBpcyBsZWdhY3kgcHJvcFxuXG4gICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMuZWxlbWVudDsgLy8gQmFja2dyb3VuZCBpcyBhZGRlZCBhcyBhIHNlcGFyYXRlIGVsZW1lbnQsXG4gICAgLy8gYXMgYW5pbWF0aW5nIG9wYWNpdHkgaXMgZmFzdGVyIHRoYW4gYW5pbWF0aW5nIHJnYmEoKVxuXG4gICAgdGhpcy5iZyA9IGNyZWF0ZUVsZW1lbnQoJ3Bzd3BfX2JnJywgJ2RpdicsIHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5zY3JvbGxXcmFwID0gY3JlYXRlRWxlbWVudCgncHN3cF9fc2Nyb2xsLXdyYXAnLCAnc2VjdGlvbicsIHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIgPSBjcmVhdGVFbGVtZW50KCdwc3dwX19jb250YWluZXInLCAnZGl2JywgdGhpcy5zY3JvbGxXcmFwKTsgLy8gYXJpYSBwYXR0ZXJuOiBjYXJvdXNlbFxuXG4gICAgdGhpcy5zY3JvbGxXcmFwLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlZGVzY3JpcHRpb24nLCAnY2Fyb3VzZWwnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGl2ZScsICdvZmYnKTtcbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3Bzd3BfX2l0ZW1zJyk7XG4gICAgdGhpcy5tYWluU2Nyb2xsLmFwcGVuZEhvbGRlcnMoKTtcbiAgICB0aGlzLnVpID0gbmV3IFVJKHRoaXMpO1xuICAgIHRoaXMudWkuaW5pdCgpOyAvLyBhcHBlbmQgdG8gRE9NXG5cbiAgICAodGhpcy5vcHRpb25zLmFwcGVuZFRvRWwgfHwgZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQodGhpcy5lbGVtZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBHZXQgcG9zaXRpb24gYW5kIGRpbWVuc2lvbnMgb2Ygc21hbGwgdGh1bWJuYWlsXHJcbiAgICogICB7eDoseTosdzp9XHJcbiAgICpcclxuICAgKiBIZWlnaHQgaXMgb3B0aW9uYWwgKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGxhcmdlIGltYWdlKVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0JvdW5kcyB8IHVuZGVmaW5lZH1cclxuICAgKi9cblxuXG4gIGdldFRodW1iQm91bmRzKCkge1xuICAgIHJldHVybiBnZXRUaHVtYkJvdW5kcyh0aGlzLmN1cnJJbmRleCwgdGhpcy5jdXJyU2xpZGUgPyB0aGlzLmN1cnJTbGlkZS5kYXRhIDogdGhpcy5faW5pdGlhbEl0ZW1EYXRhLCB0aGlzKTtcbiAgfVxuICAvKipcclxuICAgKiBJZiB0aGUgUGhvdG9Td2lwZSBjYW4gaGF2ZSBjb250aW51b3VzIGxvb3BcclxuICAgKiBAcmV0dXJucyBCb29sZWFuXHJcbiAgICovXG5cblxuICBjYW5Mb29wKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMubG9vcCAmJiB0aGlzLmdldE51bUl0ZW1zKCkgPiAyO1xuICB9XG4gIC8qKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICogQHBhcmFtIHtQaG90b1N3aXBlT3B0aW9uc30gb3B0aW9uc1xyXG4gICAqIEByZXR1cm5zIHtQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zfVxyXG4gICAqL1xuXG5cbiAgX3ByZXBhcmVPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLXJlZHVjZWQtbW90aW9uKSwgKHVwZGF0ZTogc2xvdyknKS5tYXRjaGVzKSB7XG4gICAgICBvcHRpb25zLnNob3dIaWRlQW5pbWF0aW9uVHlwZSA9ICdub25lJztcbiAgICAgIG9wdGlvbnMuem9vbUFuaW1hdGlvbkR1cmF0aW9uID0gMDtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtQcmVwYXJlZFBob3RvU3dpcGVPcHRpb25zfSAqL1xuXG5cbiAgICByZXR1cm4geyAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuICB9XG5cbn1cblxuZXhwb3J0IHsgUGhvdG9Td2lwZSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waG90b3N3aXBlLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/.pnpm/photoswipe@5.4.4/node_modules/photoswipe/dist/photoswipe.esm.js\n"));

/***/ })

}]);