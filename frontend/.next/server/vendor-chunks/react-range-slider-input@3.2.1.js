"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-range-slider-input@3.2.1";
exports.ids = ["vendor-chunks/react-range-slider-input@3.2.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/components/RangeSlider.js":
/*!********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/components/RangeSlider.js ***!
  \********************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\n__webpack_require__(/*! core-js/modules/es.weak-map.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/es.weak-map.js\");\n__webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/web.dom-collections.iterator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n__webpack_require__(/*! core-js/modules/es.array.sort.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/es.array.sort.js\");\n__webpack_require__(/*! core-js/modules/es.parse-float.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/es.parse-float.js\");\n__webpack_require__(/*! core-js/modules/esnext.iterator.constructor.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/esnext.iterator.constructor.js\");\n__webpack_require__(/*! core-js/modules/esnext.iterator.for-each.js */ \"(ssr)/./node_modules/.pnpm/core-js@3.41.0/node_modules/core-js/modules/esnext.iterator.for-each.js\");\nvar _react = _interopRequireWildcard(__webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.1.6_react-dom@19.0.0_react@19.0.0_sass@1.85.1/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\"));\nvar _clsx = _interopRequireDefault(__webpack_require__(/*! clsx */ \"(ssr)/./node_modules/.pnpm/clsx@1.2.1/node_modules/clsx/dist/clsx.m.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nfunction _getRequireWildcardCache(e) { if (\"function\" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }\nfunction _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || \"object\" != typeof e && \"function\" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if (\"default\" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }\n// Aliases\nconst abs = Math.abs;\nconst float = parseFloat;\n\n// Values\nconst MIN = 'min';\nconst MAX = 'max';\nconst ANY = 'any';\nconst VERTICAL = 'vertical';\nconst TABINDEX = 'tabindex';\n\n// Data Attributes\nconst DATA_LOWER = 'data-lower';\nconst DATA_UPPER = 'data-upper';\nconst DATA_ACTIVE = 'data-active';\nconst DATA_VERTICAL = 'data-vertical';\nconst DATA_DISABLED = 'data-disabled';\n\n// ARIA Attributes\nconst ARIA_LABEL = 'aria-label';\nconst ARIA_LABELLEDBY = 'aria-labelledby';\nclass RangeSlider extends _react.PureComponent {\n  constructor() {\n    super();\n    this.element = /*#__PURE__*/(0, _react.createRef)();\n    this.input = [];\n    this.thumb = [/*#__PURE__*/(0, _react.createRef)(), /*#__PURE__*/(0, _react.createRef)()];\n    this.range = /*#__PURE__*/(0, _react.createRef)();\n    this.options = {};\n    this.isControlled = false;\n    this.externalInput = false;\n    this.isComponentMounted = false;\n    this.lastValueProp = [];\n  }\n  initiateInputRange(index) {\n    const inputElement = document.createElement('input');\n    inputElement.type = 'range';\n    inputElement.min = this.options.min;\n    inputElement.max = this.options.max;\n    inputElement.step = this.options.step;\n    inputElement.value = this.props.value ? this.options.value[index] : this.options.defaultValue[index];\n    return inputElement;\n  }\n  updateInputRange(index) {\n    this.input[index].min = this.options.min;\n    this.input[index].max = this.options.max;\n    this.input[index].step = this.options.step;\n    this.input[index].value = this.props.value ? this.options.value[index] : index === 1 ? this.value.max : this.value.min;\n  }\n  componentDidMount() {\n    if (!this.isComponentMounted) {\n      // input[type=\"range\"] elements for syncing values\n      this.input = [this.initiateInputRange(0), this.initiateInputRange(1)];\n      this.value = this.setMinMaxProps();\n\n      // Thumb indexes for min and max values\n      // (swapped when the thumbs cross each other)\n      this.index = this.setMinMaxProps(0, 1);\n\n      // Thumb width & height for calculation of exact positions and sizes of horizontal thumbs and range\n      this.thumbWidth = this.setMinMaxProps();\n      this.thumbHeight = this.setMinMaxProps();\n\n      // Slidable range limits (when a thumb is dragged)\n      this.rangeLimits = this.setMinMaxProps();\n\n      // Slider value depending on the user interaction\n      this.sliderValue = this.setMinMaxProps();\n\n      // For dragging thumbs and range\n      this.maxRangeWidth = 0;\n      this.rangeWidth = 0;\n      this.isDragging = false;\n      this.thumbDrag = false;\n      this.startPos = 0;\n\n      // initial\n      this.reset(true);\n\n      // Add listeners to element\n      this.addNodeEventListener(this.element.current, 'pointerdown', e => {\n        this.elementFocused(e);\n      });\n\n      // Add listeners to thumbs and set [data-disabled] on disabled thumbs\n      this.thumb.forEach((t, i) => {\n        this.addNodeEventListener(t.current, 'pointerdown', e => {\n          this.initiateThumbDrag(e, i, t.current);\n        });\n        this.addNodeEventListener(t.current, 'keydown', e => {\n          if (e.which >= 37 && e.which <= 40) {\n            e.preventDefault();\n            this.stepValue(i, e.which);\n          }\n        });\n      });\n\n      // Add listeners to range\n      this.addNodeEventListener(this.range.current, 'pointerdown', e => {\n        this.initiateRangeDrag(e);\n      });\n\n      // Define and add global listeners\n      this.pointerMoveEvent = e => {\n        this.drag(e);\n      };\n      this.pointerUpEvent = () => {\n        if (this.isDragging) {\n          this.removeNodeAttribute(this.thumb[0].current, DATA_ACTIVE);\n          this.removeNodeAttribute(this.thumb[1].current, DATA_ACTIVE);\n          this.removeNodeAttribute(this.range.current, DATA_ACTIVE);\n          this.isDragging = false;\n          if (this.thumbDrag) {\n            if (this.options.onThumbDragEnd) {\n              this.options.onThumbDragEnd();\n            }\n          } else {\n            if (this.options.onRangeDragEnd) {\n              this.options.onRangeDragEnd();\n            }\n          }\n        }\n      };\n      this.resizeEvent = () => {\n        this.syncThumbDimensions();\n        this.updateThumbs();\n        this.updateRange();\n      };\n      this.addNodeEventListener(document, 'pointermove', this.pointerMoveEvent);\n      this.addNodeEventListener(document, 'pointerup', this.pointerUpEvent);\n      this.addNodeEventListener(window, 'resize', this.resizeEvent);\n      this.isComponentMounted = true;\n    }\n  }\n  componentDidUpdate() {\n    this.updateInputRange(0);\n    this.updateInputRange(1);\n    this.reset();\n  }\n  componentWillUnmount() {\n    // Remove global listeners\n    this.removeNodeEventListener(document, 'pointermove', this.pointerMoveEvent);\n    this.removeNodeEventListener(document, 'pointerup', this.pointerUpEvent);\n    this.removeNodeEventListener(window, 'resize', this.resizeEvent);\n    this.isComponentMounted = false;\n  }\n  reset() {\n    let first = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.isControlled = !!this.props.value;\n    if (this.isControlled) {\n      if (first || this.props.value !== this.lastValueProp) {\n        this.externalInput = true;\n      }\n      this.lastValueProp = this.props.value;\n    }\n    this.maxRangeWidth = this.options.max - this.options.min;\n    this.updateOrientation();\n    this.setValue('', true, false);\n    this.updateRangeLimits();\n    this.updateDisabledState();\n    this.updateThumbsDisabledState();\n    this.updateTabIndexes();\n    if (first) {\n      this.sliderValue = this.value;\n    }\n  }\n  isNumber(n) {\n    // check for NaN explicitly\n    // because with NaN, the second exp. evaluates to true\n    return !isNaN(n) && +n + '' === n + '';\n  }\n  setMinMaxProps() {\n    let min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return {\n      min,\n      max\n    };\n  }\n  iterateMinMaxProps(fn) {\n    [MIN, MAX].forEach(fn);\n  }\n  getSetProps(condition, expression, fn) {\n    if (condition) {\n      return expression;\n    } else {\n      fn();\n    }\n  }\n  setNodeAttribute(node, attribute) {\n    let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n    node.setAttribute(attribute, value);\n  }\n  removeNodeAttribute(node, attribute) {\n    node.removeAttribute(attribute);\n  }\n  addNodeEventListener(node, event, fn) {\n    let isPointerEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    // with options for pointer events\n    node.addEventListener(event, fn, isPointerEvent ? {\n      passive: false,\n      capture: true\n    } : {});\n  }\n  removeNodeEventListener(node, event, fn) {\n    let isPointerEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    // with options for pointer events\n    node.removeEventListener(event, fn, isPointerEvent ? {\n      passive: false,\n      capture: true\n    } : {});\n  }\n  fallbackToDefault(property, defaultValue) {\n    this.options[property] = this.props[property] ? this.props[property] : defaultValue;\n  }\n  ifVerticalElse(vertical, horizontal) {\n    return this.options.orientation === VERTICAL ? vertical : horizontal;\n  }\n  currentIndex(i) {\n    return i === 1 ? this.index.max : this.index.min;\n  }\n\n  // Set min and max values to 1 (arbitrarily) if any of the min or max values are \"invalid\"\n  // Setting both values 1 will disable the slider\n  // Called when,\n  // -> the element is initially set\n  // -> min or max properties are modified\n  safeMinMaxValues() {\n    let error = false;\n    if (!this.isNumber(this.options.min) || !this.isNumber(this.options.max)) {\n      error = true;\n    }\n    this.options.min = error ? 1 : +this.options.min;\n    this.options.max = error ? 1 : +this.options.max;\n  }\n\n  // Reframe the thumbsDisabled value if \"invalid\"\n  // Called when,\n  // -> the element is initially set\n  // -> thumbsDisabled property is modified\n  safeThumbsDisabledValues() {\n    if (this.options.thumbsDisabled instanceof Array) {\n      if (this.options.thumbsDisabled.length === 1) {\n        this.options.thumbsDisabled.push(false);\n      }\n      if (this.options.thumbsDisabled.length !== 1 && this.options.thumbsDisabled.length !== 2) {\n        this.options.thumbsDisabled = [false, false];\n      }\n    } else {\n      this.options.thumbsDisabled = [this.options.thumbsDisabled, this.options.thumbsDisabled];\n    }\n\n    // Boolean Values\n    this.options.thumbsDisabled[0] = !!this.options.thumbsDisabled[0];\n    this.options.thumbsDisabled[1] = !!this.options.thumbsDisabled[1];\n  }\n\n  // Called when,\n  // -> the element is initially set\n  // -> min, max, step or value properties are modified\n  // -> thumbs are dragged\n  // -> element is clicked upon\n  // -> an arrow key is pressed\n  setValue(newValue) {\n    let forceSet = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    let callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n    // Current value as set in the input elements\n    // which could change while changing min, max and step values\n    const currentValue = this.setMinMaxProps(this.input[0].value, this.input[1].value);\n\n    // var value is synced with the values set in the input elements if no newValue is passed\n    newValue = newValue || currentValue;\n    this.input[this.index.min].value = newValue.min;\n    this.input[this.index.max].value = this.thumbDrag || forceSet ? newValue.max : newValue.min + this.rangeWidth;\n    this.syncValues();\n\n    // Check if the thumbs cross each other\n    if (this.value.min > this.value.max) {\n      var _this$props, _this$props2, _this$props3, _this$props4;\n      // Switch thumb indexes\n      this.index.min = +!this.index.min;\n      this.index.max = +!this.index.max;\n\n      // Switch thumb attributes\n      this.removeNodeAttribute(this.thumb[this.index.min].current, DATA_UPPER);\n      this.removeNodeAttribute(this.thumb[this.index.max].current, DATA_LOWER);\n      this.setNodeAttribute(this.thumb[this.index.min].current, DATA_LOWER);\n      this.setNodeAttribute(this.thumb[this.index.max].current, DATA_UPPER);\n      this.setNodeAttribute(this.thumb[this.index.min].current, ARIA_LABEL, (_this$props = this.props) === null || _this$props === void 0 || (_this$props = _this$props.ariaLabel) === null || _this$props === void 0 ? void 0 : _this$props[0]);\n      this.setNodeAttribute(this.thumb[this.index.max].current, ARIA_LABEL, (_this$props2 = this.props) === null || _this$props2 === void 0 || (_this$props2 = _this$props2.ariaLabel) === null || _this$props2 === void 0 ? void 0 : _this$props2[1]);\n      this.setNodeAttribute(this.thumb[this.index.min].current, ARIA_LABELLEDBY, (_this$props3 = this.props) === null || _this$props3 === void 0 || (_this$props3 = _this$props3.ariaLabelledBy) === null || _this$props3 === void 0 ? void 0 : _this$props3[0]);\n      this.setNodeAttribute(this.thumb[this.index.max].current, ARIA_LABELLEDBY, (_this$props4 = this.props) === null || _this$props4 === void 0 || (_this$props4 = _this$props4.ariaLabelledBy) === null || _this$props4 === void 0 ? void 0 : _this$props4[1]);\n\n      // Switch thumb drag labels\n      if (this.thumbDrag) {\n        this.thumbDrag = this.thumbDrag === MIN ? MAX : MIN;\n      }\n      this.syncValues();\n    }\n    this.sliderValue = forceSet ? this.sliderValue : newValue;\n    let valueSet = false;\n    const currentValues = [currentValue.min, currentValue.max].sort((a, b) => a - b);\n    const elementValues = [this.input[0].value, this.input[1].value].sort((a, b) => a - b);\n    if (currentValues[0] !== elementValues[0] || forceSet) {\n      valueSet = true;\n    }\n    if (currentValues[1] !== elementValues[1] || forceSet) {\n      valueSet = true;\n    }\n\n    // Update the positions, dimensions and aria attributes everytime a value is set\n    // and call the onInput function from options (if set)\n    if (valueSet) {\n      if (callback && this.options.onInput) {\n        this.options.onInput([this.value.min, this.value.max]);\n      }\n      if (!this.isControlled || this.externalInput) {\n        this.externalInput = false;\n        this.syncThumbDimensions();\n        this.updateThumbs();\n        this.updateRange();\n        this.updateAriaValueAttributes();\n      }\n    }\n  }\n\n  // Sync var value with the input elements\n  syncValues() {\n    this.iterateMinMaxProps(_ => {\n      this.value[_] = +this.input[this.index[_]].value;\n    });\n  }\n\n  // Called when,\n  // -> setValue is called and a value is set\n  // -> window is resized\n  updateThumbs() {\n    this.iterateMinMaxProps(_ => {\n      this.thumb[this.index[_]].current.style[this.ifVerticalElse('top', 'left')] = \"calc(\".concat((this.value[_] - this.options.min) / this.maxRangeWidth * 100, \"% + \").concat((0.5 - (this.value[_] - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth)[_], \"px)\");\n    });\n  }\n\n  // Called when,\n  // -> setValue is called and a value is set\n  // -> window is resized\n  updateRange() {\n    const elementBounds = this.element.current.getBoundingClientRect();\n    const deltaOffset = (0.5 - (this.value.min - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth).min / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left);\n    const deltaDimension = (0.5 - (this.value.max - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth).max / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left);\n    this.range.current.style[this.ifVerticalElse('top', 'left')] = \"\".concat(((this.value.min - this.options.min) / this.maxRangeWidth + deltaOffset) * 100, \"%\");\n    this.range.current.style[this.ifVerticalElse('height', 'width')] = \"\".concat(((this.value.max - this.options.min) / this.maxRangeWidth - (this.value.min - this.options.min) / this.maxRangeWidth - deltaOffset + deltaDimension) * 100, \"%\");\n  }\n  updateRangeLimits() {\n    this.iterateMinMaxProps((_, i) => {\n      this.rangeLimits[_] = this.options.thumbsDisabled[i] ? this.value[_] : this.options[_];\n    });\n  }\n\n  // Called when,\n  // -> thumbs are initially set\n  // -> thumbs are disabled / enabled\n  updateTabIndexes() {\n    this.iterateMinMaxProps((_, i) => {\n      if (!this.options.disabled && !this.options.thumbsDisabled[i]) {\n        this.setNodeAttribute(this.thumb[this.currentIndex(i)].current, TABINDEX, 0);\n      } else {\n        this.removeNodeAttribute(this.thumb[this.currentIndex(i)].current, TABINDEX);\n      }\n    });\n  }\n\n  // Called when,\n  // -> setValue is called and a value is set\n  updateAriaValueAttributes() {\n    this.iterateMinMaxProps(_ => {\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuemin', this.options.min);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuemax', this.options.max);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuenow', this.value[_]);\n      this.setNodeAttribute(this.thumb[this.index[_]].current, 'aria-valuetext', this.value[_]);\n    });\n  }\n\n  // Called when,\n  // -> disabled property is modified\n  updateDisabledState() {\n    if (this.options.disabled) {\n      this.setNodeAttribute(this.element.current, DATA_DISABLED);\n    } else {\n      this.removeNodeAttribute(this.element.current, DATA_DISABLED);\n    }\n  }\n\n  // Called when,\n  // -> thumbsDisabled property is modified\n  updateThumbsDisabledState() {\n    this.options.thumbsDisabled.forEach((d, i) => {\n      const currIndex = this.currentIndex(i);\n      if (d) {\n        this.setNodeAttribute(this.thumb[currIndex].current, DATA_DISABLED);\n        this.setNodeAttribute(this.thumb[currIndex].current, 'aria-disabled', true);\n      } else {\n        this.removeNodeAttribute(this.thumb[currIndex].current, DATA_DISABLED);\n        this.setNodeAttribute(this.thumb[currIndex].current, 'aria-disabled', false);\n      }\n    });\n  }\n\n  // Called when,\n  // -> min or max values are modified\n  updateLimits(limit) {\n    let m = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    this.options[limit] = m;\n    this.safeMinMaxValues();\n    this.iterateMinMaxProps(_ => {\n      this.input[0][_] = this.options[_];\n      this.input[1][_] = this.options[_];\n    });\n    this.maxRangeWidth = this.options.max - this.options.min;\n    this.setValue('', true);\n    this.updateRangeLimits();\n  }\n\n  // Called when,\n  // -> the element is initially set\n  // -> orientation property is modified\n  updateOrientation() {\n    if (this.options.orientation === VERTICAL) {\n      this.setNodeAttribute(this.element.current, DATA_VERTICAL);\n    } else {\n      this.removeNodeAttribute(this.element.current, DATA_VERTICAL);\n    }\n    this.range.current.style[this.ifVerticalElse('left', 'top')] = '';\n    this.range.current.style[this.ifVerticalElse('width', 'height')] = '';\n    this.thumb[0].current.style[this.ifVerticalElse('left', 'top')] = '';\n    this.thumb[1].current.style[this.ifVerticalElse('left', 'top')] = '';\n  }\n\n  // thumb width & height values are to be synced with the CSS values for correct calculation of\n  // thumb position and range width & position\n  // Called when,\n  // -> setValue is called and a value is set (called before updateThumbs() and updateRange())\n  // -> thumb / range drag is initiated\n  // -> window is resized\n  syncThumbDimensions() {\n    this.iterateMinMaxProps(_ => {\n      this.thumbWidth[_] = float(window.getComputedStyle(this.thumb[this.index[_]].current).width);\n      this.thumbHeight[_] = float(window.getComputedStyle(this.thumb[this.index[_]].current).height);\n    });\n  }\n\n  // thumb position calculation depending upon the pointer position\n  currentPosition(e, node) {\n    const elementBounds = this.element.current.getBoundingClientRect();\n    const nodeBounds = node.getBoundingClientRect();\n    const currPos = (this.ifVerticalElse(nodeBounds.top - elementBounds.top, nodeBounds.left - elementBounds.left) + (e[\"client\".concat(this.ifVerticalElse('Y', 'X'))] - node.getBoundingClientRect()[this.ifVerticalElse('top', 'left')]) - (this.thumbDrag ? (0.5 - (this.value[this.thumbDrag] - this.options.min) / this.maxRangeWidth) * this.ifVerticalElse(this.thumbHeight, this.thumbWidth)[this.thumbDrag] : 0)) / this.ifVerticalElse(elementBounds.bottom - elementBounds.top, elementBounds.right - elementBounds.left) * this.maxRangeWidth + this.options.min;\n    if (currPos < this.options.min) {\n      return this.options.min;\n    }\n    if (currPos > this.options.max) {\n      return this.options.max;\n    }\n    return currPos;\n  }\n  doesntHaveClassName(e, className) {\n    return !e.target.classList.contains(className);\n  }\n  elementFocused(e) {\n    let repeat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    let setFocus = false;\n    if (!this.options.disabled && (this.doesntHaveClassName(e, 'range-slider__thumb') && this.doesntHaveClassName(e, 'range-slider__range') || this.options.rangeSlideDisabled && this.doesntHaveClassName(e, 'range-slider__thumb'))) {\n      setFocus = true;\n    }\n\n    // No action if both thumbs are disabled\n    if (setFocus && this.options.thumbsDisabled[0] && this.options.thumbsDisabled[1]) {\n      setFocus = false;\n    }\n    if (setFocus) {\n      const currPos = this.currentPosition(e, this.range.current);\n      const deltaMin = abs(this.value.min - currPos);\n      const deltaMax = abs(this.value.max - currPos);\n      if (this.options.thumbsDisabled[0]) {\n        if (currPos >= this.value.min) {\n          this.setValue(this.setMinMaxProps(this.value.min, currPos), true, !repeat);\n          this.initiateThumbDrag(e, this.index.max, this.thumb[this.index.max].current, !repeat);\n        }\n      } else if (this.options.thumbsDisabled[1]) {\n        if (currPos <= this.value.max) {\n          this.setValue(this.setMinMaxProps(currPos, this.value.max), true, !repeat);\n          this.initiateThumbDrag(e, this.index.min, this.thumb[this.index.min].current, !repeat);\n        }\n      } else {\n        let nearestThumbIndex = this.index.max;\n        if (deltaMin === deltaMax) {\n          this.setValue(this.setMinMaxProps(this.value.min, currPos), true, !repeat);\n        } else {\n          this.setValue(this.setMinMaxProps(deltaMin < deltaMax ? currPos : this.value.min, deltaMax < deltaMin ? currPos : this.value.max), true, !repeat);\n          nearestThumbIndex = deltaMin < deltaMax ? this.index.min : this.index.max;\n        }\n        this.initiateThumbDrag(e, nearestThumbIndex, this.thumb[nearestThumbIndex].current, !repeat);\n      }\n      if (repeat) {\n        this.elementFocused(e, false);\n      }\n    }\n  }\n  initiateDrag(e, node) {\n    this.syncThumbDimensions();\n    this.setNodeAttribute(node, DATA_ACTIVE);\n    this.startPos = this.currentPosition(e, node);\n    this.isDragging = true;\n  }\n  initiateThumbDrag(e, i, node) {\n    let callback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n    if (!this.options.disabled && !this.options.thumbsDisabled[this.currentIndex(i)]) {\n      this.initiateDrag(e, node);\n      this.thumbDrag = this.index.min === i ? MIN : MAX;\n      if (callback && this.options.onThumbDragStart) {\n        this.options.onThumbDragStart();\n      }\n    }\n  }\n  initiateRangeDrag(e) {\n    if (!this.options.disabled && !this.options.rangeSlideDisabled) {\n      this.initiateDrag(e, this.range.current);\n      this.rangeWidth = this.value.max - this.value.min;\n      this.thumbDrag = false;\n      if (this.options.onRangeDragStart) {\n        this.options.onRangeDragStart();\n      }\n    }\n  }\n  drag(e) {\n    if (this.isDragging) {\n      const lastPos = this.currentPosition(e, this.range.current);\n      const delta = lastPos - this.startPos;\n      let min = this.value.min;\n      let max = this.value.max;\n      const lower = this.thumbDrag ? this.rangeLimits.min : this.options.min;\n      const upper = this.thumbDrag ? this.rangeLimits.max : this.options.max;\n      if (!this.thumbDrag || this.thumbDrag === MIN) {\n        min = this.thumbDrag ? lastPos : this.sliderValue.min + delta;\n      }\n      if (!this.thumbDrag || this.thumbDrag === MAX) {\n        max = this.thumbDrag ? lastPos : this.sliderValue.max + delta;\n      }\n      if (min >= lower && min <= upper && max >= lower && max <= upper) {\n        this.setValue({\n          min,\n          max\n        });\n        this.startPos = lastPos;\n      } else {\n        // When min thumb reaches upper limit\n        if (min > upper && this.thumbDrag) {\n          this.setValue(this.setMinMaxProps(upper, upper));\n          this.startPos = lastPos;\n        }\n        // When max thumb reaches lower limit\n        if (max < lower && this.thumbDrag) {\n          this.setValue(this.setMinMaxProps(lower, lower));\n          this.startPos = lastPos;\n        }\n        // When range / min thumb reaches lower limit\n        if (min < lower) {\n          if (!this.thumbDrag) {\n            this.setValue(this.setMinMaxProps(lower, this.value.max - this.value.min + lower));\n          } else {\n            this.setValue(this.setMinMaxProps(lower, this.value.max));\n          }\n          this.startPos = lastPos;\n        }\n        // When range / max thumb reaches upper limit\n        if (max > upper) {\n          if (!this.thumbDrag) {\n            this.setValue(this.setMinMaxProps(this.value.min - this.value.max + upper, upper));\n          } else {\n            this.setValue(this.setMinMaxProps(this.value.min, upper));\n          }\n          this.startPos = lastPos;\n        }\n      }\n      if (!this.thumbDrag) {\n        this.updateRangeLimits();\n      }\n    }\n  }\n  actualStepValue() {\n    const step = float(this.input[0].step);\n    return this.input[0].step === ANY ? ANY : step === 0 || isNaN(step) ? 1 : step;\n  }\n\n  // Step value (up or down) using arrow keys\n  stepValue(i, key) {\n    const direction = (key === 37 || key === 40 ? -1 : 1) * this.ifVerticalElse(-1, 1);\n    if (!this.options.disabled && !this.options.thumbsDisabled[this.currentIndex(i)]) {\n      let step = this.actualStepValue();\n      step = step === ANY ? 1 : step;\n      let min = this.value.min + step * (this.index.min === i ? direction : 0);\n      let max = this.value.max + step * (this.index.max === i ? direction : 0);\n\n      // When min thumb reaches upper limit\n      if (min > this.rangeLimits.max) {\n        min = this.rangeLimits.max;\n      }\n\n      // When max thumb reaches lower limit\n      if (max < this.rangeLimits.min) {\n        max = this.rangeLimits.min;\n      }\n      this.setValue({\n        min,\n        max\n      }, true);\n    }\n  }\n  render() {\n    var _this$props5, _this$props6, _this$props7, _this$props8;\n    // Set options to default values if not set\n    this.fallbackToDefault('rangeSlideDisabled', false);\n    this.fallbackToDefault('thumbsDisabled', [false, false]);\n    this.fallbackToDefault('orientation', 'horizontal');\n    this.fallbackToDefault('defaultValue', [25, 75]);\n    this.fallbackToDefault('disabled', false);\n    this.fallbackToDefault('onThumbDragStart', false);\n    this.fallbackToDefault('onRangeDragStart', false);\n    this.fallbackToDefault('onThumbDragEnd', false);\n    this.fallbackToDefault('onRangeDragEnd', false);\n    this.fallbackToDefault('onInput', false);\n    this.fallbackToDefault('step', 1);\n    this.fallbackToDefault('min', 0);\n    this.fallbackToDefault('max', 100);\n    if (this.props.value) {\n      this.fallbackToDefault('value', [25, 75]);\n    }\n    this.safeMinMaxValues();\n    this.safeThumbsDisabledValues();\n    return /*#__PURE__*/_react.default.createElement(\"div\", {\n      \"data-testid\": \"element\",\n      id: this.props.id,\n      ref: this.element,\n      className: (0, _clsx.default)('range-slider', this.props.className)\n    }, /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.thumb[0],\n      role: \"slider\",\n      className: \"range-slider__thumb\",\n      \"data-lower\": true,\n      \"aria-label\": (_this$props5 = this.props) === null || _this$props5 === void 0 || (_this$props5 = _this$props5.ariaLabel) === null || _this$props5 === void 0 ? void 0 : _this$props5[0],\n      \"aria-labelledby\": (_this$props6 = this.props) === null || _this$props6 === void 0 || (_this$props6 = _this$props6.ariaLabelledBy) === null || _this$props6 === void 0 ? void 0 : _this$props6[0]\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.thumb[1],\n      role: \"slider\",\n      className: \"range-slider__thumb\",\n      \"data-upper\": true,\n      \"aria-label\": (_this$props7 = this.props) === null || _this$props7 === void 0 || (_this$props7 = _this$props7.ariaLabel) === null || _this$props7 === void 0 ? void 0 : _this$props7[1],\n      \"aria-labelledby\": (_this$props8 = this.props) === null || _this$props8 === void 0 || (_this$props8 = _this$props8.ariaLabelledBy) === null || _this$props8 === void 0 ? void 0 : _this$props8[1]\n    }), /*#__PURE__*/_react.default.createElement(\"div\", {\n      ref: this.range,\n      className: \"range-slider__range\"\n    }));\n  }\n}\n;\nvar _default = exports[\"default\"] = RangeSlider;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0QDMuMi4xL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXQvZGlzdC9jb21wb25lbnRzL1JhbmdlU2xpZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLG1CQUFPLENBQUMsNkhBQWdDO0FBQ3hDLG1CQUFPLENBQUMsK0pBQWlEO0FBQ3pELDhDQUE2QztBQUM3QztBQUNBLENBQUMsRUFBQztBQUNGLGtCQUFlO0FBQ2YsbUJBQU8sQ0FBQyxpSUFBa0M7QUFDMUMsbUJBQU8sQ0FBQyxtSUFBbUM7QUFDM0MsbUJBQU8sQ0FBQyw2SkFBZ0Q7QUFDeEQsbUJBQU8sQ0FBQyx1SkFBNkM7QUFDckQscUNBQXFDLG1CQUFPLENBQUMsMEtBQU87QUFDcEQsbUNBQW1DLG1CQUFPLENBQUMsb0ZBQU07QUFDakQscUNBQXFDLGlDQUFpQztBQUN0RSx1Q0FBdUMsK0NBQStDLDBDQUEwQywwRUFBMEUsbUJBQW1CO0FBQzdOLHlDQUF5Qyx1Q0FBdUMsMkVBQTJFLGNBQWMscUNBQXFDLG9DQUFvQyxVQUFVLGlCQUFpQixnRUFBZ0UsMENBQTBDLDhCQUE4QiwwREFBMEQsd0VBQXdFO0FBQ3ZoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQUk7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sSUFBSTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsa0JBQWUiLCJzb3VyY2VzIjpbIi9wcm9qZWN0cy9yZzM2MC9uZXctZWNvbW1lcmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXRAMy4yLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlLXNsaWRlci1pbnB1dC9kaXN0L2NvbXBvbmVudHMvUmFuZ2VTbGlkZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5cbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanNcIik7XG5yZXF1aXJlKFwiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzXCIpO1xucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lcy5wYXJzZS1mbG9hdC5qc1wiKTtcbnJlcXVpcmUoXCJjb3JlLWpzL21vZHVsZXMvZXNuZXh0Lml0ZXJhdG9yLmNvbnN0cnVjdG9yLmpzXCIpO1xucmVxdWlyZShcImNvcmUtanMvbW9kdWxlcy9lc25leHQuaXRlcmF0b3IuZm9yLWVhY2guanNcIik7XG52YXIgX3JlYWN0ID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQocmVxdWlyZShcInJlYWN0XCIpKTtcbnZhciBfY2xzeCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcImNsc3hcIikpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7IHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7IGRlZmF1bHQ6IGUgfTsgfVxuZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgV2Vha01hcCkgcmV0dXJuIG51bGw7IHZhciByID0gbmV3IFdlYWtNYXAoKSwgdCA9IG5ldyBXZWFrTWFwKCk7IHJldHVybiAoX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlID0gZnVuY3Rpb24gX2dldFJlcXVpcmVXaWxkY2FyZENhY2hlKGUpIHsgcmV0dXJuIGUgPyB0IDogcjsgfSkoZSk7IH1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHIpIHsgaWYgKCFyICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTsgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSB0eXBlb2YgZSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiB7IGRlZmF1bHQ6IGUgfTsgdmFyIHQgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUocik7IGlmICh0ICYmIHQuaGFzKGUpKSByZXR1cm4gdC5nZXQoZSk7IHZhciBuID0geyBfX3Byb3RvX186IG51bGwgfSwgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOyBmb3IgKHZhciB1IGluIGUpIGlmIChcImRlZmF1bHRcIiAhPT0gdSAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIHUpKSB7IHZhciBpID0gYSA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgdSkgOiBudWxsOyBpICYmIChpLmdldCB8fCBpLnNldCkgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgdSwgaSkgOiBuW3VdID0gZVt1XTsgfSByZXR1cm4gbi5kZWZhdWx0ID0gZSwgdCAmJiB0LnNldChlLCBuKSwgbjsgfVxuLy8gQWxpYXNlc1xuY29uc3QgYWJzID0gTWF0aC5hYnM7XG5jb25zdCBmbG9hdCA9IHBhcnNlRmxvYXQ7XG5cbi8vIFZhbHVlc1xuY29uc3QgTUlOID0gJ21pbic7XG5jb25zdCBNQVggPSAnbWF4JztcbmNvbnN0IEFOWSA9ICdhbnknO1xuY29uc3QgVkVSVElDQUwgPSAndmVydGljYWwnO1xuY29uc3QgVEFCSU5ERVggPSAndGFiaW5kZXgnO1xuXG4vLyBEYXRhIEF0dHJpYnV0ZXNcbmNvbnN0IERBVEFfTE9XRVIgPSAnZGF0YS1sb3dlcic7XG5jb25zdCBEQVRBX1VQUEVSID0gJ2RhdGEtdXBwZXInO1xuY29uc3QgREFUQV9BQ1RJVkUgPSAnZGF0YS1hY3RpdmUnO1xuY29uc3QgREFUQV9WRVJUSUNBTCA9ICdkYXRhLXZlcnRpY2FsJztcbmNvbnN0IERBVEFfRElTQUJMRUQgPSAnZGF0YS1kaXNhYmxlZCc7XG5cbi8vIEFSSUEgQXR0cmlidXRlc1xuY29uc3QgQVJJQV9MQUJFTCA9ICdhcmlhLWxhYmVsJztcbmNvbnN0IEFSSUFfTEFCRUxMRURCWSA9ICdhcmlhLWxhYmVsbGVkYnknO1xuY2xhc3MgUmFuZ2VTbGlkZXIgZXh0ZW5kcyBfcmVhY3QuUHVyZUNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5lbGVtZW50ID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlUmVmKSgpO1xuICAgIHRoaXMuaW5wdXQgPSBbXTtcbiAgICB0aGlzLnRodW1iID0gWy8qI19fUFVSRV9fKi8oMCwgX3JlYWN0LmNyZWF0ZVJlZikoKSwgLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlUmVmKSgpXTtcbiAgICB0aGlzLnJhbmdlID0gLyojX19QVVJFX18qLygwLCBfcmVhY3QuY3JlYXRlUmVmKSgpO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuaXNDb250cm9sbGVkID0gZmFsc2U7XG4gICAgdGhpcy5leHRlcm5hbElucHV0ID0gZmFsc2U7XG4gICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxhc3RWYWx1ZVByb3AgPSBbXTtcbiAgfVxuICBpbml0aWF0ZUlucHV0UmFuZ2UoaW5kZXgpIHtcbiAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIGlucHV0RWxlbWVudC50eXBlID0gJ3JhbmdlJztcbiAgICBpbnB1dEVsZW1lbnQubWluID0gdGhpcy5vcHRpb25zLm1pbjtcbiAgICBpbnB1dEVsZW1lbnQubWF4ID0gdGhpcy5vcHRpb25zLm1heDtcbiAgICBpbnB1dEVsZW1lbnQuc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwO1xuICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgPyB0aGlzLm9wdGlvbnMudmFsdWVbaW5kZXhdIDogdGhpcy5vcHRpb25zLmRlZmF1bHRWYWx1ZVtpbmRleF07XG4gICAgcmV0dXJuIGlucHV0RWxlbWVudDtcbiAgfVxuICB1cGRhdGVJbnB1dFJhbmdlKGluZGV4KSB7XG4gICAgdGhpcy5pbnB1dFtpbmRleF0ubWluID0gdGhpcy5vcHRpb25zLm1pbjtcbiAgICB0aGlzLmlucHV0W2luZGV4XS5tYXggPSB0aGlzLm9wdGlvbnMubWF4O1xuICAgIHRoaXMuaW5wdXRbaW5kZXhdLnN0ZXAgPSB0aGlzLm9wdGlvbnMuc3RlcDtcbiAgICB0aGlzLmlucHV0W2luZGV4XS52YWx1ZSA9IHRoaXMucHJvcHMudmFsdWUgPyB0aGlzLm9wdGlvbnMudmFsdWVbaW5kZXhdIDogaW5kZXggPT09IDEgPyB0aGlzLnZhbHVlLm1heCA6IHRoaXMudmFsdWUubWluO1xuICB9XG4gIGNvbXBvbmVudERpZE1vdW50KCkge1xuICAgIGlmICghdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQpIHtcbiAgICAgIC8vIGlucHV0W3R5cGU9XCJyYW5nZVwiXSBlbGVtZW50cyBmb3Igc3luY2luZyB2YWx1ZXNcbiAgICAgIHRoaXMuaW5wdXQgPSBbdGhpcy5pbml0aWF0ZUlucHV0UmFuZ2UoMCksIHRoaXMuaW5pdGlhdGVJbnB1dFJhbmdlKDEpXTtcbiAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnNldE1pbk1heFByb3BzKCk7XG5cbiAgICAgIC8vIFRodW1iIGluZGV4ZXMgZm9yIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgICAgLy8gKHN3YXBwZWQgd2hlbiB0aGUgdGh1bWJzIGNyb3NzIGVhY2ggb3RoZXIpXG4gICAgICB0aGlzLmluZGV4ID0gdGhpcy5zZXRNaW5NYXhQcm9wcygwLCAxKTtcblxuICAgICAgLy8gVGh1bWIgd2lkdGggJiBoZWlnaHQgZm9yIGNhbGN1bGF0aW9uIG9mIGV4YWN0IHBvc2l0aW9ucyBhbmQgc2l6ZXMgb2YgaG9yaXpvbnRhbCB0aHVtYnMgYW5kIHJhbmdlXG4gICAgICB0aGlzLnRodW1iV2lkdGggPSB0aGlzLnNldE1pbk1heFByb3BzKCk7XG4gICAgICB0aGlzLnRodW1iSGVpZ2h0ID0gdGhpcy5zZXRNaW5NYXhQcm9wcygpO1xuXG4gICAgICAvLyBTbGlkYWJsZSByYW5nZSBsaW1pdHMgKHdoZW4gYSB0aHVtYiBpcyBkcmFnZ2VkKVxuICAgICAgdGhpcy5yYW5nZUxpbWl0cyA9IHRoaXMuc2V0TWluTWF4UHJvcHMoKTtcblxuICAgICAgLy8gU2xpZGVyIHZhbHVlIGRlcGVuZGluZyBvbiB0aGUgdXNlciBpbnRlcmFjdGlvblxuICAgICAgdGhpcy5zbGlkZXJWYWx1ZSA9IHRoaXMuc2V0TWluTWF4UHJvcHMoKTtcblxuICAgICAgLy8gRm9yIGRyYWdnaW5nIHRodW1icyBhbmQgcmFuZ2VcbiAgICAgIHRoaXMubWF4UmFuZ2VXaWR0aCA9IDA7XG4gICAgICB0aGlzLnJhbmdlV2lkdGggPSAwO1xuICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLnRodW1iRHJhZyA9IGZhbHNlO1xuICAgICAgdGhpcy5zdGFydFBvcyA9IDA7XG5cbiAgICAgIC8vIGluaXRpYWxcbiAgICAgIHRoaXMucmVzZXQodHJ1ZSk7XG5cbiAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgdG8gZWxlbWVudFxuICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcih0aGlzLmVsZW1lbnQuY3VycmVudCwgJ3BvaW50ZXJkb3duJywgZSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQoZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGxpc3RlbmVycyB0byB0aHVtYnMgYW5kIHNldCBbZGF0YS1kaXNhYmxlZF0gb24gZGlzYWJsZWQgdGh1bWJzXG4gICAgICB0aGlzLnRodW1iLmZvckVhY2goKHQsIGkpID0+IHtcbiAgICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcih0LmN1cnJlbnQsICdwb2ludGVyZG93bicsIGUgPT4ge1xuICAgICAgICAgIHRoaXMuaW5pdGlhdGVUaHVtYkRyYWcoZSwgaSwgdC5jdXJyZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYWRkTm9kZUV2ZW50TGlzdGVuZXIodC5jdXJyZW50LCAna2V5ZG93bicsIGUgPT4ge1xuICAgICAgICAgIGlmIChlLndoaWNoID49IDM3ICYmIGUud2hpY2ggPD0gNDApIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMuc3RlcFZhbHVlKGksIGUud2hpY2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkIGxpc3RlbmVycyB0byByYW5nZVxuICAgICAgdGhpcy5hZGROb2RlRXZlbnRMaXN0ZW5lcih0aGlzLnJhbmdlLmN1cnJlbnQsICdwb2ludGVyZG93bicsIGUgPT4ge1xuICAgICAgICB0aGlzLmluaXRpYXRlUmFuZ2VEcmFnKGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIERlZmluZSBhbmQgYWRkIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICAgIHRoaXMucG9pbnRlck1vdmVFdmVudCA9IGUgPT4ge1xuICAgICAgICB0aGlzLmRyYWcoZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wb2ludGVyVXBFdmVudCA9ICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZykge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iWzBdLmN1cnJlbnQsIERBVEFfQUNUSVZFKTtcbiAgICAgICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlsxXS5jdXJyZW50LCBEQVRBX0FDVElWRSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMucmFuZ2UuY3VycmVudCwgREFUQV9BQ1RJVkUpO1xuICAgICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgIGlmICh0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblRodW1iRHJhZ0VuZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25UaHVtYkRyYWdFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblJhbmdlRHJhZ0VuZCkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25SYW5nZURyYWdFbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB0aGlzLnJlc2l6ZUV2ZW50ID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnN5bmNUaHVtYkRpbWVuc2lvbnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVUaHVtYnMoKTtcbiAgICAgICAgdGhpcy51cGRhdGVSYW5nZSgpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkTm9kZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMucG9pbnRlck1vdmVFdmVudCk7XG4gICAgICB0aGlzLmFkZE5vZGVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5wb2ludGVyVXBFdmVudCk7XG4gICAgICB0aGlzLmFkZE5vZGVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplRXZlbnQpO1xuICAgICAgdGhpcy5pc0NvbXBvbmVudE1vdW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBjb21wb25lbnREaWRVcGRhdGUoKSB7XG4gICAgdGhpcy51cGRhdGVJbnB1dFJhbmdlKDApO1xuICAgIHRoaXMudXBkYXRlSW5wdXRSYW5nZSgxKTtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cbiAgY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgLy8gUmVtb3ZlIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICB0aGlzLnJlbW92ZU5vZGVFdmVudExpc3RlbmVyKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLnBvaW50ZXJNb3ZlRXZlbnQpO1xuICAgIHRoaXMucmVtb3ZlTm9kZUV2ZW50TGlzdGVuZXIoZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLnBvaW50ZXJVcEV2ZW50KTtcbiAgICB0aGlzLnJlbW92ZU5vZGVFdmVudExpc3RlbmVyKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMucmVzaXplRXZlbnQpO1xuICAgIHRoaXMuaXNDb21wb25lbnRNb3VudGVkID0gZmFsc2U7XG4gIH1cbiAgcmVzZXQoKSB7XG4gICAgbGV0IGZpcnN0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB0aGlzLmlzQ29udHJvbGxlZCA9ICEhdGhpcy5wcm9wcy52YWx1ZTtcbiAgICBpZiAodGhpcy5pc0NvbnRyb2xsZWQpIHtcbiAgICAgIGlmIChmaXJzdCB8fCB0aGlzLnByb3BzLnZhbHVlICE9PSB0aGlzLmxhc3RWYWx1ZVByb3ApIHtcbiAgICAgICAgdGhpcy5leHRlcm5hbElucHV0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFZhbHVlUHJvcCA9IHRoaXMucHJvcHMudmFsdWU7XG4gICAgfVxuICAgIHRoaXMubWF4UmFuZ2VXaWR0aCA9IHRoaXMub3B0aW9ucy5tYXggLSB0aGlzLm9wdGlvbnMubWluO1xuICAgIHRoaXMudXBkYXRlT3JpZW50YXRpb24oKTtcbiAgICB0aGlzLnNldFZhbHVlKCcnLCB0cnVlLCBmYWxzZSk7XG4gICAgdGhpcy51cGRhdGVSYW5nZUxpbWl0cygpO1xuICAgIHRoaXMudXBkYXRlRGlzYWJsZWRTdGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlVGh1bWJzRGlzYWJsZWRTdGF0ZSgpO1xuICAgIHRoaXMudXBkYXRlVGFiSW5kZXhlcygpO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgdGhpcy5zbGlkZXJWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgfVxuICB9XG4gIGlzTnVtYmVyKG4pIHtcbiAgICAvLyBjaGVjayBmb3IgTmFOIGV4cGxpY2l0bHlcbiAgICAvLyBiZWNhdXNlIHdpdGggTmFOLCB0aGUgc2Vjb25kIGV4cC4gZXZhbHVhdGVzIHRvIHRydWVcbiAgICByZXR1cm4gIWlzTmFOKG4pICYmICtuICsgJycgPT09IG4gKyAnJztcbiAgfVxuICBzZXRNaW5NYXhQcm9wcygpIHtcbiAgICBsZXQgbWluID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIGxldCBtYXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbixcbiAgICAgIG1heFxuICAgIH07XG4gIH1cbiAgaXRlcmF0ZU1pbk1heFByb3BzKGZuKSB7XG4gICAgW01JTiwgTUFYXS5mb3JFYWNoKGZuKTtcbiAgfVxuICBnZXRTZXRQcm9wcyhjb25kaXRpb24sIGV4cHJlc3Npb24sIGZuKSB7XG4gICAgaWYgKGNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIGV4cHJlc3Npb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGZuKCk7XG4gICAgfVxuICB9XG4gIHNldE5vZGVBdHRyaWJ1dGUobm9kZSwgYXR0cmlidXRlKSB7XG4gICAgbGV0IHZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAnJztcbiAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgfVxuICByZW1vdmVOb2RlQXR0cmlidXRlKG5vZGUsIGF0dHJpYnV0ZSkge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gIH1cbiAgYWRkTm9kZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGZuKSB7XG4gICAgbGV0IGlzUG9pbnRlckV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIC8vIHdpdGggb3B0aW9ucyBmb3IgcG9pbnRlciBldmVudHNcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBpc1BvaW50ZXJFdmVudCA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0gOiB7fSk7XG4gIH1cbiAgcmVtb3ZlTm9kZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGZuKSB7XG4gICAgbGV0IGlzUG9pbnRlckV2ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiB0cnVlO1xuICAgIC8vIHdpdGggb3B0aW9ucyBmb3IgcG9pbnRlciBldmVudHNcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCBpc1BvaW50ZXJFdmVudCA/IHtcbiAgICAgIHBhc3NpdmU6IGZhbHNlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0gOiB7fSk7XG4gIH1cbiAgZmFsbGJhY2tUb0RlZmF1bHQocHJvcGVydHksIGRlZmF1bHRWYWx1ZSkge1xuICAgIHRoaXMub3B0aW9uc1twcm9wZXJ0eV0gPSB0aGlzLnByb3BzW3Byb3BlcnR5XSA/IHRoaXMucHJvcHNbcHJvcGVydHldIDogZGVmYXVsdFZhbHVlO1xuICB9XG4gIGlmVmVydGljYWxFbHNlKHZlcnRpY2FsLCBob3Jpem9udGFsKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucy5vcmllbnRhdGlvbiA9PT0gVkVSVElDQUwgPyB2ZXJ0aWNhbCA6IGhvcml6b250YWw7XG4gIH1cbiAgY3VycmVudEluZGV4KGkpIHtcbiAgICByZXR1cm4gaSA9PT0gMSA/IHRoaXMuaW5kZXgubWF4IDogdGhpcy5pbmRleC5taW47XG4gIH1cblxuICAvLyBTZXQgbWluIGFuZCBtYXggdmFsdWVzIHRvIDEgKGFyYml0cmFyaWx5KSBpZiBhbnkgb2YgdGhlIG1pbiBvciBtYXggdmFsdWVzIGFyZSBcImludmFsaWRcIlxuICAvLyBTZXR0aW5nIGJvdGggdmFsdWVzIDEgd2lsbCBkaXNhYmxlIHRoZSBzbGlkZXJcbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gbWluIG9yIG1heCBwcm9wZXJ0aWVzIGFyZSBtb2RpZmllZFxuICBzYWZlTWluTWF4VmFsdWVzKCkge1xuICAgIGxldCBlcnJvciA9IGZhbHNlO1xuICAgIGlmICghdGhpcy5pc051bWJlcih0aGlzLm9wdGlvbnMubWluKSB8fCAhdGhpcy5pc051bWJlcih0aGlzLm9wdGlvbnMubWF4KSkge1xuICAgICAgZXJyb3IgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLm9wdGlvbnMubWluID0gZXJyb3IgPyAxIDogK3RoaXMub3B0aW9ucy5taW47XG4gICAgdGhpcy5vcHRpb25zLm1heCA9IGVycm9yID8gMSA6ICt0aGlzLm9wdGlvbnMubWF4O1xuICB9XG5cbiAgLy8gUmVmcmFtZSB0aGUgdGh1bWJzRGlzYWJsZWQgdmFsdWUgaWYgXCJpbnZhbGlkXCJcbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gdGh1bWJzRGlzYWJsZWQgcHJvcGVydHkgaXMgbW9kaWZpZWRcbiAgc2FmZVRodW1ic0Rpc2FibGVkVmFsdWVzKCkge1xuICAgIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkLnB1c2goZmFsc2UpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZC5sZW5ndGggIT09IDEgJiYgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWQgPSBbZmFsc2UsIGZhbHNlXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkID0gW3RoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZCwgdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkXTtcbiAgICB9XG5cbiAgICAvLyBCb29sZWFuIFZhbHVlc1xuICAgIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFswXSA9ICEhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkWzBdO1xuICAgIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFsxXSA9ICEhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkWzFdO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRoZSBlbGVtZW50IGlzIGluaXRpYWxseSBzZXRcbiAgLy8gLT4gbWluLCBtYXgsIHN0ZXAgb3IgdmFsdWUgcHJvcGVydGllcyBhcmUgbW9kaWZpZWRcbiAgLy8gLT4gdGh1bWJzIGFyZSBkcmFnZ2VkXG4gIC8vIC0+IGVsZW1lbnQgaXMgY2xpY2tlZCB1cG9uXG4gIC8vIC0+IGFuIGFycm93IGtleSBpcyBwcmVzc2VkXG4gIHNldFZhbHVlKG5ld1ZhbHVlKSB7XG4gICAgbGV0IGZvcmNlU2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBsZXQgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgLy8gQ3VycmVudCB2YWx1ZSBhcyBzZXQgaW4gdGhlIGlucHV0IGVsZW1lbnRzXG4gICAgLy8gd2hpY2ggY291bGQgY2hhbmdlIHdoaWxlIGNoYW5naW5nIG1pbiwgbWF4IGFuZCBzdGVwIHZhbHVlc1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuc2V0TWluTWF4UHJvcHModGhpcy5pbnB1dFswXS52YWx1ZSwgdGhpcy5pbnB1dFsxXS52YWx1ZSk7XG5cbiAgICAvLyB2YXIgdmFsdWUgaXMgc3luY2VkIHdpdGggdGhlIHZhbHVlcyBzZXQgaW4gdGhlIGlucHV0IGVsZW1lbnRzIGlmIG5vIG5ld1ZhbHVlIGlzIHBhc3NlZFxuICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgfHwgY3VycmVudFZhbHVlO1xuICAgIHRoaXMuaW5wdXRbdGhpcy5pbmRleC5taW5dLnZhbHVlID0gbmV3VmFsdWUubWluO1xuICAgIHRoaXMuaW5wdXRbdGhpcy5pbmRleC5tYXhdLnZhbHVlID0gdGhpcy50aHVtYkRyYWcgfHwgZm9yY2VTZXQgPyBuZXdWYWx1ZS5tYXggOiBuZXdWYWx1ZS5taW4gKyB0aGlzLnJhbmdlV2lkdGg7XG4gICAgdGhpcy5zeW5jVmFsdWVzKCk7XG5cbiAgICAvLyBDaGVjayBpZiB0aGUgdGh1bWJzIGNyb3NzIGVhY2ggb3RoZXJcbiAgICBpZiAodGhpcy52YWx1ZS5taW4gPiB0aGlzLnZhbHVlLm1heCkge1xuICAgICAgdmFyIF90aGlzJHByb3BzLCBfdGhpcyRwcm9wczIsIF90aGlzJHByb3BzMywgX3RoaXMkcHJvcHM0O1xuICAgICAgLy8gU3dpdGNoIHRodW1iIGluZGV4ZXNcbiAgICAgIHRoaXMuaW5kZXgubWluID0gKyF0aGlzLmluZGV4Lm1pbjtcbiAgICAgIHRoaXMuaW5kZXgubWF4ID0gKyF0aGlzLmluZGV4Lm1heDtcblxuICAgICAgLy8gU3dpdGNoIHRodW1iIGF0dHJpYnV0ZXNcbiAgICAgIHRoaXMucmVtb3ZlTm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCBEQVRBX1VQUEVSKTtcbiAgICAgIHRoaXMucmVtb3ZlTm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWF4XS5jdXJyZW50LCBEQVRBX0xPV0VSKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCBEQVRBX0xPV0VSKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWF4XS5jdXJyZW50LCBEQVRBX1VQUEVSKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCBBUklBX0xBQkVMLCAoX3RoaXMkcHJvcHMgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wcyA9PT0gdm9pZCAwIHx8IChfdGhpcyRwcm9wcyA9IF90aGlzJHByb3BzLmFyaWFMYWJlbCkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzWzBdKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWF4XS5jdXJyZW50LCBBUklBX0xBQkVMLCAoX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHMyID09PSB2b2lkIDAgfHwgKF90aGlzJHByb3BzMiA9IF90aGlzJHByb3BzMi5hcmlhTGFiZWwpID09PSBudWxsIHx8IF90aGlzJHByb3BzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHMyWzFdKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCBBUklBX0xBQkVMTEVEQlksIChfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczMgPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHMzID0gX3RoaXMkcHJvcHMzLmFyaWFMYWJlbGxlZEJ5KSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzM1swXSk7XG4gICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlt0aGlzLmluZGV4Lm1heF0uY3VycmVudCwgQVJJQV9MQUJFTExFREJZLCAoX3RoaXMkcHJvcHM0ID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHM0ID09PSB2b2lkIDAgfHwgKF90aGlzJHByb3BzNCA9IF90aGlzJHByb3BzNC5hcmlhTGFiZWxsZWRCeSkgPT09IG51bGwgfHwgX3RoaXMkcHJvcHM0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwcm9wczRbMV0pO1xuXG4gICAgICAvLyBTd2l0Y2ggdGh1bWIgZHJhZyBsYWJlbHNcbiAgICAgIGlmICh0aGlzLnRodW1iRHJhZykge1xuICAgICAgICB0aGlzLnRodW1iRHJhZyA9IHRoaXMudGh1bWJEcmFnID09PSBNSU4gPyBNQVggOiBNSU47XG4gICAgICB9XG4gICAgICB0aGlzLnN5bmNWYWx1ZXMoKTtcbiAgICB9XG4gICAgdGhpcy5zbGlkZXJWYWx1ZSA9IGZvcmNlU2V0ID8gdGhpcy5zbGlkZXJWYWx1ZSA6IG5ld1ZhbHVlO1xuICAgIGxldCB2YWx1ZVNldCA9IGZhbHNlO1xuICAgIGNvbnN0IGN1cnJlbnRWYWx1ZXMgPSBbY3VycmVudFZhbHVlLm1pbiwgY3VycmVudFZhbHVlLm1heF0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGNvbnN0IGVsZW1lbnRWYWx1ZXMgPSBbdGhpcy5pbnB1dFswXS52YWx1ZSwgdGhpcy5pbnB1dFsxXS52YWx1ZV0uc29ydCgoYSwgYikgPT4gYSAtIGIpO1xuICAgIGlmIChjdXJyZW50VmFsdWVzWzBdICE9PSBlbGVtZW50VmFsdWVzWzBdIHx8IGZvcmNlU2V0KSB7XG4gICAgICB2YWx1ZVNldCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VmFsdWVzWzFdICE9PSBlbGVtZW50VmFsdWVzWzFdIHx8IGZvcmNlU2V0KSB7XG4gICAgICB2YWx1ZVNldCA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBwb3NpdGlvbnMsIGRpbWVuc2lvbnMgYW5kIGFyaWEgYXR0cmlidXRlcyBldmVyeXRpbWUgYSB2YWx1ZSBpcyBzZXRcbiAgICAvLyBhbmQgY2FsbCB0aGUgb25JbnB1dCBmdW5jdGlvbiBmcm9tIG9wdGlvbnMgKGlmIHNldClcbiAgICBpZiAodmFsdWVTZXQpIHtcbiAgICAgIGlmIChjYWxsYmFjayAmJiB0aGlzLm9wdGlvbnMub25JbnB1dCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25JbnB1dChbdGhpcy52YWx1ZS5taW4sIHRoaXMudmFsdWUubWF4XSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaXNDb250cm9sbGVkIHx8IHRoaXMuZXh0ZXJuYWxJbnB1dCkge1xuICAgICAgICB0aGlzLmV4dGVybmFsSW5wdXQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zeW5jVGh1bWJEaW1lbnNpb25zKCk7XG4gICAgICAgIHRoaXMudXBkYXRlVGh1bWJzKCk7XG4gICAgICAgIHRoaXMudXBkYXRlUmFuZ2UoKTtcbiAgICAgICAgdGhpcy51cGRhdGVBcmlhVmFsdWVBdHRyaWJ1dGVzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gU3luYyB2YXIgdmFsdWUgd2l0aCB0aGUgaW5wdXQgZWxlbWVudHNcbiAgc3luY1ZhbHVlcygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMudmFsdWVbX10gPSArdGhpcy5pbnB1dFt0aGlzLmluZGV4W19dXS52YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIENhbGxlZCB3aGVuLFxuICAvLyAtPiBzZXRWYWx1ZSBpcyBjYWxsZWQgYW5kIGEgdmFsdWUgaXMgc2V0XG4gIC8vIC0+IHdpbmRvdyBpcyByZXNpemVkXG4gIHVwZGF0ZVRodW1icygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMudGh1bWJbdGhpcy5pbmRleFtfXV0uY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCd0b3AnLCAnbGVmdCcpXSA9IFwiY2FsYyhcIi5jb25jYXQoKHRoaXMudmFsdWVbX10gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCAqIDEwMCwgXCIlICsgXCIpLmNvbmNhdCgoMC41IC0gKHRoaXMudmFsdWVbX10gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCkgKiB0aGlzLmlmVmVydGljYWxFbHNlKHRoaXMudGh1bWJIZWlnaHQsIHRoaXMudGh1bWJXaWR0aClbX10sIFwicHgpXCIpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHNldFZhbHVlIGlzIGNhbGxlZCBhbmQgYSB2YWx1ZSBpcyBzZXRcbiAgLy8gLT4gd2luZG93IGlzIHJlc2l6ZWRcbiAgdXBkYXRlUmFuZ2UoKSB7XG4gICAgY29uc3QgZWxlbWVudEJvdW5kcyA9IHRoaXMuZWxlbWVudC5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGNvbnN0IGRlbHRhT2Zmc2V0ID0gKDAuNSAtICh0aGlzLnZhbHVlLm1pbiAtIHRoaXMub3B0aW9ucy5taW4pIC8gdGhpcy5tYXhSYW5nZVdpZHRoKSAqIHRoaXMuaWZWZXJ0aWNhbEVsc2UodGhpcy50aHVtYkhlaWdodCwgdGhpcy50aHVtYldpZHRoKS5taW4gLyB0aGlzLmlmVmVydGljYWxFbHNlKGVsZW1lbnRCb3VuZHMuYm90dG9tIC0gZWxlbWVudEJvdW5kcy50b3AsIGVsZW1lbnRCb3VuZHMucmlnaHQgLSBlbGVtZW50Qm91bmRzLmxlZnQpO1xuICAgIGNvbnN0IGRlbHRhRGltZW5zaW9uID0gKDAuNSAtICh0aGlzLnZhbHVlLm1heCAtIHRoaXMub3B0aW9ucy5taW4pIC8gdGhpcy5tYXhSYW5nZVdpZHRoKSAqIHRoaXMuaWZWZXJ0aWNhbEVsc2UodGhpcy50aHVtYkhlaWdodCwgdGhpcy50aHVtYldpZHRoKS5tYXggLyB0aGlzLmlmVmVydGljYWxFbHNlKGVsZW1lbnRCb3VuZHMuYm90dG9tIC0gZWxlbWVudEJvdW5kcy50b3AsIGVsZW1lbnRCb3VuZHMucmlnaHQgLSBlbGVtZW50Qm91bmRzLmxlZnQpO1xuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCd0b3AnLCAnbGVmdCcpXSA9IFwiXCIuY29uY2F0KCgodGhpcy52YWx1ZS5taW4gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCArIGRlbHRhT2Zmc2V0KSAqIDEwMCwgXCIlXCIpO1xuICAgIHRoaXMucmFuZ2UuY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCdoZWlnaHQnLCAnd2lkdGgnKV0gPSBcIlwiLmNvbmNhdCgoKHRoaXMudmFsdWUubWF4IC0gdGhpcy5vcHRpb25zLm1pbikgLyB0aGlzLm1heFJhbmdlV2lkdGggLSAodGhpcy52YWx1ZS5taW4gLSB0aGlzLm9wdGlvbnMubWluKSAvIHRoaXMubWF4UmFuZ2VXaWR0aCAtIGRlbHRhT2Zmc2V0ICsgZGVsdGFEaW1lbnNpb24pICogMTAwLCBcIiVcIik7XG4gIH1cbiAgdXBkYXRlUmFuZ2VMaW1pdHMoKSB7XG4gICAgdGhpcy5pdGVyYXRlTWluTWF4UHJvcHMoKF8sIGkpID0+IHtcbiAgICAgIHRoaXMucmFuZ2VMaW1pdHNbX10gPSB0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbaV0gPyB0aGlzLnZhbHVlW19dIDogdGhpcy5vcHRpb25zW19dO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHRodW1icyBhcmUgaW5pdGlhbGx5IHNldFxuICAvLyAtPiB0aHVtYnMgYXJlIGRpc2FibGVkIC8gZW5hYmxlZFxuICB1cGRhdGVUYWJJbmRleGVzKCkge1xuICAgIHRoaXMuaXRlcmF0ZU1pbk1heFByb3BzKChfLCBpKSA9PiB7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiAhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkW2ldKSB7XG4gICAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuY3VycmVudEluZGV4KGkpXS5jdXJyZW50LCBUQUJJTkRFWCwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlt0aGlzLmN1cnJlbnRJbmRleChpKV0uY3VycmVudCwgVEFCSU5ERVgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IHNldFZhbHVlIGlzIGNhbGxlZCBhbmQgYSB2YWx1ZSBpcyBzZXRcbiAgdXBkYXRlQXJpYVZhbHVlQXR0cmlidXRlcygpIHtcbiAgICB0aGlzLml0ZXJhdGVNaW5NYXhQcm9wcyhfID0+IHtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXhbX11dLmN1cnJlbnQsICdhcmlhLXZhbHVlbWluJywgdGhpcy5vcHRpb25zLm1pbik7XG4gICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50LCAnYXJpYS12YWx1ZW1heCcsIHRoaXMub3B0aW9ucy5tYXgpO1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMudGh1bWJbdGhpcy5pbmRleFtfXV0uY3VycmVudCwgJ2FyaWEtdmFsdWVub3cnLCB0aGlzLnZhbHVlW19dKTtcbiAgICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZSh0aGlzLnRodW1iW3RoaXMuaW5kZXhbX11dLmN1cnJlbnQsICdhcmlhLXZhbHVldGV4dCcsIHRoaXMudmFsdWVbX10pO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IGRpc2FibGVkIHByb3BlcnR5IGlzIG1vZGlmaWVkXG4gIHVwZGF0ZURpc2FibGVkU3RhdGUoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5jdXJyZW50LCBEQVRBX0RJU0FCTEVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5jdXJyZW50LCBEQVRBX0RJU0FCTEVEKTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gdGh1bWJzRGlzYWJsZWQgcHJvcGVydHkgaXMgbW9kaWZpZWRcbiAgdXBkYXRlVGh1bWJzRGlzYWJsZWRTdGF0ZSgpIHtcbiAgICB0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWQuZm9yRWFjaCgoZCwgaSkgPT4ge1xuICAgICAgY29uc3QgY3VyckluZGV4ID0gdGhpcy5jdXJyZW50SW5kZXgoaSk7XG4gICAgICBpZiAoZCkge1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsICdhcmlhLWRpc2FibGVkJywgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlbW92ZU5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsIERBVEFfRElTQUJMRUQpO1xuICAgICAgICB0aGlzLnNldE5vZGVBdHRyaWJ1dGUodGhpcy50aHVtYltjdXJySW5kZXhdLmN1cnJlbnQsICdhcmlhLWRpc2FibGVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW4sXG4gIC8vIC0+IG1pbiBvciBtYXggdmFsdWVzIGFyZSBtb2RpZmllZFxuICB1cGRhdGVMaW1pdHMobGltaXQpIHtcbiAgICBsZXQgbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdGhpcy5vcHRpb25zW2xpbWl0XSA9IG07XG4gICAgdGhpcy5zYWZlTWluTWF4VmFsdWVzKCk7XG4gICAgdGhpcy5pdGVyYXRlTWluTWF4UHJvcHMoXyA9PiB7XG4gICAgICB0aGlzLmlucHV0WzBdW19dID0gdGhpcy5vcHRpb25zW19dO1xuICAgICAgdGhpcy5pbnB1dFsxXVtfXSA9IHRoaXMub3B0aW9uc1tfXTtcbiAgICB9KTtcbiAgICB0aGlzLm1heFJhbmdlV2lkdGggPSB0aGlzLm9wdGlvbnMubWF4IC0gdGhpcy5vcHRpb25zLm1pbjtcbiAgICB0aGlzLnNldFZhbHVlKCcnLCB0cnVlKTtcbiAgICB0aGlzLnVwZGF0ZVJhbmdlTGltaXRzKCk7XG4gIH1cblxuICAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gdGhlIGVsZW1lbnQgaXMgaW5pdGlhbGx5IHNldFxuICAvLyAtPiBvcmllbnRhdGlvbiBwcm9wZXJ0eSBpcyBtb2RpZmllZFxuICB1cGRhdGVPcmllbnRhdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcHRpb25zLm9yaWVudGF0aW9uID09PSBWRVJUSUNBTCkge1xuICAgICAgdGhpcy5zZXROb2RlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5jdXJyZW50LCBEQVRBX1ZFUlRJQ0FMKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVOb2RlQXR0cmlidXRlKHRoaXMuZWxlbWVudC5jdXJyZW50LCBEQVRBX1ZFUlRJQ0FMKTtcbiAgICB9XG4gICAgdGhpcy5yYW5nZS5jdXJyZW50LnN0eWxlW3RoaXMuaWZWZXJ0aWNhbEVsc2UoJ2xlZnQnLCAndG9wJyldID0gJyc7XG4gICAgdGhpcy5yYW5nZS5jdXJyZW50LnN0eWxlW3RoaXMuaWZWZXJ0aWNhbEVsc2UoJ3dpZHRoJywgJ2hlaWdodCcpXSA9ICcnO1xuICAgIHRoaXMudGh1bWJbMF0uY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCdsZWZ0JywgJ3RvcCcpXSA9ICcnO1xuICAgIHRoaXMudGh1bWJbMV0uY3VycmVudC5zdHlsZVt0aGlzLmlmVmVydGljYWxFbHNlKCdsZWZ0JywgJ3RvcCcpXSA9ICcnO1xuICB9XG5cbiAgLy8gdGh1bWIgd2lkdGggJiBoZWlnaHQgdmFsdWVzIGFyZSB0byBiZSBzeW5jZWQgd2l0aCB0aGUgQ1NTIHZhbHVlcyBmb3IgY29ycmVjdCBjYWxjdWxhdGlvbiBvZlxuICAvLyB0aHVtYiBwb3NpdGlvbiBhbmQgcmFuZ2Ugd2lkdGggJiBwb3NpdGlvblxuICAvLyBDYWxsZWQgd2hlbixcbiAgLy8gLT4gc2V0VmFsdWUgaXMgY2FsbGVkIGFuZCBhIHZhbHVlIGlzIHNldCAoY2FsbGVkIGJlZm9yZSB1cGRhdGVUaHVtYnMoKSBhbmQgdXBkYXRlUmFuZ2UoKSlcbiAgLy8gLT4gdGh1bWIgLyByYW5nZSBkcmFnIGlzIGluaXRpYXRlZFxuICAvLyAtPiB3aW5kb3cgaXMgcmVzaXplZFxuICBzeW5jVGh1bWJEaW1lbnNpb25zKCkge1xuICAgIHRoaXMuaXRlcmF0ZU1pbk1heFByb3BzKF8gPT4ge1xuICAgICAgdGhpcy50aHVtYldpZHRoW19dID0gZmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50KS53aWR0aCk7XG4gICAgICB0aGlzLnRodW1iSGVpZ2h0W19dID0gZmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy50aHVtYlt0aGlzLmluZGV4W19dXS5jdXJyZW50KS5oZWlnaHQpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdGh1bWIgcG9zaXRpb24gY2FsY3VsYXRpb24gZGVwZW5kaW5nIHVwb24gdGhlIHBvaW50ZXIgcG9zaXRpb25cbiAgY3VycmVudFBvc2l0aW9uKGUsIG5vZGUpIHtcbiAgICBjb25zdCBlbGVtZW50Qm91bmRzID0gdGhpcy5lbGVtZW50LmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgbm9kZUJvdW5kcyA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgY3VyclBvcyA9ICh0aGlzLmlmVmVydGljYWxFbHNlKG5vZGVCb3VuZHMudG9wIC0gZWxlbWVudEJvdW5kcy50b3AsIG5vZGVCb3VuZHMubGVmdCAtIGVsZW1lbnRCb3VuZHMubGVmdCkgKyAoZVtcImNsaWVudFwiLmNvbmNhdCh0aGlzLmlmVmVydGljYWxFbHNlKCdZJywgJ1gnKSldIC0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVt0aGlzLmlmVmVydGljYWxFbHNlKCd0b3AnLCAnbGVmdCcpXSkgLSAodGhpcy50aHVtYkRyYWcgPyAoMC41IC0gKHRoaXMudmFsdWVbdGhpcy50aHVtYkRyYWddIC0gdGhpcy5vcHRpb25zLm1pbikgLyB0aGlzLm1heFJhbmdlV2lkdGgpICogdGhpcy5pZlZlcnRpY2FsRWxzZSh0aGlzLnRodW1iSGVpZ2h0LCB0aGlzLnRodW1iV2lkdGgpW3RoaXMudGh1bWJEcmFnXSA6IDApKSAvIHRoaXMuaWZWZXJ0aWNhbEVsc2UoZWxlbWVudEJvdW5kcy5ib3R0b20gLSBlbGVtZW50Qm91bmRzLnRvcCwgZWxlbWVudEJvdW5kcy5yaWdodCAtIGVsZW1lbnRCb3VuZHMubGVmdCkgKiB0aGlzLm1heFJhbmdlV2lkdGggKyB0aGlzLm9wdGlvbnMubWluO1xuICAgIGlmIChjdXJyUG9zIDwgdGhpcy5vcHRpb25zLm1pbikge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5taW47XG4gICAgfVxuICAgIGlmIChjdXJyUG9zID4gdGhpcy5vcHRpb25zLm1heCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5tYXg7XG4gICAgfVxuICAgIHJldHVybiBjdXJyUG9zO1xuICB9XG4gIGRvZXNudEhhdmVDbGFzc05hbWUoZSwgY2xhc3NOYW1lKSB7XG4gICAgcmV0dXJuICFlLnRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKTtcbiAgfVxuICBlbGVtZW50Rm9jdXNlZChlKSB7XG4gICAgbGV0IHJlcGVhdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBsZXQgc2V0Rm9jdXMgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiAodGhpcy5kb2VzbnRIYXZlQ2xhc3NOYW1lKGUsICdyYW5nZS1zbGlkZXJfX3RodW1iJykgJiYgdGhpcy5kb2VzbnRIYXZlQ2xhc3NOYW1lKGUsICdyYW5nZS1zbGlkZXJfX3JhbmdlJykgfHwgdGhpcy5vcHRpb25zLnJhbmdlU2xpZGVEaXNhYmxlZCAmJiB0aGlzLmRvZXNudEhhdmVDbGFzc05hbWUoZSwgJ3JhbmdlLXNsaWRlcl9fdGh1bWInKSkpIHtcbiAgICAgIHNldEZvY3VzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBObyBhY3Rpb24gaWYgYm90aCB0aHVtYnMgYXJlIGRpc2FibGVkXG4gICAgaWYgKHNldEZvY3VzICYmIHRoaXMub3B0aW9ucy50aHVtYnNEaXNhYmxlZFswXSAmJiB0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbMV0pIHtcbiAgICAgIHNldEZvY3VzID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZXRGb2N1cykge1xuICAgICAgY29uc3QgY3VyclBvcyA9IHRoaXMuY3VycmVudFBvc2l0aW9uKGUsIHRoaXMucmFuZ2UuY3VycmVudCk7XG4gICAgICBjb25zdCBkZWx0YU1pbiA9IGFicyh0aGlzLnZhbHVlLm1pbiAtIGN1cnJQb3MpO1xuICAgICAgY29uc3QgZGVsdGFNYXggPSBhYnModGhpcy52YWx1ZS5tYXggLSBjdXJyUG9zKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbMF0pIHtcbiAgICAgICAgaWYgKGN1cnJQb3MgPj0gdGhpcy52YWx1ZS5taW4pIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHModGhpcy52YWx1ZS5taW4sIGN1cnJQb3MpLCB0cnVlLCAhcmVwZWF0KTtcbiAgICAgICAgICB0aGlzLmluaXRpYXRlVGh1bWJEcmFnKGUsIHRoaXMuaW5kZXgubWF4LCB0aGlzLnRodW1iW3RoaXMuaW5kZXgubWF4XS5jdXJyZW50LCAhcmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbMV0pIHtcbiAgICAgICAgaWYgKGN1cnJQb3MgPD0gdGhpcy52YWx1ZS5tYXgpIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHMoY3VyclBvcywgdGhpcy52YWx1ZS5tYXgpLCB0cnVlLCAhcmVwZWF0KTtcbiAgICAgICAgICB0aGlzLmluaXRpYXRlVGh1bWJEcmFnKGUsIHRoaXMuaW5kZXgubWluLCB0aGlzLnRodW1iW3RoaXMuaW5kZXgubWluXS5jdXJyZW50LCAhcmVwZWF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IG5lYXJlc3RUaHVtYkluZGV4ID0gdGhpcy5pbmRleC5tYXg7XG4gICAgICAgIGlmIChkZWx0YU1pbiA9PT0gZGVsdGFNYXgpIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHModGhpcy52YWx1ZS5taW4sIGN1cnJQb3MpLCB0cnVlLCAhcmVwZWF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldFZhbHVlKHRoaXMuc2V0TWluTWF4UHJvcHMoZGVsdGFNaW4gPCBkZWx0YU1heCA/IGN1cnJQb3MgOiB0aGlzLnZhbHVlLm1pbiwgZGVsdGFNYXggPCBkZWx0YU1pbiA/IGN1cnJQb3MgOiB0aGlzLnZhbHVlLm1heCksIHRydWUsICFyZXBlYXQpO1xuICAgICAgICAgIG5lYXJlc3RUaHVtYkluZGV4ID0gZGVsdGFNaW4gPCBkZWx0YU1heCA/IHRoaXMuaW5kZXgubWluIDogdGhpcy5pbmRleC5tYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWF0ZVRodW1iRHJhZyhlLCBuZWFyZXN0VGh1bWJJbmRleCwgdGhpcy50aHVtYltuZWFyZXN0VGh1bWJJbmRleF0uY3VycmVudCwgIXJlcGVhdCk7XG4gICAgICB9XG4gICAgICBpZiAocmVwZWF0KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudEZvY3VzZWQoZSwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbml0aWF0ZURyYWcoZSwgbm9kZSkge1xuICAgIHRoaXMuc3luY1RodW1iRGltZW5zaW9ucygpO1xuICAgIHRoaXMuc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBEQVRBX0FDVElWRSk7XG4gICAgdGhpcy5zdGFydFBvcyA9IHRoaXMuY3VycmVudFBvc2l0aW9uKGUsIG5vZGUpO1xuICAgIHRoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gIH1cbiAgaW5pdGlhdGVUaHVtYkRyYWcoZSwgaSwgbm9kZSkge1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiAhdGhpcy5vcHRpb25zLnRodW1ic0Rpc2FibGVkW3RoaXMuY3VycmVudEluZGV4KGkpXSkge1xuICAgICAgdGhpcy5pbml0aWF0ZURyYWcoZSwgbm9kZSk7XG4gICAgICB0aGlzLnRodW1iRHJhZyA9IHRoaXMuaW5kZXgubWluID09PSBpID8gTUlOIDogTUFYO1xuICAgICAgaWYgKGNhbGxiYWNrICYmIHRoaXMub3B0aW9ucy5vblRodW1iRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblRodW1iRHJhZ1N0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGluaXRpYXRlUmFuZ2VEcmFnKGUpIHtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlZCAmJiAhdGhpcy5vcHRpb25zLnJhbmdlU2xpZGVEaXNhYmxlZCkge1xuICAgICAgdGhpcy5pbml0aWF0ZURyYWcoZSwgdGhpcy5yYW5nZS5jdXJyZW50KTtcbiAgICAgIHRoaXMucmFuZ2VXaWR0aCA9IHRoaXMudmFsdWUubWF4IC0gdGhpcy52YWx1ZS5taW47XG4gICAgICB0aGlzLnRodW1iRHJhZyA9IGZhbHNlO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5vblJhbmdlRHJhZ1N0YXJ0KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5vblJhbmdlRHJhZ1N0YXJ0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGRyYWcoZSkge1xuICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcpIHtcbiAgICAgIGNvbnN0IGxhc3RQb3MgPSB0aGlzLmN1cnJlbnRQb3NpdGlvbihlLCB0aGlzLnJhbmdlLmN1cnJlbnQpO1xuICAgICAgY29uc3QgZGVsdGEgPSBsYXN0UG9zIC0gdGhpcy5zdGFydFBvcztcbiAgICAgIGxldCBtaW4gPSB0aGlzLnZhbHVlLm1pbjtcbiAgICAgIGxldCBtYXggPSB0aGlzLnZhbHVlLm1heDtcbiAgICAgIGNvbnN0IGxvd2VyID0gdGhpcy50aHVtYkRyYWcgPyB0aGlzLnJhbmdlTGltaXRzLm1pbiA6IHRoaXMub3B0aW9ucy5taW47XG4gICAgICBjb25zdCB1cHBlciA9IHRoaXMudGh1bWJEcmFnID8gdGhpcy5yYW5nZUxpbWl0cy5tYXggOiB0aGlzLm9wdGlvbnMubWF4O1xuICAgICAgaWYgKCF0aGlzLnRodW1iRHJhZyB8fCB0aGlzLnRodW1iRHJhZyA9PT0gTUlOKSB7XG4gICAgICAgIG1pbiA9IHRoaXMudGh1bWJEcmFnID8gbGFzdFBvcyA6IHRoaXMuc2xpZGVyVmFsdWUubWluICsgZGVsdGE7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMudGh1bWJEcmFnIHx8IHRoaXMudGh1bWJEcmFnID09PSBNQVgpIHtcbiAgICAgICAgbWF4ID0gdGhpcy50aHVtYkRyYWcgPyBsYXN0UG9zIDogdGhpcy5zbGlkZXJWYWx1ZS5tYXggKyBkZWx0YTtcbiAgICAgIH1cbiAgICAgIGlmIChtaW4gPj0gbG93ZXIgJiYgbWluIDw9IHVwcGVyICYmIG1heCA+PSBsb3dlciAmJiBtYXggPD0gdXBwZXIpIHtcbiAgICAgICAgdGhpcy5zZXRWYWx1ZSh7XG4gICAgICAgICAgbWluLFxuICAgICAgICAgIG1heFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zdGFydFBvcyA9IGxhc3RQb3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIG1pbiB0aHVtYiByZWFjaGVzIHVwcGVyIGxpbWl0XG4gICAgICAgIGlmIChtaW4gPiB1cHBlciAmJiB0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyh1cHBlciwgdXBwZXIpKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIG1heCB0aHVtYiByZWFjaGVzIGxvd2VyIGxpbWl0XG4gICAgICAgIGlmIChtYXggPCBsb3dlciAmJiB0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgIHRoaXMuc2V0VmFsdWUodGhpcy5zZXRNaW5NYXhQcm9wcyhsb3dlciwgbG93ZXIpKTtcbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHJhbmdlIC8gbWluIHRodW1iIHJlYWNoZXMgbG93ZXIgbGltaXRcbiAgICAgICAgaWYgKG1pbiA8IGxvd2VyKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnNldE1pbk1heFByb3BzKGxvd2VyLCB0aGlzLnZhbHVlLm1heCAtIHRoaXMudmFsdWUubWluICsgbG93ZXIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnNldE1pbk1heFByb3BzKGxvd2VyLCB0aGlzLnZhbHVlLm1heCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfVxuICAgICAgICAvLyBXaGVuIHJhbmdlIC8gbWF4IHRodW1iIHJlYWNoZXMgdXBwZXIgbGltaXRcbiAgICAgICAgaWYgKG1heCA+IHVwcGVyKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLnRodW1iRHJhZykge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnNldE1pbk1heFByb3BzKHRoaXMudmFsdWUubWluIC0gdGhpcy52YWx1ZS5tYXggKyB1cHBlciwgdXBwZXIpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnNldE1pbk1heFByb3BzKHRoaXMudmFsdWUubWluLCB1cHBlcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnN0YXJ0UG9zID0gbGFzdFBvcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLnRodW1iRHJhZykge1xuICAgICAgICB0aGlzLnVwZGF0ZVJhbmdlTGltaXRzKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGFjdHVhbFN0ZXBWYWx1ZSgpIHtcbiAgICBjb25zdCBzdGVwID0gZmxvYXQodGhpcy5pbnB1dFswXS5zdGVwKTtcbiAgICByZXR1cm4gdGhpcy5pbnB1dFswXS5zdGVwID09PSBBTlkgPyBBTlkgOiBzdGVwID09PSAwIHx8IGlzTmFOKHN0ZXApID8gMSA6IHN0ZXA7XG4gIH1cblxuICAvLyBTdGVwIHZhbHVlICh1cCBvciBkb3duKSB1c2luZyBhcnJvdyBrZXlzXG4gIHN0ZXBWYWx1ZShpLCBrZXkpIHtcbiAgICBjb25zdCBkaXJlY3Rpb24gPSAoa2V5ID09PSAzNyB8fCBrZXkgPT09IDQwID8gLTEgOiAxKSAqIHRoaXMuaWZWZXJ0aWNhbEVsc2UoLTEsIDEpO1xuICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVkICYmICF0aGlzLm9wdGlvbnMudGh1bWJzRGlzYWJsZWRbdGhpcy5jdXJyZW50SW5kZXgoaSldKSB7XG4gICAgICBsZXQgc3RlcCA9IHRoaXMuYWN0dWFsU3RlcFZhbHVlKCk7XG4gICAgICBzdGVwID0gc3RlcCA9PT0gQU5ZID8gMSA6IHN0ZXA7XG4gICAgICBsZXQgbWluID0gdGhpcy52YWx1ZS5taW4gKyBzdGVwICogKHRoaXMuaW5kZXgubWluID09PSBpID8gZGlyZWN0aW9uIDogMCk7XG4gICAgICBsZXQgbWF4ID0gdGhpcy52YWx1ZS5tYXggKyBzdGVwICogKHRoaXMuaW5kZXgubWF4ID09PSBpID8gZGlyZWN0aW9uIDogMCk7XG5cbiAgICAgIC8vIFdoZW4gbWluIHRodW1iIHJlYWNoZXMgdXBwZXIgbGltaXRcbiAgICAgIGlmIChtaW4gPiB0aGlzLnJhbmdlTGltaXRzLm1heCkge1xuICAgICAgICBtaW4gPSB0aGlzLnJhbmdlTGltaXRzLm1heDtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBtYXggdGh1bWIgcmVhY2hlcyBsb3dlciBsaW1pdFxuICAgICAgaWYgKG1heCA8IHRoaXMucmFuZ2VMaW1pdHMubWluKSB7XG4gICAgICAgIG1heCA9IHRoaXMucmFuZ2VMaW1pdHMubWluO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRWYWx1ZSh7XG4gICAgICAgIG1pbixcbiAgICAgICAgbWF4XG4gICAgICB9LCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHZhciBfdGhpcyRwcm9wczUsIF90aGlzJHByb3BzNiwgX3RoaXMkcHJvcHM3LCBfdGhpcyRwcm9wczg7XG4gICAgLy8gU2V0IG9wdGlvbnMgdG8gZGVmYXVsdCB2YWx1ZXMgaWYgbm90IHNldFxuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ3JhbmdlU2xpZGVEaXNhYmxlZCcsIGZhbHNlKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCd0aHVtYnNEaXNhYmxlZCcsIFtmYWxzZSwgZmFsc2VdKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdvcmllbnRhdGlvbicsICdob3Jpem9udGFsJyk7XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgnZGVmYXVsdFZhbHVlJywgWzI1LCA3NV0pO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ2Rpc2FibGVkJywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ29uVGh1bWJEcmFnU3RhcnQnLCBmYWxzZSk7XG4gICAgdGhpcy5mYWxsYmFja1RvRGVmYXVsdCgnb25SYW5nZURyYWdTdGFydCcsIGZhbHNlKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdvblRodW1iRHJhZ0VuZCcsIGZhbHNlKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdvblJhbmdlRHJhZ0VuZCcsIGZhbHNlKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdvbklucHV0JywgZmFsc2UpO1xuICAgIHRoaXMuZmFsbGJhY2tUb0RlZmF1bHQoJ3N0ZXAnLCAxKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdtaW4nLCAwKTtcbiAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCdtYXgnLCAxMDApO1xuICAgIGlmICh0aGlzLnByb3BzLnZhbHVlKSB7XG4gICAgICB0aGlzLmZhbGxiYWNrVG9EZWZhdWx0KCd2YWx1ZScsIFsyNSwgNzVdKTtcbiAgICB9XG4gICAgdGhpcy5zYWZlTWluTWF4VmFsdWVzKCk7XG4gICAgdGhpcy5zYWZlVGh1bWJzRGlzYWJsZWRWYWx1ZXMoKTtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgXCJkYXRhLXRlc3RpZFwiOiBcImVsZW1lbnRcIixcbiAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgcmVmOiB0aGlzLmVsZW1lbnQsXG4gICAgICBjbGFzc05hbWU6ICgwLCBfY2xzeC5kZWZhdWx0KSgncmFuZ2Utc2xpZGVyJywgdGhpcy5wcm9wcy5jbGFzc05hbWUpXG4gICAgfSwgLyojX19QVVJFX18qL19yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwge1xuICAgICAgcmVmOiB0aGlzLnRodW1iWzBdLFxuICAgICAgcm9sZTogXCJzbGlkZXJcIixcbiAgICAgIGNsYXNzTmFtZTogXCJyYW5nZS1zbGlkZXJfX3RodW1iXCIsXG4gICAgICBcImRhdGEtbG93ZXJcIjogdHJ1ZSxcbiAgICAgIFwiYXJpYS1sYWJlbFwiOiAoX3RoaXMkcHJvcHM1ID0gdGhpcy5wcm9wcykgPT09IG51bGwgfHwgX3RoaXMkcHJvcHM1ID09PSB2b2lkIDAgfHwgKF90aGlzJHByb3BzNSA9IF90aGlzJHByb3BzNS5hcmlhTGFiZWwpID09PSBudWxsIHx8IF90aGlzJHByb3BzNSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHM1WzBdLFxuICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogKF90aGlzJHByb3BzNiA9IHRoaXMucHJvcHMpID09PSBudWxsIHx8IF90aGlzJHByb3BzNiA9PT0gdm9pZCAwIHx8IChfdGhpcyRwcm9wczYgPSBfdGhpcyRwcm9wczYuYXJpYUxhYmVsbGVkQnkpID09PSBudWxsIHx8IF90aGlzJHByb3BzNiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMkcHJvcHM2WzBdXG4gICAgfSksIC8qI19fUFVSRV9fKi9fcmVhY3QuZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICAgIHJlZjogdGhpcy50aHVtYlsxXSxcbiAgICAgIHJvbGU6IFwic2xpZGVyXCIsXG4gICAgICBjbGFzc05hbWU6IFwicmFuZ2Utc2xpZGVyX190aHVtYlwiLFxuICAgICAgXCJkYXRhLXVwcGVyXCI6IHRydWUsXG4gICAgICBcImFyaWEtbGFiZWxcIjogKF90aGlzJHByb3BzNyA9IHRoaXMucHJvcHMpID09PSBudWxsIHx8IF90aGlzJHByb3BzNyA9PT0gdm9pZCAwIHx8IChfdGhpcyRwcm9wczcgPSBfdGhpcyRwcm9wczcuYXJpYUxhYmVsKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzN1sxXSxcbiAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IChfdGhpcyRwcm9wczggPSB0aGlzLnByb3BzKSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczggPT09IHZvaWQgMCB8fCAoX3RoaXMkcHJvcHM4ID0gX3RoaXMkcHJvcHM4LmFyaWFMYWJlbGxlZEJ5KSA9PT0gbnVsbCB8fCBfdGhpcyRwcm9wczggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJHByb3BzOFsxXVxuICAgIH0pLCAvKiNfX1BVUkVfXyovX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgICByZWY6IHRoaXMucmFuZ2UsXG4gICAgICBjbGFzc05hbWU6IFwicmFuZ2Utc2xpZGVyX19yYW5nZVwiXG4gICAgfSkpO1xuICB9XG59XG47XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSBSYW5nZVNsaWRlcjsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/components/RangeSlider.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/index.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/index.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _RangeSlider = _interopRequireDefault(__webpack_require__(/*! ./components/RangeSlider */ \"(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/components/RangeSlider.js\"));\nfunction _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }\nvar _default = exports[\"default\"] = _RangeSlider.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0QDMuMi4xL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBZTtBQUNmLDBDQUEwQyxtQkFBTyxDQUFDLGdLQUEwQjtBQUM1RSxxQ0FBcUMsaUNBQWlDO0FBQ3RFLGVBQWUsa0JBQWUiLCJzb3VyY2VzIjpbIi9wcm9qZWN0cy9yZzM2MC9uZXctZWNvbW1lcmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXRAMy4yLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlLXNsaWRlci1pbnB1dC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xudmFyIF9SYW5nZVNsaWRlciA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIi4vY29tcG9uZW50cy9SYW5nZVNsaWRlclwiKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHsgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHsgZGVmYXVsdDogZSB9OyB9XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzLmRlZmF1bHQgPSBfUmFuZ2VTbGlkZXIuZGVmYXVsdDsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/style.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/style.css ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"10d9d40e0a14\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmFuZ2Utc2xpZGVyLWlucHV0QDMuMi4xL25vZGVfbW9kdWxlcy9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXQvZGlzdC9zdHlsZS5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIi9wcm9qZWN0cy9yZzM2MC9uZXctZWNvbW1lcmNlL2Zyb250ZW5kL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yYW5nZS1zbGlkZXItaW5wdXRAMy4yLjEvbm9kZV9tb2R1bGVzL3JlYWN0LXJhbmdlLXNsaWRlci1pbnB1dC9kaXN0L3N0eWxlLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjEwZDlkNDBlMGExNFwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-range-slider-input@3.2.1/node_modules/react-range-slider-input/dist/style.css\n");

/***/ })

};
;